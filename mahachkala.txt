-- ╔══════════════════════════════════════════════════════════════╗
-- ║            ARCANUM NEXTGEN  •  ESP MODULE                  ║
-- ║          Drawing API  •  Highlight Chams  •  Backtrack     ║
-- ╚══════════════════════════════════════════════════════════════╝

local ESPModule = {}
ESPModule.__index = ESPModule

local hasDrawing = Drawing and Drawing.new
local FONT = 2
pcall(function() FONT = Drawing.Fonts.Plex end)

local MAX_BT = 8
local BT_INTERVAL = 0.05

local BONES_R15 = {
    {"Head","UpperTorso"},
    {"UpperTorso","LowerTorso"},
    {"UpperTorso","LeftUpperArm"},{"LeftUpperArm","LeftLowerArm"},{"LeftLowerArm","LeftHand"},
    {"UpperTorso","RightUpperArm"},{"RightUpperArm","RightLowerArm"},{"RightLowerArm","RightHand"},
    {"LowerTorso","LeftUpperLeg"},{"LeftUpperLeg","LeftLowerLeg"},{"LeftLowerLeg","LeftFoot"},
    {"LowerTorso","RightUpperLeg"},{"RightUpperLeg","RightLowerLeg"},{"RightLowerLeg","RightFoot"},
}

local BONES_R6 = {
    {"Head","Torso"},
    {"Torso","Left Arm"},{"Torso","Right Arm"},
    {"Torso","Left Leg"},{"Torso","Right Leg"},
}

-- ════════════════════════════════════════
--  Drawing Helpers
-- ════════════════════════════════════════
local function newLine()
    if not hasDrawing then return nil end
    local l = Drawing.new("Line")
    l.Visible = false; l.Thickness = 1; l.Color = Color3.new(1,1,1)
    return l
end

local function newSquare(filled)
    if not hasDrawing then return nil end
    local s = Drawing.new("Square")
    s.Visible = false; s.Thickness = 1; s.Filled = filled or false
    s.Color = Color3.new(1,1,1)
    return s
end

local function newText()
    if not hasDrawing then return nil end
    local t = Drawing.new("Text")
    t.Visible = false; t.Color = Color3.new(1,1,1); t.Size = 13
    t.Center = true; t.Outline = true; t.OutlineColor = Color3.new(0,0,0)
    t.Font = FONT
    return t
end

local function rem(obj)
    if obj then pcall(function() obj:Remove() end) end
end

-- ════════════════════════════════════════
--  Constructor
-- ════════════════════════════════════════
function ESPModule.new(config)
    local self = setmetatable({}, ESPModule)

    self.player = config.Player
    self.Players = config.Services.Players
    self.RunService = config.Services.RunService
    self.Workspace = config.Services.Workspace or game:GetService("Workspace")

    self.ESP_ENABLED = false
    self.SELF_ESP = false
    self.TEAM_CHECK = true
    self.TEAM_HIDE = false

    self.BOX_ENABLED = false
    self.BOX_TYPE = "Corner"
    self.BOX_COLOR = Color3.new(1,1,1)
    self.BOX_FILL_ENABLED = false
    self.BOX_FILL_COLOR = Color3.fromRGB(130,85,255)
    self.BOX_FILL_TRANSPARENCY = 0.75

    self.HEALTH_ENABLED = true
    self.HEALTH_GRADIENT = true

    self.NAME_ENABLED = true
    self.NAME_COLOR = Color3.new(1,1,1)
    self.DISTANCE_ENABLED = true
    self.DISTANCE_COLOR = Color3.fromRGB(200,200,200)
    self.WEAPON_ENABLED = true
    self.WEAPON_COLOR = Color3.fromRGB(200,200,200)

    self.TRACERS_ENABLED = false
    self.TRACER_COLOR = Color3.new(1,1,1)
    self.TRACER_ORIGIN = "Bottom"
    self.TRACER_THICKNESS = 1

    self.SKELETON_ENABLED = false
    self.SKELETON_COLOR = Color3.new(1,1,1)
    self.SKELETON_THICKNESS = 1.5

    self.CHAMS_ENABLED = false
    self.CHAMS_TYPE = "Outline"
    self.CHAMS_OUTLINE_COLOR = Color3.fromRGB(130,85,255)
    self.CHAMS_FILL_COLOR = Color3.fromRGB(130,85,255)
    self.CHAMS_FILL_TRANSPARENCY = 0.5
    self.CHAMS_OUTLINE_TRANSPARENCY = 0
    self.CHAMS_DEPTH = "AlwaysOnTop"

    self.BACKTRACK_ENABLED = false
    self.BACKTRACK_COLOR = Color3.fromRGB(130,85,255)
    self.BACKTRACK_DURATION = 0.5
    self.BACKTRACK_TRANSPARENCY = 0.6

    self._data = {}
    self._connections = {}

    return self
end

-- ════════════════════════════════════════
--  Setters
-- ════════════════════════════════════════
function ESPModule:SetEnabled(v)            self.ESP_ENABLED = v end
function ESPModule:SetSelfESP(v)            self.SELF_ESP = v end
function ESPModule:SetTeamCheck(v)          self.TEAM_CHECK = v end
function ESPModule:SetTeamHide(v)           self.TEAM_HIDE = v end

function ESPModule:SetBoxEnabled(v)         self.BOX_ENABLED = v end
function ESPModule:SetBoxType(v)            self.BOX_TYPE = v end
function ESPModule:SetBoxColor(v)           self.BOX_COLOR = v end
function ESPModule:SetBoxFillEnabled(v)     self.BOX_FILL_ENABLED = v end
function ESPModule:SetBoxFillColor(v)       self.BOX_FILL_COLOR = v end
function ESPModule:SetBoxFillTransparency(v) self.BOX_FILL_TRANSPARENCY = v end

function ESPModule:SetHealthEnabled(v)      self.HEALTH_ENABLED = v end
function ESPModule:SetHealthGradient(v)     self.HEALTH_GRADIENT = v end

function ESPModule:SetNameEnabled(v)        self.NAME_ENABLED = v end
function ESPModule:SetNameColor(v)          self.NAME_COLOR = v end
function ESPModule:SetDistanceEnabled(v)    self.DISTANCE_ENABLED = v end
function ESPModule:SetDistanceColor(v)      self.DISTANCE_COLOR = v end
function ESPModule:SetWeaponEnabled(v)      self.WEAPON_ENABLED = v end
function ESPModule:SetWeaponColor(v)        self.WEAPON_COLOR = v end

function ESPModule:SetTracersEnabled(v)     self.TRACERS_ENABLED = v end
function ESPModule:SetTracerColor(v)        self.TRACER_COLOR = v end
function ESPModule:SetTracerOrigin(v)       self.TRACER_ORIGIN = v end
function ESPModule:SetTracerThickness(v)    self.TRACER_THICKNESS = v end

function ESPModule:SetSkeletonEnabled(v)    self.SKELETON_ENABLED = v end
function ESPModule:SetSkeletonColor(v)      self.SKELETON_COLOR = v end
function ESPModule:SetSkeletonThickness(v)  self.SKELETON_THICKNESS = v end

function ESPModule:SetChamsEnabled(v)       self.CHAMS_ENABLED = v end
function ESPModule:SetChamsType(v)          self.CHAMS_TYPE = v end
function ESPModule:SetChamsOutlineColor(v)  self.CHAMS_OUTLINE_COLOR = v end
function ESPModule:SetChamsFillColor(v)     self.CHAMS_FILL_COLOR = v end
function ESPModule:SetChamsFillTransparency(v) self.CHAMS_FILL_TRANSPARENCY = v end
function ESPModule:SetChamsOutlineTransparency(v) self.CHAMS_OUTLINE_TRANSPARENCY = v end
function ESPModule:SetChamsDepth(v)         self.CHAMS_DEPTH = v end

function ESPModule:SetBacktrackEnabled(v)   self.BACKTRACK_ENABLED = v end
function ESPModule:SetBacktrackColor(v)     self.BACKTRACK_COLOR = v end
function ESPModule:SetBacktrackDuration(v)  self.BACKTRACK_DURATION = v end
function ESPModule:SetBacktrackTransparency(v) self.BACKTRACK_TRANSPARENCY = v end

-- ════════════════════════════════════════
--  Utilities
-- ════════════════════════════════════════
function ESPModule:W2S(worldPos)
    local cam = self.Workspace.CurrentCamera
    if not cam then return nil, false end
    local v, onScreen = cam:WorldToViewportPoint(worldPos)
    if v.Z < 0 then return nil, false end
    return Vector2.new(v.X, v.Y), onScreen
end

function ESPModule:IsTeammate(plr)
    if not self.player.Team or not plr.Team then return false end
    return self.player.Team == plr.Team
end

function ESPModule:GetHealthColor(ratio)
    ratio = math.clamp(ratio, 0, 1)
    if ratio > 0.5 then
        return Color3.new(1 - (ratio - 0.5) * 2, 1, 0)
    end
    return Color3.new(1, ratio * 2, 0)
end

function ESPModule:GetBoundingBox(char)
    local cam = self.Workspace.CurrentCamera
    if not cam then return nil end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end

    local pos = root.Position
    local top = pos + Vector3.new(0, 3, 0)
    local btm = pos + Vector3.new(0, -3, 0)

    local ts, tv = cam:WorldToViewportPoint(top)
    local bs, bv = cam:WorldToViewportPoint(btm)
    if ts.Z < 0 and bs.Z < 0 then return nil end
    if not tv and not bv then return nil end

    local h = math.abs(bs.Y - ts.Y)
    local w = h * 0.55
    local cx = (ts.X + bs.X) * 0.5

    return {
        x = cx - w * 0.5,
        y = math.min(ts.Y, bs.Y),
        w = w,
        h = h,
        cx = cx,
        cy = (ts.Y + bs.Y) * 0.5,
    }
end

function ESPModule:GetWeaponName(char)
    for _, item in pairs(char:GetChildren()) do
        if item:IsA("Tool") then return item.Name end
    end
    return nil
end

-- ════════════════════════════════════════
--  Per-Player Data
-- ════════════════════════════════════════
function ESPModule:CreateData()
    local d = {
        fullBox = newSquare(false),
        boxFill = newSquare(true),
        corners = {},
        healthBg = newSquare(true),
        healthFill = newSquare(true),
        nameText = newText(),
        distText = newText(),
        weaponText = newText(),
        tracer = newLine(),
        bones = {},
        highlight = nil,
        btBoxes = {},
        btHistory = {},
        btLastRecord = 0,
    }

    for i = 1, 8 do d.corners[i] = newLine() end
    for i = 1, 14 do d.bones[i] = newLine() end
    for i = 1, MAX_BT do d.btBoxes[i] = newSquare(false) end

    return d
end

function ESPModule:DestroyData(plr)
    local d = self._data[plr]
    if not d then return end

    rem(d.fullBox); rem(d.boxFill)
    for _, l in ipairs(d.corners) do rem(l) end
    rem(d.healthBg); rem(d.healthFill)
    rem(d.nameText); rem(d.distText); rem(d.weaponText)
    rem(d.tracer)
    for _, l in ipairs(d.bones) do rem(l) end
    for _, s in ipairs(d.btBoxes) do rem(s) end
    if d.highlight then pcall(function() d.highlight:Destroy() end) end

    self._data[plr] = nil
end

function ESPModule:HideAll(d)
    if not hasDrawing then return end
    local function hide(obj) if obj then obj.Visible = false end end

    hide(d.fullBox); hide(d.boxFill)
    for _, l in ipairs(d.corners) do hide(l) end
    hide(d.healthBg); hide(d.healthFill)
    hide(d.nameText); hide(d.distText); hide(d.weaponText)
    hide(d.tracer)
    for _, l in ipairs(d.bones) do hide(l) end
    for _, s in ipairs(d.btBoxes) do hide(s) end
    if d.highlight then d.highlight.Enabled = false end
end

-- ════════════════════════════════════════
--  Component Updaters
-- ════════════════════════════════════════
function ESPModule:UpdateBox(d, bb)
    if not hasDrawing then return end

    if not self.BOX_ENABLED then
        if d.fullBox then d.fullBox.Visible = false end
        if d.boxFill then d.boxFill.Visible = false end
        for _, l in ipairs(d.corners) do if l then l.Visible = false end end
        return
    end

    local x, y, w, h = bb.x, bb.y, bb.w, bb.h

    if self.BOX_TYPE == "Full" then
        for _, l in ipairs(d.corners) do if l then l.Visible = false end end
        if d.fullBox then
            d.fullBox.Position = Vector2.new(x, y)
            d.fullBox.Size = Vector2.new(w, h)
            d.fullBox.Color = self.BOX_COLOR
            d.fullBox.Thickness = 1
            d.fullBox.Visible = true
        end
    else
        if d.fullBox then d.fullBox.Visible = false end
        local cl = math.max(w * 0.25, 6)
        local pts = {
            {Vector2.new(x, y), Vector2.new(x + cl, y)},
            {Vector2.new(x, y), Vector2.new(x, y + cl)},
            {Vector2.new(x + w, y), Vector2.new(x + w - cl, y)},
            {Vector2.new(x + w, y), Vector2.new(x + w, y + cl)},
            {Vector2.new(x, y + h), Vector2.new(x + cl, y + h)},
            {Vector2.new(x, y + h), Vector2.new(x, y + h - cl)},
            {Vector2.new(x + w, y + h), Vector2.new(x + w - cl, y + h)},
            {Vector2.new(x + w, y + h), Vector2.new(x + w, y + h - cl)},
        }
        for i = 1, 8 do
            local l = d.corners[i]
            if l then
                l.From = pts[i][1]; l.To = pts[i][2]
                l.Color = self.BOX_COLOR; l.Thickness = 1; l.Visible = true
            end
        end
    end

    if d.boxFill then
        if self.BOX_FILL_ENABLED then
            d.boxFill.Position = Vector2.new(x, y)
            d.boxFill.Size = Vector2.new(w, h)
            d.boxFill.Color = self.BOX_FILL_COLOR
            d.boxFill.Transparency = self.BOX_FILL_TRANSPARENCY
            d.boxFill.Visible = true
        else
            d.boxFill.Visible = false
        end
    end
end

function ESPModule:UpdateHealth(d, bb, hum)
    if not hasDrawing then return end
    if not self.HEALTH_ENABLED or not hum then
        if d.healthBg then d.healthBg.Visible = false end
        if d.healthFill then d.healthFill.Visible = false end
        return
    end

    local ratio = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
    local barW = 3
    local x = bb.x - barW - 3
    local y = bb.y
    local h = bb.h

    if d.healthBg then
        d.healthBg.Position = Vector2.new(x, y)
        d.healthBg.Size = Vector2.new(barW, h)
        d.healthBg.Color = Color3.fromRGB(20, 20, 20)
        d.healthBg.Transparency = 0.3
        d.healthBg.Visible = true
    end

    if d.healthFill then
        local fh = h * ratio
        d.healthFill.Position = Vector2.new(x, y + h - fh)
        d.healthFill.Size = Vector2.new(barW, fh)
        d.healthFill.Color = self.HEALTH_GRADIENT and self:GetHealthColor(ratio) or Color3.fromRGB(80, 255, 80)
        d.healthFill.Transparency = 0
        d.healthFill.Visible = true
    end
end

function ESPModule:UpdateInfo(d, bb, targetPlayer, distance, char)
    if not hasDrawing then return end

    local yAbove = bb.y - 2
    local yBelow = bb.y + bb.h + 2

    if self.NAME_ENABLED and d.nameText then
        d.nameText.Text = targetPlayer.DisplayName
        d.nameText.Color = self.NAME_COLOR
        d.nameText.Size = 13
        yAbove = yAbove - 14
        d.nameText.Position = Vector2.new(bb.cx, yAbove)
        d.nameText.Visible = true
    elseif d.nameText then
        d.nameText.Visible = false
    end

    if self.DISTANCE_ENABLED and d.distText then
        d.distText.Text = string.format("%dm", math.floor(distance))
        d.distText.Color = self.DISTANCE_COLOR
        d.distText.Size = 12
        d.distText.Position = Vector2.new(bb.cx, yBelow)
        d.distText.Visible = true
        yBelow = yBelow + 13
    elseif d.distText then
        d.distText.Visible = false
    end

    if self.WEAPON_ENABLED and d.weaponText then
        local wep = self:GetWeaponName(char)
        if wep then
            d.weaponText.Text = wep
            d.weaponText.Color = self.WEAPON_COLOR
            d.weaponText.Size = 11
            d.weaponText.Position = Vector2.new(bb.cx, yBelow)
            d.weaponText.Visible = true
        else
            d.weaponText.Visible = false
        end
    elseif d.weaponText then
        d.weaponText.Visible = false
    end
end

function ESPModule:UpdateTracer(d, bb, vpSize)
    if not hasDrawing or not d.tracer then return end
    if not self.TRACERS_ENABLED then d.tracer.Visible = false; return end

    local fromX, fromY
    if self.TRACER_ORIGIN == "Top" then
        fromX, fromY = vpSize.X * 0.5, 0
    elseif self.TRACER_ORIGIN == "Center" then
        fromX, fromY = vpSize.X * 0.5, vpSize.Y * 0.5
    else
        fromX, fromY = vpSize.X * 0.5, vpSize.Y
    end

    d.tracer.From = Vector2.new(fromX, fromY)
    d.tracer.To = Vector2.new(bb.cx, bb.y + bb.h)
    d.tracer.Color = self.TRACER_COLOR
    d.tracer.Thickness = self.TRACER_THICKNESS
    d.tracer.Visible = true
end

function ESPModule:UpdateSkeleton(d, char, camera)
    if not hasDrawing then return end
    if not self.SKELETON_ENABLED then
        for _, l in ipairs(d.bones) do if l then l.Visible = false end end
        return
    end

    local isR15 = char:FindFirstChild("UpperTorso") ~= nil
    local boneList = isR15 and BONES_R15 or BONES_R6
    local idx = 0

    for _, pair in ipairs(boneList) do
        idx = idx + 1
        local l = d.bones[idx]
        if not l then continue end

        local p1 = char:FindFirstChild(pair[1])
        local p2 = char:FindFirstChild(pair[2])

        if p1 and p2 then
            local s1, v1 = self:W2S(p1.Position)
            local s2, v2 = self:W2S(p2.Position)
            if s1 and s2 and (v1 or v2) then
                l.From = s1; l.To = s2
                l.Color = self.SKELETON_COLOR
                l.Thickness = self.SKELETON_THICKNESS
                l.Visible = true
            else
                l.Visible = false
            end
        else
            l.Visible = false
        end
    end

    for i = idx + 1, #d.bones do
        if d.bones[i] then d.bones[i].Visible = false end
    end
end

function ESPModule:UpdateChams(d, char, targetPlayer)
    if not self.CHAMS_ENABLED then
        if d.highlight then d.highlight.Enabled = false end
        return
    end

    if not d.highlight then
        local ok, hl = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ArcanumChams"
            return h
        end)
        if ok and hl then d.highlight = hl else return end
    end

    local hl = d.highlight
    hl.Adornee = char
    hl.Parent = char

    local t = self.CHAMS_TYPE
    if t == "Outline" then
        hl.FillTransparency = 1
        hl.OutlineTransparency = self.CHAMS_OUTLINE_TRANSPARENCY
        hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
    elseif t == "Solid" then
        hl.FillTransparency = self.CHAMS_FILL_TRANSPARENCY
        hl.FillColor = self.CHAMS_FILL_COLOR
        hl.OutlineTransparency = 1
    elseif t == "Outline+Solid" then
        hl.FillTransparency = self.CHAMS_FILL_TRANSPARENCY
        hl.FillColor = self.CHAMS_FILL_COLOR
        hl.OutlineTransparency = self.CHAMS_OUTLINE_TRANSPARENCY
        hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
    elseif t == "Glow" then
        hl.FillTransparency = 0.3
        hl.FillColor = self.CHAMS_FILL_COLOR
        hl.OutlineTransparency = 0
        hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
    elseif t == "Wireframe" then
        hl.FillTransparency = 1
        hl.OutlineTransparency = 0
        hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
        hl.DepthMode = Enum.HighlightDepthMode.Occluded
    end

    if t ~= "Wireframe" then
        hl.DepthMode = self.CHAMS_DEPTH == "AlwaysOnTop"
            and Enum.HighlightDepthMode.AlwaysOnTop
            or Enum.HighlightDepthMode.Occluded
    end

    hl.Enabled = true
end

function ESPModule:UpdateBacktrack(d, char, camera, root, targetPlayer)
    if not hasDrawing then return end

    local shouldShow = self.BACKTRACK_ENABLED
    if shouldShow and self.TEAM_CHECK and self:IsTeammate(targetPlayer) then
        shouldShow = false
    end

    if not shouldShow then
        for _, s in ipairs(d.btBoxes) do if s then s.Visible = false end end
        d.btHistory = {}
        return
    end

    local now = tick()
    if now - d.btLastRecord >= BT_INTERVAL then
        d.btLastRecord = now
        table.insert(d.btHistory, { t = now, pos = root.Position })

        while #d.btHistory > 0 and (now - d.btHistory[1].t) > self.BACKTRACK_DURATION do
            table.remove(d.btHistory, 1)
        end
    end

    local count = math.min(#d.btHistory, MAX_BT)
    for i = 1, MAX_BT do
        local s = d.btBoxes[i]
        if not s then continue end

        if i <= count then
            local entry = d.btHistory[#d.btHistory - count + i]
            if entry then
                local top = entry.pos + Vector3.new(0, 3, 0)
                local btm = entry.pos + Vector3.new(0, -3, 0)
                local ts = camera:WorldToViewportPoint(top)
                local bs = camera:WorldToViewportPoint(btm)
                if ts.Z > 0 and bs.Z > 0 then
                    local h = math.abs(bs.Y - ts.Y)
                    local w = h * 0.55
                    local cx = (ts.X + bs.X) * 0.5
                    local age = (now - entry.t) / self.BACKTRACK_DURATION
                    s.Position = Vector2.new(cx - w * 0.5, math.min(ts.Y, bs.Y))
                    s.Size = Vector2.new(w, h)
                    s.Color = self.BACKTRACK_COLOR
                    s.Transparency = self.BACKTRACK_TRANSPARENCY + age * (1 - self.BACKTRACK_TRANSPARENCY)
                    s.Visible = true
                else
                    s.Visible = false
                end
            else
                s.Visible = false
            end
        else
            s.Visible = false
        end
    end
end

-- ════════════════════════════════════════
--  Main Loop
-- ════════════════════════════════════════
function ESPModule:Update()
    local cam = self.Workspace.CurrentCamera
    if not cam then return end

    local myChar = self.player.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local myPos = myRoot and myRoot.Position
    local vpSize = cam.ViewportSize

    for _, plr in ipairs(self.Players:GetPlayers()) do
        local d = self._data[plr]
        if not d then
            d = self:CreateData()
            self._data[plr] = d
        end

        local show = self.ESP_ENABLED
        if plr == self.player and not self.SELF_ESP then show = false end

        local isTeammate = self.TEAM_CHECK and self:IsTeammate(plr)
        if show and isTeammate and self.TEAM_HIDE then show = false end

        local char = plr.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local root = char and char:FindFirstChild("HumanoidRootPart")

        if not show or not char or not hum or hum.Health <= 0 or not root then
            self:HideAll(d)
            continue
        end

        local bb = self:GetBoundingBox(char)
        if not bb then
            self:HideAll(d)
            continue
        end

        local dist = myPos and (root.Position - myPos).Magnitude or 0

        self:UpdateBox(d, bb)
        self:UpdateHealth(d, bb, hum)
        self:UpdateInfo(d, bb, plr, dist, char)
        self:UpdateTracer(d, bb, vpSize)
        self:UpdateSkeleton(d, char, cam)
        self:UpdateChams(d, char, plr)
        self:UpdateBacktrack(d, char, cam, root, plr)
    end

    for plr, _ in pairs(self._data) do
        if not plr.Parent then
            self:DestroyData(plr)
        end
    end
end

-- ════════════════════════════════════════
--  Start / Stop / Destroy
-- ════════════════════════════════════════
function ESPModule:Start()
    if self._renderConn then return end

    self._renderConn = self.RunService.RenderStepped:Connect(function()
        pcall(function() self:Update() end)
    end)

    self._playerLeftConn = self.Players.PlayerRemoving:Connect(function(plr)
        self:DestroyData(plr)
    end)
end

function ESPModule:Stop()
    if self._renderConn then self._renderConn:Disconnect(); self._renderConn = nil end
    if self._playerLeftConn then self._playerLeftConn:Disconnect(); self._playerLeftConn = nil end
end

function ESPModule:Destroy()
    self:Stop()
    for plr, _ in pairs(self._data) do
        self:DestroyData(plr)
    end
end

-- ════════════════════════════════════════
--  Config
-- ════════════════════════════════════════
local function c3str(c) return {R = c.R, G = c.G, B = c.B} end
local function strc3(t)
    if not t then return nil end
    return Color3.new(t.R or 1, t.G or 1, t.B or 1)
end

function ESPModule:GetSettings()
    return {
        ESP_ENABLED = self.ESP_ENABLED,
        SELF_ESP = self.SELF_ESP,
        TEAM_CHECK = self.TEAM_CHECK,
        TEAM_HIDE = self.TEAM_HIDE,
        BOX_ENABLED = self.BOX_ENABLED,
        BOX_TYPE = self.BOX_TYPE,
        BOX_COLOR = c3str(self.BOX_COLOR),
        BOX_FILL_ENABLED = self.BOX_FILL_ENABLED,
        BOX_FILL_COLOR = c3str(self.BOX_FILL_COLOR),
        BOX_FILL_TRANSPARENCY = self.BOX_FILL_TRANSPARENCY,
        HEALTH_ENABLED = self.HEALTH_ENABLED,
        HEALTH_GRADIENT = self.HEALTH_GRADIENT,
        NAME_ENABLED = self.NAME_ENABLED,
        NAME_COLOR = c3str(self.NAME_COLOR),
        DISTANCE_ENABLED = self.DISTANCE_ENABLED,
        DISTANCE_COLOR = c3str(self.DISTANCE_COLOR),
        WEAPON_ENABLED = self.WEAPON_ENABLED,
        WEAPON_COLOR = c3str(self.WEAPON_COLOR),
        TRACERS_ENABLED = self.TRACERS_ENABLED,
        TRACER_COLOR = c3str(self.TRACER_COLOR),
        TRACER_ORIGIN = self.TRACER_ORIGIN,
        TRACER_THICKNESS = self.TRACER_THICKNESS,
        SKELETON_ENABLED = self.SKELETON_ENABLED,
        SKELETON_COLOR = c3str(self.SKELETON_COLOR),
        SKELETON_THICKNESS = self.SKELETON_THICKNESS,
        CHAMS_ENABLED = self.CHAMS_ENABLED,
        CHAMS_TYPE = self.CHAMS_TYPE,
        CHAMS_OUTLINE_COLOR = c3str(self.CHAMS_OUTLINE_COLOR),
        CHAMS_FILL_COLOR = c3str(self.CHAMS_FILL_COLOR),
        CHAMS_FILL_TRANSPARENCY = self.CHAMS_FILL_TRANSPARENCY,
        CHAMS_OUTLINE_TRANSPARENCY = self.CHAMS_OUTLINE_TRANSPARENCY,
        CHAMS_DEPTH = self.CHAMS_DEPTH,
        BACKTRACK_ENABLED = self.BACKTRACK_ENABLED,
        BACKTRACK_COLOR = c3str(self.BACKTRACK_COLOR),
        BACKTRACK_DURATION = self.BACKTRACK_DURATION,
        BACKTRACK_TRANSPARENCY = self.BACKTRACK_TRANSPARENCY,
    }
end

function ESPModule:ApplySettings(s)
    if not s then return end
    local function apply(key, setter)
        if s[key] ~= nil then setter(s[key]) end
    end
    local function applyC3(key, setter)
        if s[key] then setter(strc3(s[key])) end
    end

    apply("ESP_ENABLED", function(v) self:SetEnabled(v) end)
    apply("SELF_ESP", function(v) self:SetSelfESP(v) end)
    apply("TEAM_CHECK", function(v) self:SetTeamCheck(v) end)
    apply("TEAM_HIDE", function(v) self:SetTeamHide(v) end)
    apply("BOX_ENABLED", function(v) self:SetBoxEnabled(v) end)
    apply("BOX_TYPE", function(v) self:SetBoxType(v) end)
    applyC3("BOX_COLOR", function(v) self:SetBoxColor(v) end)
    apply("BOX_FILL_ENABLED", function(v) self:SetBoxFillEnabled(v) end)
    applyC3("BOX_FILL_COLOR", function(v) self:SetBoxFillColor(v) end)
    apply("BOX_FILL_TRANSPARENCY", function(v) self:SetBoxFillTransparency(v) end)
    apply("HEALTH_ENABLED", function(v) self:SetHealthEnabled(v) end)
    apply("HEALTH_GRADIENT", function(v) self:SetHealthGradient(v) end)
    apply("NAME_ENABLED", function(v) self:SetNameEnabled(v) end)
    applyC3("NAME_COLOR", function(v) self:SetNameColor(v) end)
    apply("DISTANCE_ENABLED", function(v) self:SetDistanceEnabled(v) end)
    applyC3("DISTANCE_COLOR", function(v) self:SetDistanceColor(v) end)
    apply("WEAPON_ENABLED", function(v) self:SetWeaponEnabled(v) end)
    applyC3("WEAPON_COLOR", function(v) self:SetWeaponColor(v) end)
    apply("TRACERS_ENABLED", function(v) self:SetTracersEnabled(v) end)
    applyC3("TRACER_COLOR", function(v) self:SetTracerColor(v) end)
    apply("TRACER_ORIGIN", function(v) self:SetTracerOrigin(v) end)
    apply("TRACER_THICKNESS", function(v) self:SetTracerThickness(v) end)
    apply("SKELETON_ENABLED", function(v) self:SetSkeletonEnabled(v) end)
    applyC3("SKELETON_COLOR", function(v) self:SetSkeletonColor(v) end)
    apply("SKELETON_THICKNESS", function(v) self:SetSkeletonThickness(v) end)
    apply("CHAMS_ENABLED", function(v) self:SetChamsEnabled(v) end)
    apply("CHAMS_TYPE", function(v) self:SetChamsType(v) end)
    applyC3("CHAMS_OUTLINE_COLOR", function(v) self:SetChamsOutlineColor(v) end)
    applyC3("CHAMS_FILL_COLOR", function(v) self:SetChamsFillColor(v) end)
    apply("CHAMS_FILL_TRANSPARENCY", function(v) self:SetChamsFillTransparency(v) end)
    apply("CHAMS_OUTLINE_TRANSPARENCY", function(v) self:SetChamsOutlineTransparency(v) end)
    apply("CHAMS_DEPTH", function(v) self:SetChamsDepth(v) end)
    apply("BACKTRACK_ENABLED", function(v) self:SetBacktrackEnabled(v) end)
    applyC3("BACKTRACK_COLOR", function(v) self:SetBacktrackColor(v) end)
    apply("BACKTRACK_DURATION", function(v) self:SetBacktrackDuration(v) end)
    apply("BACKTRACK_TRANSPARENCY", function(v) self:SetBacktrackTransparency(v) end)
end

return ESPModule
