-- ╔══════════════════════════════════════════════════════════════╗
-- ║            ARCANUM NEXTGEN  •  ESP MODULE  (Optimized)     ║
-- ║          Drawing API  •  Highlight Chams  •  Backtrack     ║
-- ╚══════════════════════════════════════════════════════════════╝

local ESPModule = {}
ESPModule.__index = ESPModule

local hasDrawing = Drawing and Drawing.new
local FONT = 2
pcall(function() FONT = Drawing.Fonts.Plex end)

local MAX_BT = 8
local BT_INTERVAL = 0.05

local BONES_R15 = {
    {"Head","UpperTorso"},
    {"UpperTorso","LowerTorso"},
    {"UpperTorso","LeftUpperArm"},{"LeftUpperArm","LeftLowerArm"},{"LeftLowerArm","LeftHand"},
    {"UpperTorso","RightUpperArm"},{"RightUpperArm","RightLowerArm"},{"RightLowerArm","RightHand"},
    {"LowerTorso","LeftUpperLeg"},{"LeftUpperLeg","LeftLowerLeg"},{"LeftLowerLeg","LeftFoot"},
    {"LowerTorso","RightUpperLeg"},{"RightUpperLeg","RightLowerLeg"},{"RightLowerLeg","RightFoot"},
}

local BONES_R6 = {
    {"Head","Torso"},
    {"Torso","Left Arm"},{"Torso","Right Arm"},
    {"Torso","Left Leg"},{"Torso","Right Leg"},
}

-- ════════════════════════════════════════
--  Drawing Helpers
-- ════════════════════════════════════════
local function newLine()
    if not hasDrawing then return nil end
    local l = Drawing.new("Line")
    l.Visible = false; l.Thickness = 1; l.Color = Color3.new(1,1,1)
    return l
end

local function newSquare(filled)
    if not hasDrawing then return nil end
    local s = Drawing.new("Square")
    s.Visible = false; s.Thickness = 1; s.Filled = filled or false
    s.Color = Color3.new(1,1,1)
    return s
end

local function newText()
    if not hasDrawing then return nil end
    local t = Drawing.new("Text")
    t.Visible = false; t.Color = Color3.new(1,1,1); t.Size = 13
    t.Center = true; t.Outline = true; t.OutlineColor = Color3.new(0,0,0)
    t.Font = FONT
    return t
end

local function rem(obj)
    if obj then pcall(function() obj:Remove() end) end
end

-- ════════════════════════════════════════
--  Constructor
-- ════════════════════════════════════════
function ESPModule.new(config)
    local self = setmetatable({}, ESPModule)

    self.player = config.Player
    self.Players = config.Services.Players
    self.RunService = config.Services.RunService
    self.Workspace = config.Services.Workspace or game:GetService("Workspace")

    self.ESP_ENABLED = false
    self.SELF_ESP = false
    self.TEAM_CHECK = true
    self.TEAM_HIDE = false

    self.BOX_ENABLED = false
    self.BOX_TYPE = "Corner"
    self.BOX_COLOR = Color3.new(1,1,1)
    self.BOX_FILL_ENABLED = false
    self.BOX_FILL_COLOR = Color3.fromRGB(130,85,255)
    self.BOX_FILL_TRANSPARENCY = 0.75

    self.HEALTH_ENABLED = true
    self.HEALTH_GRADIENT = true
    self.HEALTH_LOW_COLOR = Color3.fromRGB(255, 50, 50)
    self.HEALTH_HIGH_COLOR = Color3.fromRGB(80, 255, 80)

    self.NAME_ENABLED = true
    self.NAME_COLOR = Color3.new(1,1,1)
    self.DISTANCE_ENABLED = true
    self.DISTANCE_COLOR = Color3.fromRGB(200,200,200)
    self.WEAPON_ENABLED = true
    self.WEAPON_COLOR = Color3.fromRGB(200,200,200)

    self.TRACERS_ENABLED = false
    self.TRACER_COLOR = Color3.new(1,1,1)
    self.TRACER_ORIGIN = "Bottom"
    self.TRACER_THICKNESS = 1

    self.SKELETON_ENABLED = false
    self.SKELETON_COLOR = Color3.new(1,1,1)
    self.SKELETON_THICKNESS = 1.5

    self.CHAMS_ENABLED = false
    self.CHAMS_TYPE = "Outline"
    self.CHAMS_OUTLINE_COLOR = Color3.fromRGB(130,85,255)
    self.CHAMS_FILL_COLOR = Color3.fromRGB(130,85,255)
    self.CHAMS_FILL_TRANSPARENCY = 0.5
    self.CHAMS_OUTLINE_TRANSPARENCY = 0
    self.CHAMS_DEPTH = "AlwaysOnTop"

    self.BACKTRACK_ENABLED = false
    self.BACKTRACK_COLOR = Color3.fromRGB(130,85,255)
    self.BACKTRACK_DURATION = 0.5
    self.BACKTRACK_TRANSPARENCY = 0.6

    self._data = {}
    self._connections = {}

    -- Cached player list
    self._playerCache = {}
    self._playerCacheTick = 0
    self._PLAYER_CACHE_RATE = 0.25

    -- Max ESP render distance (studs)
    self._MAX_ESP_DIST = 2000

    return self
end

-- ════════════════════════════════════════
--  Setters
-- ════════════════════════════════════════
function ESPModule:SetEnabled(v)            self.ESP_ENABLED = v end
function ESPModule:SetSelfESP(v)            self.SELF_ESP = v end
function ESPModule:SetTeamCheck(v)          self.TEAM_CHECK = v end
function ESPModule:SetTeamHide(v)           self.TEAM_HIDE = v end

function ESPModule:SetBoxEnabled(v)         self.BOX_ENABLED = v end
function ESPModule:SetBoxType(v)            self.BOX_TYPE = v end
function ESPModule:SetBoxColor(v)           self.BOX_COLOR = v end
function ESPModule:SetBoxFillEnabled(v)     self.BOX_FILL_ENABLED = v end
function ESPModule:SetBoxFillColor(v)       self.BOX_FILL_COLOR = v end
function ESPModule:SetBoxFillTransparency(v) self.BOX_FILL_TRANSPARENCY = v end

function ESPModule:SetHealthEnabled(v)      self.HEALTH_ENABLED = v end
function ESPModule:SetHealthGradient(v)     self.HEALTH_GRADIENT = v end
function ESPModule:SetHealthLowColor(v)     self.HEALTH_LOW_COLOR = v end
function ESPModule:SetHealthHighColor(v)    self.HEALTH_HIGH_COLOR = v end

function ESPModule:SetNameEnabled(v)        self.NAME_ENABLED = v end
function ESPModule:SetNameColor(v)          self.NAME_COLOR = v end
function ESPModule:SetDistanceEnabled(v)    self.DISTANCE_ENABLED = v end
function ESPModule:SetDistanceColor(v)      self.DISTANCE_COLOR = v end
function ESPModule:SetWeaponEnabled(v)      self.WEAPON_ENABLED = v end
function ESPModule:SetWeaponColor(v)        self.WEAPON_COLOR = v end

function ESPModule:SetTracersEnabled(v)     self.TRACERS_ENABLED = v end
function ESPModule:SetTracerColor(v)        self.TRACER_COLOR = v end
function ESPModule:SetTracerOrigin(v)       self.TRACER_ORIGIN = v end
function ESPModule:SetTracerThickness(v)    self.TRACER_THICKNESS = v end

function ESPModule:SetSkeletonEnabled(v)    self.SKELETON_ENABLED = v end
function ESPModule:SetSkeletonColor(v)      self.SKELETON_COLOR = v end
function ESPModule:SetSkeletonThickness(v)  self.SKELETON_THICKNESS = v end

function ESPModule:SetChamsEnabled(v)       self.CHAMS_ENABLED = v end
function ESPModule:SetChamsType(v)          self.CHAMS_TYPE = v end
function ESPModule:SetChamsOutlineColor(v)  self.CHAMS_OUTLINE_COLOR = v end
function ESPModule:SetChamsFillColor(v)     self.CHAMS_FILL_COLOR = v end
function ESPModule:SetChamsFillTransparency(v) self.CHAMS_FILL_TRANSPARENCY = v end
function ESPModule:SetChamsOutlineTransparency(v) self.CHAMS_OUTLINE_TRANSPARENCY = v end
function ESPModule:SetChamsDepth(v)         self.CHAMS_DEPTH = v end

function ESPModule:SetBacktrackEnabled(v)   self.BACKTRACK_ENABLED = v end
function ESPModule:SetBacktrackColor(v)     self.BACKTRACK_COLOR = v end
function ESPModule:SetBacktrackDuration(v)  self.BACKTRACK_DURATION = v end
function ESPModule:SetBacktrackTransparency(v) self.BACKTRACK_TRANSPARENCY = v end

-- ════════════════════════════════════════
--  Utilities
-- ════════════════════════════════════════
function ESPModule:IsTeammate(plr)
    if not self.player.Team or not plr.Team then return false end
    return self.player.Team == plr.Team
end

function ESPModule:GetHealthColor(ratio)
    local lo = self.HEALTH_LOW_COLOR
    local hi = self.HEALTH_HIGH_COLOR
    return Color3.new(
        lo.R + (hi.R - lo.R) * ratio,
        lo.G + (hi.G - lo.G) * ratio,
        lo.B + (hi.B - lo.B) * ratio
    )
end

function ESPModule:GetBoundingBox(root, cam)
    local pos = root.Position
    local top = pos + Vector3.new(0, 3, 0)
    local btm = pos + Vector3.new(0, -3, 0)

    local ts, tv = cam:WorldToViewportPoint(top)
    local bs, bv = cam:WorldToViewportPoint(btm)
    if ts.Z < 0 and bs.Z < 0 then return nil end
    if not tv and not bv then return nil end

    local h = math.abs(bs.Y - ts.Y)
    local w = h * 0.55
    local cx = (ts.X + bs.X) * 0.5

    return {
        x = cx - w * 0.5,
        y = math.min(ts.Y, bs.Y),
        w = w,
        h = h,
        cx = cx,
        cy = (ts.Y + bs.Y) * 0.5,
    }
end

-- ════════════════════════════════════════
--  Per-Player Data
-- ════════════════════════════════════════
function ESPModule:CreateData()
    local d = {
        fullBox = newSquare(false),
        boxFill = newSquare(true),
        corners = {},
        healthBg = newSquare(true),
        healthFill = newSquare(true),
        nameText = newText(),
        distText = newText(),
        weaponText = newText(),
        tracer = newLine(),
        bones = {},
        highlight = nil,
        btGhost = nil,
        btHighlight = nil,
        btGhostTime = 0,
        btHistory = {},
        btHead = 1,
        btTail = 0,
        btLastRecord = 0,
        cachedWeapon = nil,
        cachedWeaponTick = 0,
        lastChamsType = nil,
        lastChamsDepth = nil,
    }

    for i = 1, 8 do d.corners[i] = newLine() end
    for i = 1, 14 do d.bones[i] = newLine() end

    return d
end

function ESPModule:DestroyData(plr)
    local d = self._data[plr]
    if not d then return end

    rem(d.fullBox); rem(d.boxFill)
    for _, l in ipairs(d.corners) do rem(l) end
    rem(d.healthBg); rem(d.healthFill)
    rem(d.nameText); rem(d.distText); rem(d.weaponText)
    rem(d.tracer)
    for _, l in ipairs(d.bones) do rem(l) end
    if d.btGhost then pcall(function() d.btGhost:Destroy() end) end
    if d.btHighlight then pcall(function() d.btHighlight:Destroy() end) end
    if d.highlight then pcall(function() d.highlight:Destroy() end) end

    self._data[plr] = nil
end

function ESPModule:HideAll(d)
    if not hasDrawing then return end

    if d.fullBox then d.fullBox.Visible = false end
    if d.boxFill then d.boxFill.Visible = false end
    for i = 1, 8 do local l = d.corners[i]; if l then l.Visible = false end end
    if d.healthBg then d.healthBg.Visible = false end
    if d.healthFill then d.healthFill.Visible = false end
    if d.nameText then d.nameText.Visible = false end
    if d.distText then d.distText.Visible = false end
    if d.weaponText then d.weaponText.Visible = false end
    if d.tracer then d.tracer.Visible = false end
    for i = 1, #d.bones do local l = d.bones[i]; if l then l.Visible = false end end
    if d.btGhost then d.btGhost.Parent = nil end
    if d.btHighlight then d.btHighlight.Enabled = false end
    if d.highlight then d.highlight.Enabled = false end
end

-- ════════════════════════════════════════
--  Component Updaters
-- ════════════════════════════════════════
function ESPModule:UpdateBox(d, bb)
    if not hasDrawing then return end

    if not self.BOX_ENABLED then
        if d.fullBox then d.fullBox.Visible = false end
        if d.boxFill then d.boxFill.Visible = false end
        for i = 1, 8 do local l = d.corners[i]; if l then l.Visible = false end end
        return
    end

    local x, y, w, h = bb.x, bb.y, bb.w, bb.h

    if self.BOX_TYPE == "Full" then
        for i = 1, 8 do local l = d.corners[i]; if l then l.Visible = false end end
        if d.fullBox then
            d.fullBox.Position = Vector2.new(x, y)
            d.fullBox.Size = Vector2.new(w, h)
            d.fullBox.Color = self.BOX_COLOR
            d.fullBox.Thickness = 1
            d.fullBox.Visible = true
        end
    else
        if d.fullBox then d.fullBox.Visible = false end
        local cl = math.max(w * 0.25, 6)
        local xw, yh = x + w, y + h

        local c = d.corners
        if c[1] then c[1].From = Vector2.new(x, y);   c[1].To = Vector2.new(x + cl, y);   c[1].Color = self.BOX_COLOR; c[1].Visible = true end
        if c[2] then c[2].From = Vector2.new(x, y);   c[2].To = Vector2.new(x, y + cl);   c[2].Color = self.BOX_COLOR; c[2].Visible = true end
        if c[3] then c[3].From = Vector2.new(xw, y);  c[3].To = Vector2.new(xw - cl, y);  c[3].Color = self.BOX_COLOR; c[3].Visible = true end
        if c[4] then c[4].From = Vector2.new(xw, y);  c[4].To = Vector2.new(xw, y + cl);  c[4].Color = self.BOX_COLOR; c[4].Visible = true end
        if c[5] then c[5].From = Vector2.new(x, yh);  c[5].To = Vector2.new(x + cl, yh);  c[5].Color = self.BOX_COLOR; c[5].Visible = true end
        if c[6] then c[6].From = Vector2.new(x, yh);  c[6].To = Vector2.new(x, yh - cl);  c[6].Color = self.BOX_COLOR; c[6].Visible = true end
        if c[7] then c[7].From = Vector2.new(xw, yh); c[7].To = Vector2.new(xw - cl, yh); c[7].Color = self.BOX_COLOR; c[7].Visible = true end
        if c[8] then c[8].From = Vector2.new(xw, yh); c[8].To = Vector2.new(xw, yh - cl); c[8].Color = self.BOX_COLOR; c[8].Visible = true end
    end

    if d.boxFill then
        if self.BOX_FILL_ENABLED then
            d.boxFill.Position = Vector2.new(x, y)
            d.boxFill.Size = Vector2.new(w, h)
            d.boxFill.Color = self.BOX_FILL_COLOR
            d.boxFill.Transparency = self.BOX_FILL_TRANSPARENCY
            d.boxFill.Visible = true
        else
            d.boxFill.Visible = false
        end
    end
end

function ESPModule:UpdateHealth(d, bb, hum)
    if not hasDrawing then return end
    if not self.HEALTH_ENABLED or not hum then
        if d.healthBg then d.healthBg.Visible = false end
        if d.healthFill then d.healthFill.Visible = false end
        return
    end

    local ratio = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
    local barW = 3
    local x = bb.x - barW - 3
    local y = bb.y
    local h = bb.h

    if d.healthBg then
        d.healthBg.Position = Vector2.new(x, y)
        d.healthBg.Size = Vector2.new(barW, h)
        d.healthBg.Color = Color3.fromRGB(20, 20, 20)
        d.healthBg.Transparency = 0.3
        d.healthBg.Visible = true
    end

    if d.healthFill then
        local fh = h * ratio
        d.healthFill.Position = Vector2.new(x, y + h - fh)
        d.healthFill.Size = Vector2.new(barW, fh)
        d.healthFill.Color = self.HEALTH_GRADIENT and self:GetHealthColor(ratio) or self.HEALTH_HIGH_COLOR
        d.healthFill.Transparency = 0
        d.healthFill.Visible = true
    end
end

function ESPModule:UpdateInfo(d, bb, targetPlayer, distance, char)
    if not hasDrawing then return end

    local yAbove = bb.y - 2
    local yBelow = bb.y + bb.h + 2

    if self.NAME_ENABLED and d.nameText then
        d.nameText.Text = targetPlayer.DisplayName
        d.nameText.Color = self.NAME_COLOR
        d.nameText.Size = 13
        yAbove = yAbove - 14
        d.nameText.Position = Vector2.new(bb.cx, yAbove)
        d.nameText.Visible = true
    elseif d.nameText then
        d.nameText.Visible = false
    end

    if self.DISTANCE_ENABLED and d.distText then
        d.distText.Text = string.format("%dm", math.floor(distance))
        d.distText.Color = self.DISTANCE_COLOR
        d.distText.Size = 12
        d.distText.Position = Vector2.new(bb.cx, yBelow)
        d.distText.Visible = true
        yBelow = yBelow + 13
    elseif d.distText then
        d.distText.Visible = false
    end

    if self.WEAPON_ENABLED and d.weaponText then
        local now = tick()
        local wep = d.cachedWeapon
        if now - d.cachedWeaponTick > 0.3 then
            d.cachedWeaponTick = now
            wep = nil
            local tool = char:FindFirstChildOfClass("Tool")
            if tool then wep = tool.Name end
            d.cachedWeapon = wep
        end
        if wep then
            d.weaponText.Text = wep
            d.weaponText.Color = self.WEAPON_COLOR
            d.weaponText.Size = 11
            d.weaponText.Position = Vector2.new(bb.cx, yBelow)
            d.weaponText.Visible = true
        else
            d.weaponText.Visible = false
        end
    elseif d.weaponText then
        d.weaponText.Visible = false
    end
end

function ESPModule:UpdateTracer(d, bb, vpSize)
    if not hasDrawing or not d.tracer then return end
    if not self.TRACERS_ENABLED then d.tracer.Visible = false; return end

    local fromX, fromY
    if self.TRACER_ORIGIN == "Top" then
        fromX, fromY = vpSize.X * 0.5, 0
    elseif self.TRACER_ORIGIN == "Center" then
        fromX, fromY = vpSize.X * 0.5, vpSize.Y * 0.5
    else
        fromX, fromY = vpSize.X * 0.5, vpSize.Y
    end

    d.tracer.From = Vector2.new(fromX, fromY)
    d.tracer.To = Vector2.new(bb.cx, bb.y + bb.h)
    d.tracer.Color = self.TRACER_COLOR
    d.tracer.Thickness = self.TRACER_THICKNESS
    d.tracer.Visible = true
end

function ESPModule:UpdateSkeleton(d, char, cam)
    if not hasDrawing then return end
    if not self.SKELETON_ENABLED then
        for i = 1, #d.bones do local l = d.bones[i]; if l then l.Visible = false end end
        return
    end

    local isR15 = char:FindFirstChild("UpperTorso") ~= nil
    local boneList = isR15 and BONES_R15 or BONES_R6
    local idx = 0
    local skelColor = self.SKELETON_COLOR
    local skelThick = self.SKELETON_THICKNESS

    for _, pair in ipairs(boneList) do
        idx = idx + 1
        local l = d.bones[idx]
        if not l then continue end

        local p1 = char:FindFirstChild(pair[1])
        local p2 = char:FindFirstChild(pair[2])

        if p1 and p2 then
            local v1 = cam:WorldToViewportPoint(p1.Position)
            local v2 = cam:WorldToViewportPoint(p2.Position)
            if v1.Z > 0 or v2.Z > 0 then
                l.From = Vector2.new(v1.X, v1.Y)
                l.To = Vector2.new(v2.X, v2.Y)
                l.Color = skelColor
                l.Thickness = skelThick
                l.Visible = true
            else
                l.Visible = false
            end
        else
            l.Visible = false
        end
    end

    for i = idx + 1, #d.bones do
        if d.bones[i] then d.bones[i].Visible = false end
    end
end

function ESPModule:UpdateChams(d, char)
    if not self.CHAMS_ENABLED then
        if d.highlight then d.highlight.Enabled = false end
        d.lastChamsType = nil
        return
    end

    if not d.highlight then
        local ok, hl = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ArcanumChams"
            return h
        end)
        if ok and hl then d.highlight = hl else return end
    end

    local hl = d.highlight
    if hl.Adornee ~= char then
        hl.Adornee = char
        hl.Parent = char
    end

    local t = self.CHAMS_TYPE
    local depth = self.CHAMS_DEPTH
    local needsUpdate = (t ~= d.lastChamsType) or (depth ~= d.lastChamsDepth)

    if needsUpdate then
        d.lastChamsType = t
        d.lastChamsDepth = depth

        if t == "Outline" then
            hl.FillTransparency = 1
            hl.OutlineTransparency = self.CHAMS_OUTLINE_TRANSPARENCY
            hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
        elseif t == "Solid" then
            hl.FillTransparency = self.CHAMS_FILL_TRANSPARENCY
            hl.FillColor = self.CHAMS_FILL_COLOR
            hl.OutlineTransparency = 1
        elseif t == "Outline+Solid" then
            hl.FillTransparency = self.CHAMS_FILL_TRANSPARENCY
            hl.FillColor = self.CHAMS_FILL_COLOR
            hl.OutlineTransparency = self.CHAMS_OUTLINE_TRANSPARENCY
            hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
        elseif t == "Glow" then
            hl.FillTransparency = 0.3
            hl.FillColor = self.CHAMS_FILL_COLOR
            hl.OutlineTransparency = 0
            hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
        elseif t == "Wireframe" then
            hl.FillTransparency = 1
            hl.OutlineTransparency = 0
            hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
            hl.DepthMode = Enum.HighlightDepthMode.Occluded
        end

        if t ~= "Wireframe" then
            hl.DepthMode = depth == "AlwaysOnTop"
                and Enum.HighlightDepthMode.AlwaysOnTop
                or Enum.HighlightDepthMode.Occluded
        end
    else
        if t == "Outline" or t == "Glow" or t == "Wireframe" or t == "Outline+Solid" then
            hl.OutlineColor = self.CHAMS_OUTLINE_COLOR
        end
        if t == "Solid" or t == "Outline+Solid" or t == "Glow" then
            hl.FillColor = self.CHAMS_FILL_COLOR
        end
    end

    hl.Enabled = true
end

function ESPModule:CreateGhost(char)
    local ok, ghost = pcall(function()
        local g = char:Clone()
        for _, v in ipairs(g:GetDescendants()) do
            if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("ModuleScript")
                or v:IsA("Sound") or v:IsA("ParticleEmitter") or v:IsA("BillboardGui")
                or v:IsA("ProximityPrompt") or v:IsA("Decal") then
                v:Destroy()
            elseif v:IsA("BasePart") then
                v.CanCollide = false
                v.Anchored = true
                v.Transparency = 1
            end
        end
        local hum = g:FindFirstChildOfClass("Humanoid")
        if hum then hum:Destroy() end
        local anim = g:FindFirstChildOfClass("Animator")
        if anim then anim:Destroy() end
        g.Name = "ArcanumBT"
        return g
    end)
    return ok and ghost or nil
end

function ESPModule:UpdateBacktrack(d, char, root, targetPlayer)
    local shouldShow = self.BACKTRACK_ENABLED
    if shouldShow and self.TEAM_CHECK and self:IsTeammate(targetPlayer) then
        shouldShow = false
    end

    if not shouldShow then
        if d.btGhost then d.btGhost.Parent = nil end
        if d.btHighlight then d.btHighlight.Enabled = false end
        d.btHistory = {}
        d.btHead = 1
        d.btTail = 0
        return
    end

    local now = tick()
    if now - d.btLastRecord >= BT_INTERVAL then
        d.btLastRecord = now
        d.btTail = d.btTail + 1
        d.btHistory[d.btTail] = { t = now, cf = root.CFrame }

        while d.btHead <= d.btTail and (now - d.btHistory[d.btHead].t) > self.BACKTRACK_DURATION do
            d.btHistory[d.btHead] = nil
            d.btHead = d.btHead + 1
        end
    end

    local count = d.btTail - d.btHead + 1
    if count < 2 then
        if d.btGhost then d.btGhost.Parent = nil end
        if d.btHighlight then d.btHighlight.Enabled = false end
        return
    end

    if not d.btGhost or (now - d.btGhostTime > 1.5) then
        if d.btGhost then pcall(function() d.btGhost:Destroy() end) end
        d.btGhost = self:CreateGhost(char)
        d.btGhostTime = now
    end

    if not d.btGhost then return end

    local oldest = d.btHistory[d.btHead]
    if oldest then
        pcall(function() d.btGhost:PivotTo(oldest.cf) end)
        d.btGhost.Parent = self.Workspace
    end

    if not d.btHighlight then
        local ok, hl = pcall(function()
            local h = Instance.new("Highlight")
            h.Name = "ArcanumBTChams"
            return h
        end)
        if ok and hl then d.btHighlight = hl end
    end

    if d.btHighlight then
        d.btHighlight.FillColor = self.BACKTRACK_COLOR
        d.btHighlight.FillTransparency = self.BACKTRACK_TRANSPARENCY
        d.btHighlight.OutlineColor = self.BACKTRACK_COLOR
        d.btHighlight.OutlineTransparency = math.clamp(self.BACKTRACK_TRANSPARENCY - 0.2, 0, 1)
        d.btHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        d.btHighlight.Adornee = d.btGhost
        d.btHighlight.Parent = d.btGhost
        d.btHighlight.Enabled = true
    end
end

-- ════════════════════════════════════════
--  Main Loop
-- ════════════════════════════════════════
function ESPModule:Update()
    local cam = self.Workspace.CurrentCamera
    if not cam then return end

    local myChar = self.player.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local myPos = myRoot and myRoot.Position
    local vpSize = cam.ViewportSize

    local now = tick()
    if now - self._playerCacheTick >= self._PLAYER_CACHE_RATE then
        self._playerCacheTick = now
        self._playerCache = self.Players:GetPlayers()
    end

    local anyDrawingFeature = self.BOX_ENABLED or self.HEALTH_ENABLED
        or self.NAME_ENABLED or self.DISTANCE_ENABLED or self.WEAPON_ENABLED
        or self.TRACERS_ENABLED or self.SKELETON_ENABLED

    for _, plr in ipairs(self._playerCache) do
        local d = self._data[plr]
        if not d then
            d = self:CreateData()
            self._data[plr] = d
        end

        local show = self.ESP_ENABLED
        if plr == self.player and not self.SELF_ESP then show = false end

        local isTeammate = self.TEAM_CHECK and self:IsTeammate(plr)
        if show and isTeammate and self.TEAM_HIDE then show = false end

        local char = plr.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        local root = char and char:FindFirstChild("HumanoidRootPart")

        if not show or not char or not hum or hum.Health <= 0 or not root then
            self:HideAll(d)
            continue
        end

        local dist = myPos and (root.Position - myPos).Magnitude or 0

        if dist > self._MAX_ESP_DIST then
            self:HideAll(d)
            continue
        end

        if anyDrawingFeature then
            local bb = self:GetBoundingBox(root, cam)
            if not bb then
                self:HideAll(d)
                continue
            end

            self:UpdateBox(d, bb)
            self:UpdateHealth(d, bb, hum)
            self:UpdateInfo(d, bb, plr, dist, char)
            self:UpdateTracer(d, bb, vpSize)
            self:UpdateSkeleton(d, char, cam)
        end

        self:UpdateChams(d, char)
        self:UpdateBacktrack(d, char, root, plr)
    end

    for plr, _ in pairs(self._data) do
        if not plr.Parent then
            self:DestroyData(plr)
        end
    end
end

-- ════════════════════════════════════════
--  Start / Stop / Destroy
-- ════════════════════════════════════════
function ESPModule:Start()
    if self._renderConn then return end

    self._renderConn = self.RunService.RenderStepped:Connect(function()
        self:Update()
    end)

    self._playerLeftConn = self.Players.PlayerRemoving:Connect(function(plr)
        self:DestroyData(plr)
    end)
end

function ESPModule:Stop()
    if self._renderConn then self._renderConn:Disconnect(); self._renderConn = nil end
    if self._playerLeftConn then self._playerLeftConn:Disconnect(); self._playerLeftConn = nil end
end

function ESPModule:Destroy()
    self:Stop()
    for plr, _ in pairs(self._data) do
        self:DestroyData(plr)
    end
end

-- ════════════════════════════════════════
--  Config
-- ════════════════════════════════════════
local function c3str(c) return {R = c.R, G = c.G, B = c.B} end
local function strc3(t)
    if not t then return nil end
    return Color3.new(t.R or 1, t.G or 1, t.B or 1)
end

function ESPModule:GetSettings()
    return {
        ESP_ENABLED = self.ESP_ENABLED,
        SELF_ESP = self.SELF_ESP,
        TEAM_CHECK = self.TEAM_CHECK,
        TEAM_HIDE = self.TEAM_HIDE,
        BOX_ENABLED = self.BOX_ENABLED,
        BOX_TYPE = self.BOX_TYPE,
        BOX_COLOR = c3str(self.BOX_COLOR),
        BOX_FILL_ENABLED = self.BOX_FILL_ENABLED,
        BOX_FILL_COLOR = c3str(self.BOX_FILL_COLOR),
        BOX_FILL_TRANSPARENCY = self.BOX_FILL_TRANSPARENCY,
        HEALTH_ENABLED = self.HEALTH_ENABLED,
        HEALTH_GRADIENT = self.HEALTH_GRADIENT,
        HEALTH_LOW_COLOR = c3str(self.HEALTH_LOW_COLOR),
        HEALTH_HIGH_COLOR = c3str(self.HEALTH_HIGH_COLOR),
        NAME_ENABLED = self.NAME_ENABLED,
        NAME_COLOR = c3str(self.NAME_COLOR),
        DISTANCE_ENABLED = self.DISTANCE_ENABLED,
        DISTANCE_COLOR = c3str(self.DISTANCE_COLOR),
        WEAPON_ENABLED = self.WEAPON_ENABLED,
        WEAPON_COLOR = c3str(self.WEAPON_COLOR),
        TRACERS_ENABLED = self.TRACERS_ENABLED,
        TRACER_COLOR = c3str(self.TRACER_COLOR),
        TRACER_ORIGIN = self.TRACER_ORIGIN,
        TRACER_THICKNESS = self.TRACER_THICKNESS,
        SKELETON_ENABLED = self.SKELETON_ENABLED,
        SKELETON_COLOR = c3str(self.SKELETON_COLOR),
        SKELETON_THICKNESS = self.SKELETON_THICKNESS,
        CHAMS_ENABLED = self.CHAMS_ENABLED,
        CHAMS_TYPE = self.CHAMS_TYPE,
        CHAMS_OUTLINE_COLOR = c3str(self.CHAMS_OUTLINE_COLOR),
        CHAMS_FILL_COLOR = c3str(self.CHAMS_FILL_COLOR),
        CHAMS_FILL_TRANSPARENCY = self.CHAMS_FILL_TRANSPARENCY,
        CHAMS_OUTLINE_TRANSPARENCY = self.CHAMS_OUTLINE_TRANSPARENCY,
        CHAMS_DEPTH = self.CHAMS_DEPTH,
        BACKTRACK_ENABLED = self.BACKTRACK_ENABLED,
        BACKTRACK_COLOR = c3str(self.BACKTRACK_COLOR),
        BACKTRACK_DURATION = self.BACKTRACK_DURATION,
        BACKTRACK_TRANSPARENCY = self.BACKTRACK_TRANSPARENCY,
    }
end

function ESPModule:ApplySettings(s)
    if not s then return end
    local function apply(key, setter)
        if s[key] ~= nil then setter(s[key]) end
    end
    local function applyC3(key, setter)
        if s[key] then setter(strc3(s[key])) end
    end

    apply("ESP_ENABLED", function(v) self:SetEnabled(v) end)
    apply("SELF_ESP", function(v) self:SetSelfESP(v) end)
    apply("TEAM_CHECK", function(v) self:SetTeamCheck(v) end)
    apply("TEAM_HIDE", function(v) self:SetTeamHide(v) end)
    apply("BOX_ENABLED", function(v) self:SetBoxEnabled(v) end)
    apply("BOX_TYPE", function(v) self:SetBoxType(v) end)
    applyC3("BOX_COLOR", function(v) self:SetBoxColor(v) end)
    apply("BOX_FILL_ENABLED", function(v) self:SetBoxFillEnabled(v) end)
    applyC3("BOX_FILL_COLOR", function(v) self:SetBoxFillColor(v) end)
    apply("BOX_FILL_TRANSPARENCY", function(v) self:SetBoxFillTransparency(v) end)
    apply("HEALTH_ENABLED", function(v) self:SetHealthEnabled(v) end)
    apply("HEALTH_GRADIENT", function(v) self:SetHealthGradient(v) end)
    applyC3("HEALTH_LOW_COLOR", function(v) self:SetHealthLowColor(v) end)
    applyC3("HEALTH_HIGH_COLOR", function(v) self:SetHealthHighColor(v) end)
    apply("NAME_ENABLED", function(v) self:SetNameEnabled(v) end)
    applyC3("NAME_COLOR", function(v) self:SetNameColor(v) end)
    apply("DISTANCE_ENABLED", function(v) self:SetDistanceEnabled(v) end)
    applyC3("DISTANCE_COLOR", function(v) self:SetDistanceColor(v) end)
    apply("WEAPON_ENABLED", function(v) self:SetWeaponEnabled(v) end)
    applyC3("WEAPON_COLOR", function(v) self:SetWeaponColor(v) end)
    apply("TRACERS_ENABLED", function(v) self:SetTracersEnabled(v) end)
    applyC3("TRACER_COLOR", function(v) self:SetTracerColor(v) end)
    apply("TRACER_ORIGIN", function(v) self:SetTracerOrigin(v) end)
    apply("TRACER_THICKNESS", function(v) self:SetTracerThickness(v) end)
    apply("SKELETON_ENABLED", function(v) self:SetSkeletonEnabled(v) end)
    applyC3("SKELETON_COLOR", function(v) self:SetSkeletonColor(v) end)
    apply("SKELETON_THICKNESS", function(v) self:SetSkeletonThickness(v) end)
    apply("CHAMS_ENABLED", function(v) self:SetChamsEnabled(v) end)
    apply("CHAMS_TYPE", function(v) self:SetChamsType(v) end)
    applyC3("CHAMS_OUTLINE_COLOR", function(v) self:SetChamsOutlineColor(v) end)
    applyC3("CHAMS_FILL_COLOR", function(v) self:SetChamsFillColor(v) end)
    apply("CHAMS_FILL_TRANSPARENCY", function(v) self:SetChamsFillTransparency(v) end)
    apply("CHAMS_OUTLINE_TRANSPARENCY", function(v) self:SetChamsOutlineTransparency(v) end)
    apply("CHAMS_DEPTH", function(v) self:SetChamsDepth(v) end)
    apply("BACKTRACK_ENABLED", function(v) self:SetBacktrackEnabled(v) end)
    applyC3("BACKTRACK_COLOR", function(v) self:SetBacktrackColor(v) end)
    apply("BACKTRACK_DURATION", function(v) self:SetBacktrackDuration(v) end)
    apply("BACKTRACK_TRANSPARENCY", function(v) self:SetBacktrackTransparency(v) end)
end

return ESPModule
