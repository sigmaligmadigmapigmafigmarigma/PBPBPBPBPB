local Players = game:GetService("Players")
local Lighting = game:GetService("Lighting")
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TS = game:GetService("TweenService")

local player = Players.LocalPlayer

local World = {}
World.__index = World

function World.new()
	local self = setmetatable({}, World)

	self.ORIGINAL_LIGHTING = {
		Brightness = Lighting.Brightness,
		Ambient = Lighting.Ambient,
		OutdoorAmbient = Lighting.OutdoorAmbient,
		ClockTime = Lighting.ClockTime,
	}

	self.WORLD_TIME_ENABLED = false
	self.CUSTOM_CLOCKTIME = Lighting.ClockTime

	self.CUSTOM_SKY_ENABLED = false
	self.CUSTOM_SKY_PRESET = "Original"

	self.SKY_PRESETS = {
		Original = {
			SkyboxBk = "rbxassetid://148345460",
			SkyboxDn = "rbxassetid://148345469",
			SkyboxFt = "rbxassetid://148345455",
			SkyboxLf = "rbxassetid://148345446",
			SkyboxRt = "rbxassetid://148345440",
			SkyboxUp = "rbxassetid://148345466",
			SunTextureId = "rbxassetid://1345009717",
			MoonTextureId = "rbxasset://sky/moon.jpg",
			StarCount = 3000,
		},
		Blue = {
			SkyboxBk = "rbxassetid://124106120273678",
			SkyboxDn = "rbxassetid://72406028001064",
			SkyboxFt = "rbxassetid://139238600782726",
			SkyboxLf = "rbxassetid://139363840022859",
			SkyboxRt = "rbxassetid://122628916393316",
			SkyboxUp = "rbxassetid://104354476381566",
			StarCount = 3000,
		},
		Gray = {
			CelestialBodiesShown = true,
			MoonAngularSize = 6,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://15063412549",
			SkyboxDn = "rbxassetid://15063431496",
			SkyboxFt = "rbxassetid://15063442046",
			SkyboxLf = "rbxassetid://15063637382",
			SkyboxRt = "rbxassetid://15063435355",
			SkyboxUp = "rbxassetid://15063533447",
			StarCount = 3000,
			SunAngularSize = 9,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
		Dark = {
			CelestialBodiesShown = true,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://2013298",
			SkyboxDn = "rbxassetid://2013298",
			SkyboxFt = "rbxassetid://2013298",
			SkyboxLf = "rbxassetid://2013298",
			SkyboxRt = "rbxassetid://2013298",
			SkyboxUp = "rbxassetid://2013298",
			StarCount = 3000,
			SunAngularSize = 21,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
		Green = {
			CelestialBodiesShown = false,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://56661187",
			SkyboxDn = "rbxassetid://566611398",
			SkyboxFt = "rbxassetid://566611142",
			SkyboxLf = "rbxassetid://566611266",
			SkyboxRt = "rbxassetid://566611300",
			SkyboxUp = "rbxassetid://566611218",
			StarCount = 3000,
			SunAngularSize = 21,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
		Pink = {
			CelestialBodiesShown = false,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://271042516",
			SkyboxDn = "rbxassetid://271077243",
			SkyboxFt = "rbxassetid://271042556",
			SkyboxLf = "rbxassetid://271042310",
			SkyboxRt = "rbxassetid://271042467",
			SkyboxUp = "rbxassetid://271077958",
			StarCount = 0,
			SunAngularSize = 21,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
		Orange = {
			CelestialBodiesShown = true,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://150939022",
			SkyboxDn = "rbxassetid://150939038",
			SkyboxFt = "rbxassetid://150939047",
			SkyboxLf = "rbxassetid://150939056",
			SkyboxRt = "rbxassetid://150939063",
			SkyboxUp = "rbxassetid://150939082",
			StarCount = 3000,
			SunAngularSize = 21,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
		Purple = {
			CelestialBodiesShown = true,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://75339068650022",
			SkyboxDn = "rbxassetid://103288557260150",
			SkyboxFt = "rbxassetid://131140417030026",
			SkyboxLf = "rbxassetid://91178363674210",
			SkyboxRt = "rbxassetid://91811655162047",
			SkyboxUp = "rbxassetid://70646477316976",
			StarCount = 3000,
			SunAngularSize = 14,
			SunTextureId = "rbxassetid://13683514089",
		},
		Red = {
			CelestialBodiesShown = false,
			MoonAngularSize = 11,
			MoonTextureId = "rbxasset://sky/moon.jpg",
			SkyboxBk = "rbxassetid://108929045660200",
			SkyboxDn = "rbxassetid://78646480540009",
			SkyboxFt = "rbxassetid://90546017435179",
			SkyboxLf = "rbxassetid://109838453114563",
			SkyboxRt = "rbxassetid://94190734796082",
			SkyboxUp = "rbxassetid://126944775797063",
			StarCount = 3000,
			SunAngularSize = 21,
			SunTextureId = "rbxasset://sky/sun.jpg",
		},
	}

	local s = Lighting:FindFirstChildOfClass("Sky")
	if s then
		self.ORIGINAL_SKY = s:Clone()
	end

	self.BLUR_ENABLED = false
	self.BLUR_SIZE = 10
	self._blurEffect = nil

	self.BHOP_ENABLED = false
	self.BHOP_SPEED = 25
	self._bhopConn = nil

	self.NOCLIP_ENABLED = false
	self._noclipConn = nil

	self.FLY_ENABLED = false
	self.FLY_SPEED = 50
	self._flyConn = nil
	self._flyBV = nil

	self.SPAWN_TP_ENABLED = false
	self._spawnTpConn = nil

	self.TRASHTALK_ENABLED = false
	self.TRASHTALK_MODE = "Kill Talk"
	self.TRASHTALK_MESSAGES = {"Get better, get Arcanum Nextgen"}
	self.TRASHTALK_COOLDOWN = 3
	self._ttMsgIndex = 1
	self._ttSpamConn = nil
	self._ttKillConn = nil
	self._ttRoundConn = nil
	self._ttDeathConn = nil

	-- Weather
	self.RAIN_ENABLED = false
	self.RAIN_DENSITY = 50
	self.RAIN_SPEED = 30
	self._rainPart = nil
	self._rainEmitter = nil

	self.SNOW_ENABLED = false
	self.SNOW_DENSITY = 40
	self.SNOW_SPEED = 10
	self._snowPart = nil
	self._snowEmitter = nil

	self.THUNDER_ENABLED = false
	self.THUNDER_DENSITY = 50
	self.THUNDER_SPEED = 30
	self.THUNDER_FREQUENCY = 8
	self._thunderPart = nil
	self._thunderEmitter = nil
	self._thunderConn = nil

	self.FOG_ENABLED = false
	self.FOG_START = 0
	self.FOG_END = 500
	self.FOG_COLOR = Color3.fromRGB(180, 180, 190)
	self._origFog = {
		FogStart = Lighting.FogStart,
		FogEnd = Lighting.FogEnd,
		FogColor = Lighting.FogColor,
	}

	self._unloadCallbacks = {}
	self._connections = {}

	return self
end

-- ═══════════════════════════════════════════════════
--  World Time Changer
-- ═══════════════════════════════════════════════════

function World:applyTime()
	if self.WORLD_TIME_ENABLED then
		Lighting.ClockTime = self.CUSTOM_CLOCKTIME
	else
		Lighting.ClockTime = self.ORIGINAL_LIGHTING.ClockTime
	end
end

function World:SetTimeEnabled(v)
	self.WORLD_TIME_ENABLED = v
	self:applyTime()
end

function World:SetClockTime(v)
	self.CUSTOM_CLOCKTIME = v
	self:applyTime()
end

-- ═══════════════════════════════════════════════════
--  Skybox Changer
-- ═══════════════════════════════════════════════════

function World:wipeSky()
	for _, v in ipairs(Lighting:GetChildren()) do
		if v:IsA("Sky") then v:Destroy() end
	end
end

function World:buildSky(name)
	local data = self.SKY_PRESETS[name]
	if not data then return end
	local sky = Instance.new("Sky")
	for k, v in pairs(data) do
		sky[k] = v
	end
	sky.Name = "NemesisSky"
	sky.Parent = Lighting
end

function World:applySky()
	self:wipeSky()
	if self.CUSTOM_SKY_ENABLED then
		self:buildSky(self.CUSTOM_SKY_PRESET)
	else
		if self.ORIGINAL_SKY then
			self.ORIGINAL_SKY:Clone().Parent = Lighting
		end
	end
end

function World:SetSkyEnabled(v)
	self.CUSTOM_SKY_ENABLED = v
	self:applySky()
end

function World:SetSkyPreset(v)
	self.CUSTOM_SKY_PRESET = v
	self:applySky()
end

-- ═══════════════════════════════════════════════════
--  Blur (Post Processing)
-- ═══════════════════════════════════════════════════

function World:SetBlurEnabled(v)
	self.BLUR_ENABLED = v
	if v then
		if not self._blurEffect then
			self._blurEffect = Instance.new("BlurEffect")
			self._blurEffect.Name = "ArcBlur"
			self._blurEffect.Size = self.BLUR_SIZE
			self._blurEffect.Parent = Lighting
		end
		self._blurEffect.Enabled = true
	else
		if self._blurEffect then
			self._blurEffect.Enabled = false
		end
	end
end

function World:SetBlurSize(v)
	self.BLUR_SIZE = v
	if self._blurEffect then
		self._blurEffect.Size = v
	end
end

-- ═══════════════════════════════════════════════════
--  Bunny Hop
-- ═══════════════════════════════════════════════════

function World:SetBhopEnabled(v)
	self.BHOP_ENABLED = v
	if v then
		self:StartBhop()
	else
		self:StopBhop()
	end
end

function World:SetBhopSpeed(v)
	self.BHOP_SPEED = v
end

function World:StartBhop()
	self:StopBhop()
	self._bhopConn = RS.Heartbeat:Connect(function()
		if not self.BHOP_ENABLED then return end
		local char = player.Character
		if not char then return end
		local hum = char:FindFirstChildOfClass("Humanoid")
		if not hum then return end

		hum.WalkSpeed = self.BHOP_SPEED
	end)
	table.insert(self._connections, self._bhopConn)
end

function World:StopBhop()
	if self._bhopConn then
		self._bhopConn:Disconnect()
		self._bhopConn = nil
	end
	local char = player.Character
	if char then
		local hum = char:FindFirstChildOfClass("Humanoid")
		if hum then hum.WalkSpeed = 16 end
	end
end

-- ═══════════════════════════════════════════════════
--  Noclip
-- ═══════════════════════════════════════════════════

function World:SetNoclipEnabled(v)
	self.NOCLIP_ENABLED = v
	if v then
		self:StartNoclip()
	else
		self:StopNoclip()
	end
end

function World:StartNoclip()
	self:StopNoclip()
	self._noclipConn = RS.Stepped:Connect(function()
		if not self.NOCLIP_ENABLED then return end
		local char = player.Character
		if not char then return end
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end)
	table.insert(self._connections, self._noclipConn)
end

function World:StopNoclip()
	if self._noclipConn then
		self._noclipConn:Disconnect()
		self._noclipConn = nil
	end
end

-- ═══════════════════════════════════════════════════
--  Fly
-- ═══════════════════════════════════════════════════

function World:SetFlyEnabled(v)
	self.FLY_ENABLED = v
	if v then
		self:StartFly()
	else
		self:StopFly()
	end
end

function World:SetFlySpeed(v)
	self.FLY_SPEED = v
end

function World:StartFly()
	self:StopFly()
	local char = player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local bv = Instance.new("BodyVelocity")
	bv.Name = "ArcFlyBV"
	bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	bv.Velocity = Vector3.new(0, 0, 0)
	bv.Parent = hrp
	self._flyBV = bv

	self._flyConn = RS.Heartbeat:Connect(function()
		if not self.FLY_ENABLED then return end
		if not hrp or not hrp.Parent then self:StopFly(); return end

		local cam = Workspace.CurrentCamera
		local dir = Vector3.new(0, 0, 0)
		local speed = self.FLY_SPEED

		local moveDir = hum.MoveDirection
		if moveDir.Magnitude > 0 then
			dir = dir + cam.CFrame:VectorToWorldSpace(
				cam.CFrame:VectorToObjectSpace(moveDir).Unit
			) * speed
		end

		if UIS:IsKeyDown(Enum.KeyCode.Space) then
			dir = dir + Vector3.new(0, speed, 0)
		end
		if UIS:IsKeyDown(Enum.KeyCode.LeftControl) or UIS:IsKeyDown(Enum.KeyCode.LeftShift) then
			dir = dir - Vector3.new(0, speed, 0)
		end

		bv.Velocity = dir

		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end)
	table.insert(self._connections, self._flyConn)
end

function World:StopFly()
	if self._flyConn then
		self._flyConn:Disconnect()
		self._flyConn = nil
	end
	if self._flyBV then
		self._flyBV:Destroy()
		self._flyBV = nil
	end
end

-- ═══════════════════════════════════════════════════
--  Enemy Spawn Teleport
-- ═══════════════════════════════════════════════════

function World:SetSpawnTpEnabled(v)
	self.SPAWN_TP_ENABLED = v
	if v then
		self:StartSpawnTp()
	else
		self:StopSpawnTp()
	end
end

function World:GetPlayerTeam()
	local char = player.Character
	if not char then return nil end

	local teamFolder = Workspace:FindFirstChild("Teams") or Workspace:FindFirstChild("teams")
	if teamFolder then
		for _, folder in pairs(teamFolder:GetChildren()) do
			local name = folder.Name:lower()
			for _, obj in pairs(folder:GetChildren()) do
				if obj.Name == player.Name or (obj:IsA("ObjectValue") and obj.Value == player) then
					if name:find("t") and not name:find("ct") then
						return "T"
					elseif name:find("ct") or name:find("counter") then
						return "CT"
					end
				end
			end
		end
	end

	if player.Team then
		local tn = player.Team.Name:lower()
		if tn:find("terrorist") and not tn:find("counter") then return "T" end
		if tn:find("counter") or tn:find("ct") then return "CT" end
		if tn == "t" then return "T" end
	end

	local teamVal = char:FindFirstChild("Team") or char:FindFirstChild("team")
	if teamVal and teamVal:IsA("StringValue") then
		local tv = teamVal.Value:lower()
		if tv:find("t") and not tv:find("ct") then return "T" end
		if tv:find("ct") or tv:find("counter") then return "CT" end
	end

	return nil
end

function World:TeleportToSpawn()
	local char = player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local team = self:GetPlayerTeam()
	if not team then return end

	if team == "T" then
		hrp.CFrame = CFrame.new(-201, 24, -10)
	elseif team == "CT" then
		hrp.CFrame = CFrame.new(-303, 19, 55)
	end
end

function World:StartSpawnTp()
	self:StopSpawnTp()

	local roundEvent = ReplicatedStorage:FindFirstChild("GameEvent")
		or ReplicatedStorage:FindFirstChild("RoundStart")
		or ReplicatedStorage:FindFirstChild("round")

	if roundEvent and roundEvent:IsA("RemoteEvent") then
		self._spawnTpConn = roundEvent.OnClientEvent:Connect(function()
			if not self.SPAWN_TP_ENABLED then return end
			task.delay(5.1, function()
				self:TeleportToSpawn()
			end)
		end)
		table.insert(self._connections, self._spawnTpConn)
	end

	local charConn
	charConn = player.CharacterAdded:Connect(function(char)
		if not self.SPAWN_TP_ENABLED then return end
		char:WaitForChild("HumanoidRootPart", 10)
		task.delay(5.1, function()
			if self.SPAWN_TP_ENABLED then
				self:TeleportToSpawn()
			end
		end)
	end)
	self._spawnTpCharConn = charConn
	table.insert(self._connections, charConn)
end

function World:StopSpawnTp()
	if self._spawnTpConn then
		self._spawnTpConn:Disconnect()
		self._spawnTpConn = nil
	end
	if self._spawnTpCharConn then
		self._spawnTpCharConn:Disconnect()
		self._spawnTpCharConn = nil
	end
end

-- ═══════════════════════════════════════════════════
--  Trash Talk
-- ═══════════════════════════════════════════════════

function World:SetTrashtalkEnabled(v)
	self.TRASHTALK_ENABLED = v
	if v then
		self:StartTrashtalk()
	else
		self:StopTrashtalk()
	end
end

function World:SetTrashtalkMode(v)
	self.TRASHTALK_MODE = v
	if self.TRASHTALK_ENABLED then
		self:StopTrashtalk()
		self:StartTrashtalk()
	end
end

function World:SetTrashtalkCooldown(v)
	self.TRASHTALK_COOLDOWN = v
end

function World:AddTrashtalkMessage(msg)
	if msg and msg ~= "" then
		table.insert(self.TRASHTALK_MESSAGES, msg)
	end
end

function World:RemoveTrashtalkMessage(index)
	if index > 0 and index <= #self.TRASHTALK_MESSAGES then
		table.remove(self.TRASHTALK_MESSAGES, index)
	end
end

function World:ClearTrashtalkMessages()
	self.TRASHTALK_MESSAGES = {}
	self._ttMsgIndex = 1
end

function World:GetNextMessage()
	if #self.TRASHTALK_MESSAGES == 0 then return nil end
	local msg = self.TRASHTALK_MESSAGES[self._ttMsgIndex]
	self._ttMsgIndex = self._ttMsgIndex + 1
	if self._ttMsgIndex > #self.TRASHTALK_MESSAGES then
		self._ttMsgIndex = 1
	end
	return msg
end

function World:FindChatRemote()
	if self._chatRemote then return self._chatRemote end

	local function deepSearch(parent, depth)
		if depth > 3 then return nil end
		for _, child in pairs(parent:GetChildren()) do
			local n = child.Name:lower()
			if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
				if n:find("chat") or n:find("message") or n:find("msg")
					or n:find("send") or n:find("say") or n:find("talk") then
					return child
				end
			end
			if child:IsA("Folder") or child:IsA("Configuration") or child:IsA("ModuleScript") then
				local found = deepSearch(child, depth + 1)
				if found then return found end
			end
		end
		return nil
	end

	local legacy = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
	if legacy then
		local sayMsg = legacy:FindFirstChild("SayMessageRequest")
		if sayMsg then self._chatRemote = sayMsg; return sayMsg end
	end

	local found = deepSearch(ReplicatedStorage, 0)
	if found then self._chatRemote = found; return found end

	return nil
end

function World:SendChat(msg)
	if not msg or msg == "" then return end

	local sent = false

	pcall(function()
		local TCS = game:GetService("TextChatService")
		if TCS then
			local textChannels = TCS:FindFirstChild("TextChannels")
			if textChannels then
				for _, ch in pairs(textChannels:GetChildren()) do
					if ch:IsA("TextChannel") then
						ch:SendAsync(msg)
						sent = true
						return
					end
				end
			end
		end
	end)
	if sent then return end

	pcall(function()
		local legacy = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
		if legacy then
			local sayMsg = legacy:FindFirstChild("SayMessageRequest")
			if sayMsg then
				sayMsg:FireServer(msg, "All")
				sent = true
				return
			end
		end
	end)
	if sent then return end

	pcall(function()
		local remote = self:FindChatRemote()
		if remote then
			if remote:IsA("RemoteEvent") then
				remote:FireServer(msg)
				sent = true
			elseif remote:IsA("RemoteFunction") then
				remote:InvokeServer(msg)
				sent = true
			end
		end
	end)
	if sent then return end

	pcall(function()
		local SSSService = game:GetService("StarterGui")
		SSSService:SetCore("ChatMakeSystemMessage", {
			Text = msg,
			Color = Color3.fromRGB(255, 255, 255),
		})
	end)

	pcall(function()
		for _, v in pairs(ReplicatedStorage:GetDescendants()) do
			if v:IsA("RemoteEvent") then
				local n = v.Name:lower()
				if n:find("chat") or n:find("msg") or n:find("message") or n:find("say") or n:find("send") or n:find("talk") then
					v:FireServer(msg, "All")
					sent = true
					return
				end
			end
		end
	end)
	if sent then return end

	pcall(function()
		for _, v in pairs(ReplicatedStorage:GetDescendants()) do
			if v:IsA("RemoteEvent") then
				pcall(function()
					v:FireServer(msg)
				end)
				return
			end
		end
	end)
end

function World:StartTrashtalk()
	self:StopTrashtalk()
	local mode = self.TRASHTALK_MODE

	if mode == "Spam" then
		self._ttSpamConn = task.spawn(function()
			while self.TRASHTALK_ENABLED and self.TRASHTALK_MODE == "Spam" do
				local msg = self:GetNextMessage()
				if msg then self:SendChat(msg) end
				task.wait(self.TRASHTALK_COOLDOWN)
			end
		end)

	elseif mode == "Kill Talk" then
		local infEvent = ReplicatedStorage:FindFirstChild("inf", 5)
		if infEvent then
			self._ttKillConn = infEvent.OnClientEvent:Connect(function()
				if not self.TRASHTALK_ENABLED then return end
				local msg = self:GetNextMessage()
				if msg then
					task.delay(0.3, function() self:SendChat(msg) end)
				end
			end)
			table.insert(self._connections, self._ttKillConn)
		end

	elseif mode == "Death Talk" then
		local function hookChar(char)
			local hum = char:WaitForChild("Humanoid", 10)
			if not hum then return end
			self._ttDeathConn = hum.Died:Connect(function()
				if not self.TRASHTALK_ENABLED then return end
				local msg = self:GetNextMessage()
				if msg then
					task.delay(0.5, function() self:SendChat(msg) end)
				end
			end)
			table.insert(self._connections, self._ttDeathConn)
		end
		if player.Character then hookChar(player.Character) end
		self._ttDeathCharConn = player.CharacterAdded:Connect(function(c) hookChar(c) end)
		table.insert(self._connections, self._ttDeathCharConn)

	elseif mode == "Round Start" then
		self._ttRoundCharConn = player.CharacterAdded:Connect(function()
			if not self.TRASHTALK_ENABLED then return end
			task.delay(5.5, function()
				if self.TRASHTALK_ENABLED then
					local msg = self:GetNextMessage()
					if msg then self:SendChat(msg) end
				end
			end)
		end)
		table.insert(self._connections, self._ttRoundCharConn)

	elseif mode == "Random" then
		self._ttSpamConn = task.spawn(function()
			while self.TRASHTALK_ENABLED and self.TRASHTALK_MODE == "Random" do
				if #self.TRASHTALK_MESSAGES > 0 then
					local msg = self.TRASHTALK_MESSAGES[math.random(1, #self.TRASHTALK_MESSAGES)]
					if msg then self:SendChat(msg) end
				end
				task.wait(self.TRASHTALK_COOLDOWN + math.random() * 3)
			end
		end)
	end
end

function World:StopTrashtalk()
	if self._ttKillConn then pcall(function() self._ttKillConn:Disconnect() end); self._ttKillConn = nil end
	if self._ttDeathConn then pcall(function() self._ttDeathConn:Disconnect() end); self._ttDeathConn = nil end
	if self._ttDeathCharConn then pcall(function() self._ttDeathCharConn:Disconnect() end); self._ttDeathCharConn = nil end
	if self._ttRoundConn then pcall(function() self._ttRoundConn:Disconnect() end); self._ttRoundConn = nil end
	if self._ttRoundCharConn then pcall(function() self._ttRoundCharConn:Disconnect() end); self._ttRoundCharConn = nil end
end

-- ═══════════════════════════════════════════════════
--  Weather: Rain
-- ═══════════════════════════════════════════════════

function World:_createWeatherPart(name)
	local part = Instance.new("Part")
	part.Name = name
	part.Anchored = true
	part.CanCollide = false
	part.Transparency = 1
	part.Size = Vector3.new(200, 1, 200)
	part.Parent = Workspace
	return part
end

function World:_updateWeatherPartPos(part)
	local cam = Workspace.CurrentCamera
	if cam then
		part.CFrame = CFrame.new(cam.CFrame.Position + Vector3.new(0, 80, 0))
	end
end

function World:SetRainEnabled(v)
	self.RAIN_ENABLED = v
	if v then
		self:StartRain()
	else
		self:StopRain()
	end
end

function World:SetRainDensity(v)
	self.RAIN_DENSITY = v
	if self._rainEmitter then
		self._rainEmitter.Rate = v * 20
	end
end

function World:SetRainSpeed(v)
	self.RAIN_SPEED = v
	if self._rainEmitter then
		local sp = NumberRange.new(v, v + 10)
		self._rainEmitter.Speed = sp
	end
end

function World:StartRain()
	self:StopRain()
	local part = self:_createWeatherPart("ArcRain")
	self._rainPart = part

	local att = Instance.new("Attachment")
	att.Parent = part

	local pe = Instance.new("ParticleEmitter")
	pe.Parent = att
	pe.Texture = "rbxassetid://241876428"
	pe.Rate = self.RAIN_DENSITY * 20
	pe.Lifetime = NumberRange.new(0.8, 1.5)
	pe.Speed = NumberRange.new(self.RAIN_SPEED, self.RAIN_SPEED + 10)
	pe.SpreadAngle = Vector2.new(15, 15)
	pe.Rotation = NumberRange.new(0, 0)
	pe.RotSpeed = NumberRange.new(0, 0)
	pe.EmissionDirection = Enum.NormalId.Bottom
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.05),
		NumberSequenceKeypoint.new(1, 0.02),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.8, 0.5),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Color = ColorSequence.new(Color3.fromRGB(180, 200, 220))
	pe.LightEmission = 0.05
	pe.Drag = 0
	self._rainEmitter = pe

	local conn = RS.Heartbeat:Connect(function()
		if part and part.Parent then
			self:_updateWeatherPartPos(part)
		end
	end)
	table.insert(self._connections, conn)
end

function World:StopRain()
	if self._rainPart then
		pcall(function() self._rainPart:Destroy() end)
		self._rainPart = nil
	end
	self._rainEmitter = nil
end

-- ═══════════════════════════════════════════════════
--  Weather: Snow
-- ═══════════════════════════════════════════════════

function World:SetSnowEnabled(v)
	self.SNOW_ENABLED = v
	if v then
		self:StartSnow()
	else
		self:StopSnow()
	end
end

function World:SetSnowDensity(v)
	self.SNOW_DENSITY = v
	if self._snowEmitter then
		self._snowEmitter.Rate = v * 15
	end
end

function World:SetSnowSpeed(v)
	self.SNOW_SPEED = v
	if self._snowEmitter then
		self._snowEmitter.Speed = NumberRange.new(v, v + 5)
	end
end

function World:StartSnow()
	self:StopSnow()
	local part = self:_createWeatherPart("ArcSnow")
	self._snowPart = part

	local att = Instance.new("Attachment")
	att.Parent = part

	local pe = Instance.new("ParticleEmitter")
	pe.Parent = att
	pe.Texture = "rbxassetid://241876428"
	pe.Rate = self.SNOW_DENSITY * 15
	pe.Lifetime = NumberRange.new(3, 6)
	pe.Speed = NumberRange.new(self.SNOW_SPEED, self.SNOW_SPEED + 5)
	pe.SpreadAngle = Vector2.new(40, 40)
	pe.Rotation = NumberRange.new(0, 360)
	pe.RotSpeed = NumberRange.new(-60, 60)
	pe.EmissionDirection = Enum.NormalId.Bottom
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.15),
		NumberSequenceKeypoint.new(0.5, 0.2),
		NumberSequenceKeypoint.new(1, 0.1),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(0.7, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Color = ColorSequence.new(Color3.fromRGB(240, 245, 255))
	pe.LightEmission = 0.15
	pe.Drag = 3
	self._snowEmitter = pe

	local conn = RS.Heartbeat:Connect(function()
		if part and part.Parent then
			self:_updateWeatherPartPos(part)
		end
	end)
	table.insert(self._connections, conn)
end

function World:StopSnow()
	if self._snowPart then
		pcall(function() self._snowPart:Destroy() end)
		self._snowPart = nil
	end
	self._snowEmitter = nil
end

-- ═══════════════════════════════════════════════════
--  Weather: Thunder
-- ═══════════════════════════════════════════════════

function World:SetThunderEnabled(v)
	self.THUNDER_ENABLED = v
	if v then
		self:StartThunder()
	else
		self:StopThunder()
	end
end

function World:SetThunderDensity(v)
	self.THUNDER_DENSITY = v
	if self._thunderEmitter then
		self._thunderEmitter.Rate = v * 20
	end
end

function World:SetThunderSpeed(v)
	self.THUNDER_SPEED = v
	if self._thunderEmitter then
		self._thunderEmitter.Speed = NumberRange.new(v, v + 10)
	end
end

function World:SetThunderFrequency(v)
	self.THUNDER_FREQUENCY = v
end

function World:_flashLightning()
	local origBrightness = Lighting.Brightness
	local origAmbient = Lighting.Ambient

	Lighting.Brightness = 8
	Lighting.Ambient = Color3.fromRGB(200, 210, 255)

	local sound = Instance.new("Sound")
	sound.SoundId = "rbxassetid://1907349676"
	sound.Volume = 0.6
	sound.PlayOnRemove = false
	sound.Parent = Workspace
	sound:Play()

	task.delay(0.12, function()
		TS:Create(Lighting, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Brightness = origBrightness,
			Ambient = origAmbient,
		}):Play()
	end)
	task.delay(3, function()
		pcall(function() sound:Destroy() end)
	end)
end

function World:StartThunder()
	self:StopThunder()

	local part = self:_createWeatherPart("ArcThunder")
	self._thunderPart = part

	local att = Instance.new("Attachment")
	att.Parent = part

	local pe = Instance.new("ParticleEmitter")
	pe.Parent = att
	pe.Texture = "rbxassetid://241876428"
	pe.Rate = self.THUNDER_DENSITY * 20
	pe.Lifetime = NumberRange.new(0.8, 1.5)
	pe.Speed = NumberRange.new(self.THUNDER_SPEED, self.THUNDER_SPEED + 10)
	pe.SpreadAngle = Vector2.new(15, 15)
	pe.Rotation = NumberRange.new(0, 0)
	pe.RotSpeed = NumberRange.new(0, 0)
	pe.EmissionDirection = Enum.NormalId.Bottom
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.05),
		NumberSequenceKeypoint.new(1, 0.02),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.8, 0.5),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Color = ColorSequence.new(Color3.fromRGB(160, 175, 200))
	pe.LightEmission = 0.05
	pe.Drag = 0
	self._thunderEmitter = pe

	local posConn = RS.Heartbeat:Connect(function()
		if part and part.Parent then
			self:_updateWeatherPartPos(part)
		end
	end)
	table.insert(self._connections, posConn)

	task.spawn(function()
		while self.THUNDER_ENABLED do
			local interval = math.random(
				math.max(2, self.THUNDER_FREQUENCY - 3),
				self.THUNDER_FREQUENCY + 5
			)
			task.wait(interval)
			if self.THUNDER_ENABLED then
				self:_flashLightning()
			end
		end
	end)
end

function World:StopThunder()
	self.THUNDER_ENABLED = false
	if self._thunderPart then
		pcall(function() self._thunderPart:Destroy() end)
		self._thunderPart = nil
	end
	self._thunderEmitter = nil
end

-- ═══════════════════════════════════════════════════
--  Weather: Fog
-- ═══════════════════════════════════════════════════

function World:SetFogEnabled(v)
	self.FOG_ENABLED = v
	if v then
		self:ApplyFog()
	else
		self:RemoveFog()
	end
end

function World:SetFogStart(v)
	self.FOG_START = v
	if self.FOG_ENABLED then
		Lighting.FogStart = v
	end
end

function World:SetFogEnd(v)
	self.FOG_END = v
	if self.FOG_ENABLED then
		Lighting.FogEnd = v
	end
end

function World:SetFogColor(c)
	self.FOG_COLOR = c
	if self.FOG_ENABLED then
		Lighting.FogColor = c
	end
end

function World:ApplyFog()
	Lighting.FogStart = self.FOG_START
	Lighting.FogEnd = self.FOG_END
	Lighting.FogColor = self.FOG_COLOR
end

function World:RemoveFog()
	Lighting.FogStart = self._origFog.FogStart
	Lighting.FogEnd = self._origFog.FogEnd
	Lighting.FogColor = self._origFog.FogColor
end

-- ═══════════════════════════════════════════════════
--  Unload
-- ═══════════════════════════════════════════════════

function World:RegisterUnloadCallback(fn)
	table.insert(self._unloadCallbacks, fn)
end

function World:Unload()
	self:StopBhop()
	self:StopNoclip()
	self:StopFly()
	self:StopSpawnTp()
	self:StopTrashtalk()
	self:StopRain()
	self:StopSnow()
	self:StopThunder()
	if self.FOG_ENABLED then self:RemoveFog() end

	if self.BLUR_ENABLED and self._blurEffect then
		self._blurEffect:Destroy()
		self._blurEffect = nil
	end

	if self.WORLD_TIME_ENABLED then
		Lighting.ClockTime = self.ORIGINAL_LIGHTING.ClockTime
	end
	if self.CUSTOM_SKY_ENABLED then
		self:wipeSky()
		if self.ORIGINAL_SKY then
			self.ORIGINAL_SKY:Clone().Parent = Lighting
		end
	end

	for _, conn in ipairs(self._connections) do
		pcall(function() conn:Disconnect() end)
	end
	self._connections = {}

	for _, fn in ipairs(self._unloadCallbacks) do
		pcall(fn)
	end
end

-- ═══════════════════════════════════════════════════
--  Export / Import
-- ═══════════════════════════════════════════════════

function World:Export()
	return {
		WORLD_TIME_ENABLED = self.WORLD_TIME_ENABLED,
		CUSTOM_CLOCKTIME = self.CUSTOM_CLOCKTIME,
		CUSTOM_SKY_ENABLED = self.CUSTOM_SKY_ENABLED,
		CUSTOM_SKY_PRESET = self.CUSTOM_SKY_PRESET,
		BLUR_ENABLED = self.BLUR_ENABLED,
		BLUR_SIZE = self.BLUR_SIZE,
		BHOP_ENABLED = self.BHOP_ENABLED,
		BHOP_SPEED = self.BHOP_SPEED,
		NOCLIP_ENABLED = self.NOCLIP_ENABLED,
		FLY_ENABLED = self.FLY_ENABLED,
		FLY_SPEED = self.FLY_SPEED,
		SPAWN_TP_ENABLED = self.SPAWN_TP_ENABLED,
		TRASHTALK_ENABLED = self.TRASHTALK_ENABLED,
		TRASHTALK_MODE = self.TRASHTALK_MODE,
		TRASHTALK_MESSAGES = self.TRASHTALK_MESSAGES,
		TRASHTALK_COOLDOWN = self.TRASHTALK_COOLDOWN,
	}
end

function World:Import(t)
	if t.WORLD_TIME_ENABLED ~= nil then self.WORLD_TIME_ENABLED = t.WORLD_TIME_ENABLED end
	if t.CUSTOM_CLOCKTIME then self.CUSTOM_CLOCKTIME = t.CUSTOM_CLOCKTIME end
	if t.CUSTOM_SKY_ENABLED ~= nil then self.CUSTOM_SKY_ENABLED = t.CUSTOM_SKY_ENABLED end
	if t.CUSTOM_SKY_PRESET then self.CUSTOM_SKY_PRESET = t.CUSTOM_SKY_PRESET end
	if t.BLUR_ENABLED ~= nil then self:SetBlurEnabled(t.BLUR_ENABLED) end
	if t.BLUR_SIZE then self:SetBlurSize(t.BLUR_SIZE) end
	if t.BHOP_ENABLED ~= nil then self:SetBhopEnabled(t.BHOP_ENABLED) end
	if t.BHOP_SPEED then self:SetBhopSpeed(t.BHOP_SPEED) end
	if t.NOCLIP_ENABLED ~= nil then self:SetNoclipEnabled(t.NOCLIP_ENABLED) end
	if t.FLY_ENABLED ~= nil then self:SetFlyEnabled(t.FLY_ENABLED) end
	if t.FLY_SPEED then self:SetFlySpeed(t.FLY_SPEED) end
	if t.SPAWN_TP_ENABLED ~= nil then self:SetSpawnTpEnabled(t.SPAWN_TP_ENABLED) end
	if t.TRASHTALK_MODE then self.TRASHTALK_MODE = t.TRASHTALK_MODE end
	if t.TRASHTALK_MESSAGES then self.TRASHTALK_MESSAGES = t.TRASHTALK_MESSAGES end
	if t.TRASHTALK_COOLDOWN then self.TRASHTALK_COOLDOWN = t.TRASHTALK_COOLDOWN end
	if t.TRASHTALK_ENABLED ~= nil then self:SetTrashtalkEnabled(t.TRASHTALK_ENABLED) end

	self:applyTime()
	self:applySky()
end

return World
