local VisualsModule = {}
VisualsModule.__index = VisualsModule

function VisualsModule.new(config)
	local self = setmetatable({}, VisualsModule)

	self.player = config.Player
	self.guiParent = config.GuiParent
	self.Services = config.Services or {}

	self.Players = self.Services.Players
	self.TweenService = self.Services.TweenService
	self.RunService = self.Services.RunService
	self.UserInputService = self.Services.UserInputService
	self.ReplicatedStorage = self.Services.ReplicatedStorage
	self.Workspace = self.Services.Workspace
	self.Lighting = self.Services.Lighting
	self.Debris = self.Services.Debris
	self.SoundService = self.Services.SoundService
	self.HttpService = self.Services.HttpService

	self.Notification = config.Notification
	self.IsFakeLagEnabled = config.IsFakeLagEnabled

	self.HITLOG_ENABLED = false
	self.HITSOUND_ENABLED = true
	self.HITSOUND_VOLUME = 1
	self.HITSOUND_PRESET = "bell"

self.GHOST_BASE_TRANSPARENCY = 0.7
self.GHOST_FADE_RADIUS = 1.6
self.GHOST_FADE_POWER = 1.2

	self.TRACER_ENABLED = false
	self.TRACER_COLOR = Color3.fromRGB(255, 255, 255)
	self.TRACER_LIFETIME = 0.45
	self.TRACER_WIDTH = 0.12
	self.TRACER_NEON = false

	self.TRACER_BRIGHTNESS = 20
	self.TRACER_LIGHTEMISSION = 1
	self.TRACER_LIGHTINFLUENCE = 0.95
	self.TRACER_TAIL = 2
	self.TRACER_TRANSPARENCY = NumberSequence.new({
		NumberSequenceKeypoint.new(0.00, 1.00),
		NumberSequenceKeypoint.new(0.125, 0.05),
		NumberSequenceKeypoint.new(0.89, 0.0562),
		NumberSequenceKeypoint.new(1.00, 1.00),
	})

	self.WALLBANG_ENABLED = false
	self.WALLBANG_ENTRY_COLOR = Color3.fromRGB(255, 50, 50)
	self.WALLBANG_EXIT_COLOR = Color3.fromRGB(50, 255, 50)
	self.WALLBANG_MARKER_SIZE = Vector3.new(0.5, 0.5, 0.5)
	self.WALLBANG_LIFETIME = 3

	self.KILLFX_ENABLED = false
	self.KILLFX_TYPE = "Sparkle"
	self.KILLFX_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLFX_LIGHT_COLOR = Color3.fromRGB(120, 180, 255)
	self.KILLFX_CUSTOM_DURATION = 0.25
	self.KILLFX_LIGHT_RANGE = 15
	self.KILLFX_LIGHT_BRIGHTNESS = 1

	self.OFFSCREEN_ENABLED = false
	self.OFFSCREEN_COLOR = Color3.fromRGB(255, 80, 80)

	self.BACKTRACK_GHOST_ENABLED = false
	self.BACKTRACK_GHOST_COLOR = Color3.fromRGB(80, 160, 255)
	self.BACKTRACK_GHOST_DURATION = 0.3

	self.KILLIMAGE_ENABLED = false
	self.KILLIMAGE_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLIMAGE_FADE_IN = 0.08
	self.KILLIMAGE_HOLD = 0.1
	self.KILLIMAGE_FADE_OUT = 0.6
	self.KILLIMAGE_MAX_ALPHA = 0.45

	self.ATMOSPHERE_ENABLED = false
	self.ATMOSPHERE_DENSITY = 0.3
	self.ATMOSPHERE_OFFSET = 0.25
	self.ATMOSPHERE_COLOR = Color3.fromRGB(200, 200, 200)
	self.ATMOSPHERE_DECAY = Color3.fromRGB(128, 128, 128)
	self.ATMOSPHERE_GLARE = 0.5
	self.ATMOSPHERE_HAZE = 0.5

	self.BLOOM_ENABLED = false
	self.BLOOM_INTENSITY = 2
	self.BLOOM_SIZE = 56
	self.BLOOM_THRESHOLD = 0.8

	self.COLOR_CORRECTION_ENABLED = false
	self.COLOR_CORRECTION_BRIGHTNESS = 0
	self.COLOR_CORRECTION_CONTRAST = 0
	self.COLOR_CORRECTION_SATURATION = 0
	self.COLOR_CORRECTION_TINT = Color3.fromRGB(255, 255, 255)

	self.CHINA_HAT_ENABLED = false
	self.CHINA_HAT_COLOR = Color3.fromRGB(255, 255, 255)
	self._chinaHatParts = {}

	self.WINGS_ENABLED = false
	self.WINGS_COLOR = Color3.fromRGB(255, 255, 255)
	self._wingData = nil

	self.AURA_ENABLED = false
	self.AURA_COLOR = Color3.fromRGB(255, 255, 255)
	self._auraData = nil

	self.JUMP_CIRCLES_ENABLED = false
	self.JUMP_CIRCLES_COLOR = Color3.fromRGB(255, 255, 255)
	self._jumpConn = nil

	self.HIT_MARKER_ENABLED = false
	self._hitMarkerGui = nil
	self._hitMarkerLines = {}

	self.tracerPool = {}
	self.MAX_TRACER_POOL = 12

	self.arrows = {}
	self.hitlogContainer = nil
	self.hitlogOrder = 0

	self._bindInputBegan = nil
	self._bindInputEnded = nil

	self.ghostModel = nil
	self.ghostExpireAt = 0
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
	self.ghostParts = {}
	self.ghostLastCFrames = {}
	self.GHOST_SMOOTH_SPEED = 45
	self._hbLast = tick()
	self._ghostDt = 1 / 60

	self.killImage = nil

	self:Initialize()

	return self
end

function VisualsModule:Initialize()
	self.Camera = self.Workspace.CurrentCamera
	self.FX_ROOT = self.ReplicatedStorage:WaitForChild("FXTemplates")
	self.HITSOUND_STORAGE = self.guiParent:WaitForChild("ScreenGui"):WaitForChild("storage")

	self.ORIGINAL_EFFECTS = {
		Atmosphere = self:SnapshotFirstEffect("Atmosphere"),
		BloomEffect = self:SnapshotFirstEffect("BloomEffect"),
		ColorCorrectionEffect = self:SnapshotFirstEffect("ColorCorrectionEffect"),
	}

	self:CreateHitlogUI()
	self:CreateOffscreenArrows()
	self:CreateKillImageGUI()
	self:CreateHitMarkerUI()
	self:SetupBacktrackGhost()
	self:SetupKillFXListener()
	self:SetupPlayerEffects()
end

function VisualsModule:CreateHitlogUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "NemesisHitlogs"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.Parent = self.guiParent

	local container = Instance.new("Frame")
	container.Name = "HitlogList"
	container.Active = false
	container.Selectable = false
	container.Size = UDim2.new(0, 300, 0, 200)
	container.Position = UDim2.new(0.5, -150, 0.55, 20)
	container.AnchorPoint = Vector2.new(0, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.Parent = screenGui

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 2)
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.Parent = container

	self.hitlogContainer = container
	self.hitlogOrder = 0
end

function VisualsModule:ShowHitlog(hitType, info)
	if not self.HITLOG_ENABLED then return end
	if not self.hitlogContainer then return end

	self.hitlogOrder += 1

	local text
	if hitType == "Hit" and info then
		text = string.format("HIT  %s  %d DMG  %d studs",
			tostring(info.bodyPart or "Body"),
			math.floor(tonumber(info.damage) or 0),
			math.floor(tonumber(info.distance) or 0))
	elseif hitType == "Miss" and info then
		local reason = info.reason or "unknown"
		if reason == "hitchance_failed" then
			text = string.format("MISS  %d%% (%d)  %d studs",
				tonumber(info.hitchance) or 0, tonumber(info.roll) or 0, tonumber(info.distance) or 0)
		elseif reason == "min_damage" then
			text = string.format("MISS  DMG < %d  %d studs", tonumber(info.minDamage) or 0, tonumber(info.distance) or 0)
		elseif reason == "wall_blocking_target" then
			text = string.format("MISS  WALL  %d studs", tonumber(info.distance) or 0)
		elseif reason == "too_far" then
			text = string.format("MISS  TOO FAR  %d studs", tonumber(info.distance) or 0)
		elseif reason == "no_target" then text = "MISS  NO TARGET"
		elseif reason == "target_dead" then text = "MISS  DEAD"
		elseif reason == "friendly_fire" then text = "MISS  TEAM"
		else text = "MISS"
		end
	elseif hitType == "Hit" then text = "HIT"
	else text = "MISS"
	end

	local isHit = (hitType == "Hit")
	local accentColor = isHit and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(90, 90, 100)

	local row = Instance.new("Frame")
	row.Name = "Hitlog_" .. self.hitlogOrder
	row.Size = UDim2.new(1, 0, 0, 22)
	row.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
	row.BackgroundTransparency = 0.25
	row.BorderSizePixel = 0
	row.LayoutOrder = self.hitlogOrder
	row.Parent = self.hitlogContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = row

	local stripe = Instance.new("Frame")
	stripe.Size = UDim2.new(0, 2, 1, -4)
	stripe.Position = UDim2.new(0, 2, 0, 2)
	stripe.BackgroundColor3 = accentColor
	stripe.BorderSizePixel = 0
	stripe.Parent = row
	local stripeCorner = Instance.new("UICorner")
	stripeCorner.CornerRadius = UDim.new(0, 1)
	stripeCorner.Parent = stripe

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -14, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(220, 220, 225)
	label.TextSize = 11
	label.Font = Enum.Font.Code
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextTransparency = 1
	label.Parent = row

	row.BackgroundTransparency = 1
	stripe.BackgroundTransparency = 1

	local showInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
	self.TweenService:Create(row, showInfo, {BackgroundTransparency = 0.25}):Play()
	self.TweenService:Create(stripe, showInfo, {BackgroundTransparency = 0}):Play()
	self.TweenService:Create(label, showInfo, {TextTransparency = 0}):Play()

	task.spawn(function()
		task.wait(2.5)
		if not row or not row.Parent then return end
		local hideInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
		self.TweenService:Create(row, hideInfo, {BackgroundTransparency = 1}):Play()
		self.TweenService:Create(stripe, hideInfo, {BackgroundTransparency = 1}):Play()
		local t = self.TweenService:Create(label, hideInfo, {TextTransparency = 1})
		t:Play()
		t.Completed:Connect(function()
			if row and row.Parent then row:Destroy() end
		end)
	end)
end

function VisualsModule:PlayHitSound()
	if not self.HITSOUND_ENABLED then return end

	local HITSOUND_MAP = {
		correct = "HitSfx13",
		skeet = "HitSfx",
		orchestra = "HitSfx2",
		bow = "HitSfx3",
		uwu = "HitSfx4",
		tf2 = "HitSfx5",
		b8 = "HitSfx6",
		basketball = "HitSfx7",
		idk = "HitSfx8",
		orb = "HitSfx9",
		balltap = "HitSfx10",
		softbell = "HitSfx11",
		softhit = "HitSfx12",
		soft = "HitSfx14",
		bell2 = "HitSfx15",
		tank1 = "HitSfx16",
		rampage = "HitSfx18",
		headshot = "HitSfx19",
		tank2 = "HitSfx20",
		rust = "HitSfx22",
	}

	if self.HITSOUND_PRESET == "bell" then
		local s = Instance.new("Sound")
		s.SoundId = "rbxassetid://7112391013"
		s.Volume = self.HITSOUND_VOLUME
		s.Parent = self.SoundService
		s:Play()
		self.Debris:AddItem(s, 3)
		return
	end

	if not self.HITSOUND_STORAGE then return end

	local assetName = HITSOUND_MAP[self.HITSOUND_PRESET]
	if not assetName then return end

	local src = self.HITSOUND_STORAGE:FindFirstChild(assetName)
	if not src then return end

	local sound
	if src:IsA("Sound") then
		sound = src:Clone()
	else
		sound = src:FindFirstChildWhichIsA("Sound", true)
		if sound then sound = sound:Clone() end
	end
	if not sound then return end

	sound.Volume = self.HITSOUND_VOLUME
	sound.Parent = self.SoundService
	sound:Play()
	self.Debris:AddItem(sound, math.max(sound.TimeLength + 0.3, 2))
end

function VisualsModule:CreateOffscreenArrows()
	local OffscreenGui = Instance.new("ScreenGui")
	OffscreenGui.Name = "NemesisOffscreen"
	OffscreenGui.IgnoreGuiInset = true
	OffscreenGui.ResetOnSpawn = false
	OffscreenGui.Parent = self.guiParent

	self.OffscreenGui = OffscreenGui

	local function isEnemy(plr)
		if self.player.Team and plr.Team then
			return self.player.Team ~= plr.Team
		end
		return true
	end

	local function createArrow(plr)
		local img = Instance.new("ImageLabel")
		img.Name = plr.Name .. "_Arrow"
		img.Size = UDim2.fromOffset(45, 45)
img:SetAttribute("BaseSize", 45)
		img.AnchorPoint = Vector2.new(0.5, 0.5)
		img.BackgroundTransparency = 1
		img.Image = "rbxassetid://121771059734689"
		img.Visible = false
		img.ImageTransparency = 0.3
		img.Parent = OffscreenGui
		self.arrows[plr] = img
	end

	local function removeArrow(plr)
		if self.arrows[plr] then
			self.arrows[plr]:Destroy()
			self.arrows[plr] = nil
		end
	end

	self.Players.PlayerAdded:Connect(function(plr)
		if plr ~= self.player and isEnemy(plr) then
			createArrow(plr)
		end
	end)
	self.Players.PlayerRemoving:Connect(removeArrow)

	for _, p in ipairs(self.Players:GetPlayers()) do
		if p ~= self.player and isEnemy(p) then
			createArrow(p)
		end
	end

	local function refreshArrows()
		for plr, arrow in pairs(self.arrows) do
			if not isEnemy(plr) then
				arrow:Destroy()
				self.arrows[plr] = nil
			end
		end

		for _, plr in ipairs(self.Players:GetPlayers()) do
			if plr ~= self.player and isEnemy(plr) and not self.arrows[plr] then
				createArrow(plr)
			end
		end
	end

	self.player:GetPropertyChangedSignal("Team"):Connect(refreshArrows)

	self.RunService.RenderStepped:Connect(function()
local t = tick()
		self.Camera = self.Workspace.CurrentCamera or self.Camera
		local Camera = self.Camera
		if not Camera then return end

		if not self.OFFSCREEN_ENABLED then
			for _, a in pairs(self.arrows) do
				a.Visible = false
			end
			return
		end

		local camCF = Camera.CFrame
		local camPos = camCF.Position
		local vp = Camera.ViewportSize
		local center = Vector2.new(vp.X / 2, vp.Y / 2)

		for plr, arrow in pairs(self.arrows) do
			if not isEnemy(plr) then
				arrow.Visible = false
				continue
			end

			local char = plr.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local hum = char and char:FindFirstChild("Humanoid")

			if not hrp or not hum or hum.Health <= 0 then
				arrow.Visible = false
				continue
			end

			local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)

			if onScreen and screenPos.Z > 0 then
				if screenPos.X > 0 and screenPos.X < vp.X and screenPos.Y > 0 and screenPos.Y < vp.Y then
					arrow.Visible = false
					continue
				end
			end

			local toPlayer = (hrp.Position - camPos).Unit
			local camRight = camCF.RightVector
			local x = toPlayer:Dot(camRight)
			local z = toPlayer:Dot(camCF.LookVector)

			local angle = math.atan2(x, z)
			local rot = math.deg(angle)

			local maxRadius = math.min(420, math.min(vp.X, vp.Y) * 0.35)
			local pos = center + Vector2.new(math.sin(angle), -math.cos(angle)) * maxRadius

			arrow.Position = UDim2.fromOffset(pos.X, pos.Y)
			arrow.Rotation = rot + 180
			arrow.ImageColor3 = self.OFFSCREEN_COLOR
			arrow.Visible = true

local pulse = math.abs(math.sin(t * 4.5))
arrow.ImageTransparency = 0.1 + pulse * 0.65
		end
	end)
end

function VisualsModule:CreateTracer(startPos, endPos)
	if not self.TRACER_ENABLED then return end

	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	if self.WALLBANG_ENABLED then
		local direction = (endPos - startPos)
		local dirUnit = direction.Unit

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local char = self.player.Character
		if char then
			params.FilterDescendantsInstances = { char }
		end

		local rayForward = self.Workspace:Raycast(startPos, dirUnit * distance, params)
		if rayForward then
			local rayBackward = self.Workspace:Raycast(endPos, -dirUnit * distance, params)
			if rayBackward then
				local penetrationDepth = (rayForward.Position - rayBackward.Position).Magnitude
				if penetrationDepth > 0.5 and penetrationDepth < (distance * 0.95) then
					task.spawn(function()
						self:CreateWallbangMarker(rayForward.Position, self.WALLBANG_ENTRY_COLOR)
						self:CreateWallbangMarker(rayBackward.Position, self.WALLBANG_EXIT_COLOR)
					end)
				end
			end
		end
	end

	local tracerObj = table.remove(self.tracerPool)
	if not tracerObj then
		local folder = Instance.new("Folder")
		folder.Name = "tracer_fx"

		local mover = Instance.new("Part")
		mover.Name = "Mover"
		mover.Anchored = true
		mover.Transparency = 1
		mover.CanCollide = false
		mover.CanQuery = false
		mover.CanTouch = false
		mover.Size = Vector3.new(0.05, 0.05, 0.05)
		mover.Parent = folder

		local a0 = Instance.new("Attachment")
		a0.Name = "A0"
		a0.Parent = mover

		local a1 = Instance.new("Attachment")
		a1.Name = "A1"
		a1.Parent = mover

		local trail = Instance.new("Trail")
		trail.Name = "Trace"
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Enabled = false
		trail.FaceCamera = true
		trail.Brightness = self.TRACER_BRIGHTNESS
		trail.LightEmission = self.TRACER_LIGHTEMISSION
		trail.LightInfluence = self.TRACER_LIGHTINFLUENCE
		trail.TextureMode = Enum.TextureMode.Stretch
		trail.Texture = "rbxassetid://93746968407218"
		trail.TextureLength = 3
		trail.Transparency = self.TRACER_TRANSPARENCY
		trail.Parent = mover

		tracerObj = { folder = folder, mover = mover, a0 = a0, a1 = a1, trail = trail }
	end

	local w = math.clamp(self.TRACER_WIDTH, 0.02, 0.25)

	tracerObj.trail.Color = ColorSequence.new(self.TRACER_COLOR)
	tracerObj.trail.Lifetime = self.TRACER_LIFETIME
	tracerObj.trail.WidthScale = NumberSequence.new(w)
	tracerObj.trail.Transparency = self.TRACER_TRANSPARENCY
	tracerObj.trail.Brightness = self.TRACER_BRIGHTNESS
	tracerObj.trail.LightEmission = self.TRACER_LIGHTEMISSION
	tracerObj.trail.LightInfluence = self.TRACER_LIGHTINFLUENCE

	local dir = (endPos - startPos)
	local unit = dir.Unit

	tracerObj.folder.Parent = self.Workspace
	tracerObj.mover.CFrame = CFrame.lookAt(startPos, startPos + unit)
	tracerObj.a0.Position = Vector3.new(0, 0, 0)
	tracerObj.a1.Position = Vector3.new(0, 0, -self.TRACER_TAIL)
	tracerObj.trail.Enabled = true

	local flyTime = math.clamp(distance / 2200, 0.06, 0.22)
	local tween = self.TweenService:Create(tracerObj.mover, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
		CFrame = CFrame.lookAt(endPos, endPos + unit),
	})
	tween:Play()

	tween.Completed:Once(function()
		task.delay(tracerObj.trail.Lifetime + 0.05, function()
			if not tracerObj or not tracerObj.folder then return end
			tracerObj.trail.Enabled = false
			tracerObj.folder.Parent = nil
			if #self.tracerPool < self.MAX_TRACER_POOL then
				table.insert(self.tracerPool, tracerObj)
			else
				tracerObj.folder:Destroy()
			end
		end)
	end)
end

function VisualsModule:CreateWallbangMarker(pos, color)
	local part = Instance.new("Part")
	part.Name = "WallbangMarker"
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CastShadow = false
	part.Material = Enum.Material.ForceField
	part.Color = color
	part.Size = self.WALLBANG_MARKER_SIZE
	part.CFrame = CFrame.new(pos)
	part.Parent = self.Workspace

	part.Transparency = 0
	local tIn = self.TweenService:Create(part, TweenInfo.new(0.3), { Transparency = 0 })
	tIn:Play()

	self.Debris:AddItem(part, self.WALLBANG_LIFETIME)

	task.delay(self.WALLBANG_LIFETIME - 0.5, function()
		if part.Parent then
			self.TweenService:Create(part, TweenInfo.new(0.5), { Transparency = 1, Size = Vector3.new(0, 0, 0) }):Play()
		end
	end)
end

function VisualsModule:CreateKillImageGUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisKillImage"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.DisplayOrder = 9999
	gui.Parent = self.guiParent

	local img = Instance.new("ImageLabel")
	img.Name = "Effect"
	img.Size = UDim2.fromScale(1, 1)
	img.Position = UDim2.fromScale(0.5, 0.5)
	img.AnchorPoint = Vector2.new(0.5, 0.5)
	img.BackgroundTransparency = 1
	img.Image = "http://www.roblox.com/asset/?id=3124804643"
	img.ImageTransparency = 1
	img.ScaleType = Enum.ScaleType.Stretch
	img.ZIndex = 999
	img.Parent = gui

	self.killImage = img
end

function VisualsModule:PlayKillImage()
	if not self.KILLIMAGE_ENABLED then return end
	if not self.killImage then return end

	self.killImage.ImageColor3 = self.KILLIMAGE_COLOR
	self.killImage.ImageTransparency = 1

	local tIn = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_IN, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ ImageTransparency = 1 - self.KILLIMAGE_MAX_ALPHA }
	)

	local tOut = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{ ImageTransparency = 1 }
	)

	tIn:Play()
	tIn.Completed:Wait()
	task.wait(self.KILLIMAGE_HOLD)
	tOut:Play()
end

function VisualsModule:CreateHitMarkerUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisHitMarker"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.DisplayOrder = 100
	gui.Parent = self.guiParent

	local holder = Instance.new("Frame")
	holder.Name = "HitMarker"
	holder.Size = UDim2.new(0, 40, 0, 40)
	holder.AnchorPoint = Vector2.new(0.5, 0.5)
	holder.Position = UDim2.new(0.5, 0, 0.5, 0)
	holder.BackgroundTransparency = 1
	holder.Visible = false
	holder.Parent = gui

	self._hitMarkerLines = {}

	local function makeLine(rot)
		local line = Instance.new("Frame")
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.Position = UDim2.new(0.5, 0, 0.5, 0)
		line.Size = UDim2.new(0, 2, 0, 24)
		line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		line.BorderSizePixel = 0
		line.Rotation = rot
		line.BackgroundTransparency = 1
		line.Parent = holder

		local hole = Instance.new("Frame")
		hole.AnchorPoint = Vector2.new(0.5, 0.5)
		hole.Position = UDim2.new(0.5, 0, 0.5, 0)
		hole.Size = UDim2.new(0, 4, 0, 8)
		hole.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		hole.BackgroundTransparency = 1
		hole.BorderSizePixel = 0
		hole.Parent = line

		return line
	end

	table.insert(self._hitMarkerLines, makeLine(45))
	table.insert(self._hitMarkerLines, makeLine(-45))

	self._hitMarkerGui = holder
end

function VisualsModule:FlashHitMarker()
	if not self.HIT_MARKER_ENABLED then return end
	if not self._hitMarkerGui then return end

	self._hitMarkerGui.Visible = true
	self._hitMarkerGui.Size = UDim2.new(0, 50, 0, 50)
	for _, l in ipairs(self._hitMarkerLines) do
		l.BackgroundTransparency = 0
	end

	local shrink = self.TweenService:Create(self._hitMarkerGui,
		TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 40, 0, 40)}
	)
	shrink:Play()

	task.spawn(function()
		task.wait(0.15)
		if not self._hitMarkerGui then return end
		local fadeInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		for _, l in ipairs(self._hitMarkerLines) do
			self.TweenService:Create(l, fadeInfo, {BackgroundTransparency = 1}):Play()
		end
		task.wait(0.2)
		if self._hitMarkerGui then self._hitMarkerGui.Visible = false end
	end)
end

function VisualsModule:SetupPlayerEffects()
	self.player.CharacterAdded:Connect(function(char)
		task.wait(0.5)
		if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
		if self.WINGS_ENABLED then self:SpawnWings() end
		if self.AURA_ENABLED then self:SpawnAura() end
		if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
	end)

	if self.player.Character then
		task.defer(function()
			if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
			if self.WINGS_ENABLED then self:SpawnWings() end
			if self.AURA_ENABLED then self:SpawnAura() end
			if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
		end)
	end
end

function VisualsModule:SpawnChinaHat()
	self:DestroyChinaHat()
	local char = self.player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end

	local parts = {}
	local SLICES = 8
	local RADIUS = 1.6
	local HEIGHT = 1.0

	for i = 1, SLICES do
		local angle = (i - 1) * (math.pi * 2 / SLICES)
		local nextAngle = i * (math.pi * 2 / SLICES)
		local midAngle = (angle + nextAngle) / 2

		local wedge = Instance.new("WedgePart")
		wedge.Name = "ArcHatSlice"
		wedge.Material = Enum.Material.SmoothPlastic
		wedge.Color = self.CHINA_HAT_COLOR
		wedge.Anchored = false
		wedge.CanCollide = false
		wedge.CanTouch = false
		wedge.CanQuery = false
		wedge.CastShadow = false
		wedge.Massless = true
		wedge.Transparency = 0.05

		local sliceWidth = 2 * RADIUS * math.sin(math.pi / SLICES)
		wedge.Size = Vector3.new(sliceWidth, HEIGHT, RADIUS)

		local cf = head.CFrame
			* CFrame.new(0, 0.6, 0)
			* CFrame.Angles(0, midAngle, 0)
			* CFrame.new(0, 0, -RADIUS / 2)
			* CFrame.Angles(0, 0, 0)

		wedge.CFrame = cf
		wedge.Parent = char

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = head
		weld.Part1 = wedge
		weld.Parent = wedge

		table.insert(parts, wedge)
	end

	local brim = Instance.new("Part")
	brim.Name = "ArcHatBrim"
	brim.Shape = Enum.PartType.Cylinder
	brim.Size = Vector3.new(0.06, RADIUS * 2.3, RADIUS * 2.3)
	brim.Material = Enum.Material.SmoothPlastic
	brim.Color = self.CHINA_HAT_COLOR
	brim.Anchored = false
	brim.CanCollide = false
	brim.CanTouch = false
	brim.CanQuery = false
	brim.CastShadow = false
	brim.Massless = true
	brim.Transparency = 0.05
	brim.CFrame = head.CFrame * CFrame.new(0, 0.58, 0) * CFrame.Angles(0, 0, math.rad(90))
	brim.Parent = char

	local brimWeld = Instance.new("WeldConstraint")
	brimWeld.Part0 = head
	brimWeld.Part1 = brim
	brimWeld.Parent = brim

	table.insert(parts, brim)
	self._chinaHatParts = parts
end

function VisualsModule:DestroyChinaHat()
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p:Destroy() end
	end
	self._chinaHatParts = {}
end

function VisualsModule:SpawnWings()
	self:DestroyWings()
	local char = self.player.Character
	if not char then return end
	local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
	if not torso then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcWings"
	folder.Parent = char

	local featherDefs = {
		{side = -1, x = 1.0, y = 0.7, z = 0.5, rx = 5, ry = 15, flapMult = 1.0, size = Vector3.new(0.08, 2.0, 1.5)},
		{side = -1, x = 1.8, y = 0.4, z = 0.6, rx = 3, ry = 20, flapMult = 1.15, size = Vector3.new(0.07, 2.6, 1.2)},
		{side = -1, x = 2.5, y = 0.0, z = 0.7, rx = 0, ry = 25, flapMult = 1.3, size = Vector3.new(0.06, 2.8, 0.9)},
		{side = -1, x = 3.0, y = -0.4, z = 0.8, rx = -3, ry = 28, flapMult = 1.45, size = Vector3.new(0.05, 2.2, 0.7)},
		{side = 1, x = 1.0, y = 0.7, z = 0.5, rx = 5, ry = 15, flapMult = 1.0, size = Vector3.new(0.08, 2.0, 1.5)},
		{side = 1, x = 1.8, y = 0.4, z = 0.6, rx = 3, ry = 20, flapMult = 1.15, size = Vector3.new(0.07, 2.6, 1.2)},
		{side = 1, x = 2.5, y = 0.0, z = 0.7, rx = 0, ry = 25, flapMult = 1.3, size = Vector3.new(0.06, 2.8, 0.9)},
		{side = 1, x = 3.0, y = -0.4, z = 0.8, rx = -3, ry = 28, flapMult = 1.45, size = Vector3.new(0.05, 2.2, 0.7)},
	}

	local feathers = {}
	for _, def in ipairs(featherDefs) do
		local p = Instance.new("WedgePart")
		p.Name = "ArcWingFeather"
		p.Size = def.size
		p.Material = Enum.Material.Neon
		p.Color = self.WINGS_COLOR
		p.Anchored = true
		p.CanCollide = false
		p.CanTouch = false
		p.CanQuery = false
		p.CastShadow = false
		p.Transparency = 0.1
		p.Parent = folder

		local trail = Instance.new("Trail")
		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, def.size.Y * 0.4, 0)
		a0.Parent = p
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -def.size.Y * 0.4, 0)
		a1.Parent = p
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.WINGS_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.6),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.3
		trail.FaceCamera = true
		trail.LightEmission = 0.5
		trail.Parent = p

		table.insert(feathers, {part = p, def = def, trail = trail})
	end

	local conn = self.RunService.Heartbeat:Connect(function()
		if not torso or not torso.Parent then
			self:DestroyWings()
			return
		end
		local t = tick()
		local torsoCF = torso.CFrame
		local flapBase = math.sin(t * 3.0) * 12

		for _, f in ipairs(feathers) do
			local d = f.def
			local s = d.side
			local flapAngle = flapBase * d.flapMult
			local breathe = math.sin(t * 1.5 + d.x) * 2

			local localCF = CFrame.new(s * d.x, d.y, d.z)
				* CFrame.Angles(math.rad(d.rx + breathe), math.rad(s * d.ry), math.rad(s * (flapAngle - 10)))

			f.part.CFrame = torsoCF * localCF
		end
	end)

	self._wingData = {
		folder = folder,
		feathers = feathers,
		conn = conn,
	}
end

function VisualsModule:DestroyWings()
	if self._wingData then
		if self._wingData.conn then
			self._wingData.conn:Disconnect()
		end
		if self._wingData.folder and self._wingData.folder.Parent then
			self._wingData.folder:Destroy()
		end
		self._wingData = nil
	end
end

function VisualsModule:SpawnAura()
	self:DestroyAura()
	local char = self.player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcAura"
	folder.Parent = char

	local NUM_MAIN = 5
	local NUM_INNER = 3
	local RADIUS_MAIN = 3.2
	local RADIUS_INNER = 1.8

	local function makeOrb(name, size, transp)
		local orb = Instance.new("Part")
		orb.Name = name
		orb.Shape = Enum.PartType.Ball
		orb.Size = Vector3.new(size, size, size)
		orb.Material = Enum.Material.Neon
		orb.Color = self.AURA_COLOR
		orb.Anchored = true
		orb.CanCollide = false
		orb.CanTouch = false
		orb.CanQuery = false
		orb.CastShadow = false
		orb.Transparency = transp

		local light = Instance.new("PointLight")
		light.Color = self.AURA_COLOR
		light.Range = 4
		light.Brightness = 0.4
		light.Parent = orb

		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, 0.1, 0)
		a0.Parent = orb
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -0.1, 0)
		a1.Parent = orb
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.AURA_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.4),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.5
		trail.FaceCamera = true
		trail.LightEmission = 0.7
		trail.Parent = orb

		orb.Parent = folder
		return orb
	end

	local mainOrbs = {}
	for i = 1, NUM_MAIN do
		table.insert(mainOrbs, makeOrb("AuraOrb_" .. i, 0.35, 0.25))
	end

	local innerOrbs = {}
	for i = 1, NUM_INNER do
		table.insert(innerOrbs, makeOrb("AuraInner_" .. i, 0.2, 0.4))
	end

	local groundRing = Instance.new("Part")
	groundRing.Name = "AuraGroundRing"
	groundRing.Shape = Enum.PartType.Cylinder
	groundRing.Size = Vector3.new(0.05, RADIUS_MAIN * 2, RADIUS_MAIN * 2)
	groundRing.Material = Enum.Material.Neon
	groundRing.Color = self.AURA_COLOR
	groundRing.Anchored = true
	groundRing.CanCollide = false
	groundRing.CanTouch = false
	groundRing.CanQuery = false
	groundRing.CastShadow = false
	groundRing.Transparency = 0.85
	groundRing.Parent = folder

	local rising = Instance.new("ParticleEmitter")
	rising.Name = "AuraRise"
	rising.Color = ColorSequence.new(self.AURA_COLOR)
	rising.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(0.5, 0.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	rising.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.6, 0.6),
		NumberSequenceKeypoint.new(1, 1),
	})
	rising.Lifetime = NumberRange.new(0.8, 1.5)
	rising.Rate = 18
	rising.Speed = NumberRange.new(1.5, 3.5)
	rising.SpreadAngle = Vector2.new(20, 20)
	rising.RotSpeed = NumberRange.new(-60, 60)
	rising.LightEmission = 0.8
	rising.LightInfluence = 0.1
	rising.Texture = "rbxassetid://6490035152"
	rising.EmissionDirection = Enum.NormalId.Top
	rising.Parent = hrp

	self._auraData = {
		folder = folder,
		mainOrbs = mainOrbs,
		innerOrbs = innerOrbs,
		groundRing = groundRing,
		emitter = rising,
		conn = nil,
	}

	self._auraData.conn = self.RunService.Heartbeat:Connect(function()
		if not hrp or not hrp.Parent then
			self:DestroyAura()
			return
		end
		local t = tick()
		local basePos = hrp.Position

		for idx, orb in ipairs(mainOrbs) do
			if orb and orb.Parent then
				local angle = (t * 1.8) + (idx - 1) * (math.pi * 2 / NUM_MAIN)
				local yOff = math.sin(t * 2.5 + idx * 1.3) * 0.7
				local pulse = 0.35 + math.sin(t * 4 + idx) * 0.08
				orb.Size = Vector3.new(pulse, pulse, pulse)
				local x = math.cos(angle) * RADIUS_MAIN
				local z = math.sin(angle) * RADIUS_MAIN
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

		for idx, orb in ipairs(innerOrbs) do
			if orb and orb.Parent then
				local angle = -(t * 2.8) + (idx - 1) * (math.pi * 2 / NUM_INNER)
				local yOff = math.sin(t * 3.0 + idx * 2.1) * 0.4 + 1.0
				local x = math.cos(angle) * RADIUS_INNER
				local z = math.sin(angle) * RADIUS_INNER
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

		if groundRing and groundRing.Parent then
			local ringPulse = RADIUS_MAIN * 2 + math.sin(t * 2) * 0.3
			groundRing.Size = Vector3.new(0.05, ringPulse, ringPulse)
			groundRing.CFrame = CFrame.new(basePos - Vector3.new(0, 2.8, 0)) * CFrame.Angles(0, 0, math.rad(90))
			groundRing.Transparency = 0.82 + math.sin(t * 3) * 0.08
		end
	end)
end

function VisualsModule:DestroyAura()
	if self._auraData then
		if self._auraData.conn then
			self._auraData.conn:Disconnect()
		end
		if self._auraData.folder and self._auraData.folder.Parent then
			self._auraData.folder:Destroy()
		end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter:Destroy()
		end
		self._auraData = nil
	end
end

function VisualsModule:ConnectJumpCircles()
	self:DisconnectJumpCircles()
	local char = self.player.Character
	if not char then return end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	self._jumpConn = hum.StateChanged:Connect(function(_, newState)
		if newState == Enum.HumanoidStateType.Jumping then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if hrp then
				self:SpawnJumpCircle(hrp.Position - Vector3.new(0, 3, 0))
			end
		end
	end)
end

function VisualsModule:DisconnectJumpCircles()
	if self._jumpConn then
		self._jumpConn:Disconnect()
		self._jumpConn = nil
	end
end

function VisualsModule:SpawnJumpCircle(position)
	local ring = Instance.new("Part")
	ring.Name = "ArcJumpCircle"
	ring.Shape = Enum.PartType.Cylinder
	ring.Anchored = true
	ring.CanCollide = false
	ring.CanTouch = false
	ring.CanQuery = false
	ring.CastShadow = false
	ring.Material = Enum.Material.Neon
	ring.Color = self.JUMP_CIRCLES_COLOR
	ring.Size = Vector3.new(0.08, 1, 1)
	ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	ring.Transparency = 0.3
	ring.Parent = self.Workspace

	local expand = self.TweenService:Create(ring,
		TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.08, 8, 8), Transparency = 1}
	)
	expand:Play()
	expand.Completed:Connect(function()
		ring:Destroy()
	end)
end

function VisualsModule:PlaySparkleFX(position)
	local part = Instance.new("Part")
	part.Name = "ArcSparkleFX"
	part.Size = Vector3.new(0.5, 0.5, 0.5)
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.Transparency = 1
	part.CFrame = CFrame.new(position)
	part.Parent = self.Workspace

	local emitter = Instance.new("ParticleEmitter")
	emitter.Color = ColorSequence.new(self.KILLFX_COLOR)
	emitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(1, 0),
	})
	emitter.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.8, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	emitter.Lifetime = NumberRange.new(0.3, 0.7)
	emitter.Speed = NumberRange.new(8, 18)
	emitter.SpreadAngle = Vector2.new(360, 360)
	emitter.Rate = 0
	emitter.LightEmission = 1
	emitter.LightInfluence = 0
	emitter.Texture = "rbxassetid://6490035152"
	emitter.Parent = part

	emitter:Emit(30)

	local light = Instance.new("PointLight")
	light.Color = self.KILLFX_LIGHT_COLOR
	light.Range = self.KILLFX_LIGHT_RANGE
	light.Brightness = self.KILLFX_LIGHT_BRIGHTNESS
	light.Parent = part

	task.delay(0.1, function()
		if light and light.Parent then
			self.TweenService:Create(light, TweenInfo.new(0.5), {Range = 0}):Play()
		end
	end)

	self.Debris:AddItem(part, 1.5)
end

function VisualsModule:PlayRingFX(position)
	local ring = Instance.new("Part")
	ring.Name = "ArcRingFX"
	ring.Shape = Enum.PartType.Cylinder
	ring.Anchored = true
	ring.CanCollide = false
	ring.CanQuery = false
	ring.CanTouch = false
	ring.CastShadow = false
	ring.Material = Enum.Material.Neon
	ring.Color = self.KILLFX_COLOR
	ring.Size = Vector3.new(0.1, 0.5, 0.5)
	ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	ring.Transparency = 0
	ring.Parent = self.Workspace

	self.TweenService:Create(ring,
		TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.1, 12, 12), Transparency = 1}
	):Play()

	self.Debris:AddItem(ring, 1)
end

function VisualsModule:PlayBeamFX(position)
	local beam = Instance.new("Part")
	beam.Name = "ArcBeamFX"
	beam.Anchored = true
	beam.CanCollide = false
	beam.CanQuery = false
	beam.CanTouch = false
	beam.CastShadow = false
	beam.Material = Enum.Material.Neon
	beam.Color = self.KILLFX_COLOR
	beam.Size = Vector3.new(0.15, 0.1, 0.15)
	beam.CFrame = CFrame.new(position)
	beam.Transparency = 0.2
	beam.Parent = self.Workspace

	local light = Instance.new("PointLight")
	light.Color = self.KILLFX_LIGHT_COLOR
	light.Range = self.KILLFX_LIGHT_RANGE * 0.5
	light.Brightness = self.KILLFX_LIGHT_BRIGHTNESS
	light.Parent = beam

	self.TweenService:Create(beam,
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.15, 25, 0.15), CFrame = CFrame.new(position + Vector3.new(0, 12.5, 0))}
	):Play()

	task.delay(0.4, function()
		if beam and beam.Parent then
			self.TweenService:Create(beam,
				TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
			if light then
				self.TweenService:Create(light, TweenInfo.new(0.35), {Range = 0}):Play()
			end
		end
	end)

	self.Debris:AddItem(beam, 1.5)
end

function VisualsModule:FixFxInstance(fx, cf)
	if fx:IsA("Model") then
		for _, d in ipairs(fx:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
				d.CanQuery = false
				d.CanTouch = false
			end
		end
		fx:PivotTo(cf)
	elseif fx:IsA("BasePart") then
		fx.Anchored = true
		fx.CanCollide = false
		fx.CanQuery = false
		fx.CanTouch = false
		fx.CFrame = cf
	end
end

function VisualsModule:RecolorParticles(root, color)
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Color = ColorSequence.new(color)
		end
	end
end

function VisualsModule:PlayImpactFX(position)
	local template = self.FX_ROOT:FindFirstChild("ImpactFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(0.15, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:PlayCustomFX(position)
	local template = self.FX_ROOT:FindFirstChild("CustomFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	local light = fx:FindFirstChild("PointLight") or fx:FindFirstChildWhichIsA("PointLight", true)
	if light then
		light.Color = self.KILLFX_LIGHT_COLOR
		light.Range = 0
		light.Brightness = self.KILLFX_LIGHT_BRIGHTNESS
		light.Enabled = true

		local tIn = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = self.KILLFX_LIGHT_RANGE })
		local tOut = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = 0 })

		tIn:Play()
		tIn.Completed:Once(function()
			tOut:Play()
		end)
	end

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(self.KILLFX_CUSTOM_DURATION, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:SetupKillFXListener()
	local InfEvent = self.ReplicatedStorage:WaitForChild("inf", 10)
	if InfEvent then
		InfEvent.OnClientEvent:Connect(function(killedPlayerName)
			if not self.KILLFX_ENABLED then return end

			local killedPlayer = self.Players:FindFirstChild(killedPlayerName)
			if not killedPlayer then return end

			local char = killedPlayer.Character
			if not char then return end

			local head = char:FindFirstChild("Head")
			if not head then return end

			local pos = head.Position
			if self.KILLFX_TYPE == "Sparkle" then
				self:PlaySparkleFX(pos)
			elseif self.KILLFX_TYPE == "Ring" then
				self:PlayRingFX(pos)
			elseif self.KILLFX_TYPE == "Beam" then
				self:PlayBeamFX(pos)
			end

		end)
	end

	task.spawn(function()
		local htl = self.ReplicatedStorage:WaitForChild("htl", 10)
		if not htl then return end

		htl.OnClientEvent:Connect(function(hitType, info)
			if hitType == "Hit" then
				self:PlayHitSound()
				self:FlashHitMarker()
			end

			if hitType == "Hit" and info and self.KILLIMAGE_ENABLED then
				local dmg = info.damage or 0
				if dmg > 99 then
					self:PlayKillImage()
				end
			end

			if self.HITLOG_ENABLED then
				self:ShowHitlog(hitType, info)
			end
		end)
	end)
end

function VisualsModule:IsFakeLagEnabledFallback()
	if typeof(self.IsFakeLagEnabled) == "function" then
		local ok, v = pcall(self.IsFakeLagEnabled)
		if ok then return v == true end
	end
	if _G.ConfigSystem and _G.ConfigSystem.settings then
		return _G.ConfigSystem.settings["FakeLag"] == true
	end
	return false
end

function VisualsModule:SetupBacktrackGhost()
	local backtrackRemote = self.ReplicatedStorage:WaitForChild("btl")
	local lastSend = 0

	local ghostsFolder = self.Workspace:FindFirstChild("BacktrackGhosts") or Instance.new("Folder", self.Workspace)
	ghostsFolder.Name = "BacktrackGhosts"
	self._ghostsFolder = ghostsFolder

	self.RunService.Heartbeat:Connect(function()
		local now = tick()
		local dt = now - self._hbLast
		self._hbLast = now
		self._ghostDt = dt

		if self.ghostModel and now > self.ghostExpireAt then
			self:ClearBacktrackGhost()
		end

		if self.BACKTRACK_GHOST_ENABLED and self.player.Character then
			local hrp = self.player.Character:FindFirstChild("HumanoidRootPart")
			if hrp then
				if now - lastSend > 0.05 then
					lastSend = now
					backtrackRemote:FireServer(self:IsFakeLagEnabledFallback())
				end
			end
		end
	end)

	backtrackRemote.OnClientEvent:Connect(function(cframe, isFakelag, ping)
		if not self.BACKTRACK_GHOST_ENABLED then return end

		if not isFakelag and ping then
			local char = self.player.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local velocity = hrp.AssemblyLinearVelocity
					local pingOffset = velocity * (ping * 0.5)
					cframe = hrp.CFrame - pingOffset
				end
			end
		end

		self:UpdateBacktrackGhostPose(cframe, isFakelag)
	end)

	self.player.CharacterAdded:Connect(function()
		self:ClearBacktrackGhost()
	end)

	self.player.CharacterRemoving:Connect(function()
		self:ClearBacktrackGhost()
	end)
end

function VisualsModule:ClearBacktrackGhost()
	if self.ghostModel then
		self.ghostModel:Destroy()
		self.ghostModel = nil
		table.clear(self.ghostParts)
		table.clear(self.ghostLastCFrames)
	end
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
end

function VisualsModule:CreateBacktrackGhost()
	local srcChar = self.player.Character
	if not srcChar then return nil end

	local root = srcChar:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	srcChar.Archivable = true
	local ghost = srcChar:Clone()
	srcChar.Archivable = false
	if not ghost then return nil end

	ghost.Name = self.player.Name .. "_BacktrackGhost"

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("Sound")
			or v:IsA("BillboardGui") or v:IsA("Humanoid")
			or v:IsA("AlignPosition") or v:IsA("AlignOrientation")
			or v:IsA("BodyMover") or v:IsA("BodyGyro") or v:IsA("BodyVelocity")
			or v:IsA("BodyPosition") or v:IsA("BodyForce") or v:IsA("VectorForce")
			or v:IsA("LineForce") or v:IsA("Animator") then
			v:Destroy()
		end
	end

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Motor6D") or v:IsA("Weld") or v:IsA("WeldConstraint")
			or v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint")
			or v:IsA("Constraint") or v:IsA("JointInstance") then
			v:Destroy()
		end
	end

	local hasParts = false
	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			hasParts = true
			v.Anchored = true
			v.CanCollide = false
			v.CanTouch = false
			v.CanQuery = false
			v.Massless = true
			v.Material = Enum.Material.ForceField
			v.Transparency = self.GHOST_BASE_TRANSPARENCY
			v.Color = self.BACKTRACK_GHOST_COLOR
			v.CastShadow = false

			if v.Name == "Head" then
				local face = v:FindFirstChild("face")
				if face then face:Destroy() end
			end
		end
	end

	if not hasParts then
		ghost:Destroy()
		return nil
	end

	table.clear(self.ghostParts)
	for _, v in ipairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			table.insert(self.ghostParts, v)
		end
	end

	ghost.Parent = self._ghostsFolder
	return ghost
end

function VisualsModule:UpdateBacktrackGhostPose(targetCFrame, isFakelag)
	if not self.BACKTRACK_GHOST_ENABLED then return end

	local srcChar = self.player.Character
	if not srcChar then return end

	local humanoid = srcChar:FindFirstChild("Humanoid")
	if humanoid and humanoid.Health <= 0 then
		self:ClearBacktrackGhost()
		return
	end

	if (not self.ghostModel) or (self.sourceCharacter ~= srcChar) or (self.lastFakeLagState ~= isFakelag) or (not self.ghostModel.Parent) then
		self:ClearBacktrackGhost()
		self.ghostModel = self:CreateBacktrackGhost()
		if self.ghostModel then
			self.sourceCharacter = srcChar
			self.lastFakeLagState = isFakelag
		else
			return
		end
	end

	local srcRoot = srcChar:FindFirstChild("HumanoidRootPart")
	if not srcRoot then return end

	local currentRootCFrame = srcRoot.CFrame
	local offset = targetCFrame * currentRootCFrame:Inverse()

	local dt = tonumber(self._ghostDt) or (1 / 60)
	local alpha = math.clamp(self.GHOST_SMOOTH_SPEED * dt, 0, 1)

for _, ghostPart in ipairs(self.ghostParts) do
	local srcPart = srcChar:FindFirstChild(ghostPart.Name, true)
	if srcPart then
		local targetCF = offset * srcPart.CFrame
		local lastCF = self.ghostLastCFrames[ghostPart] or ghostPart.CFrame
		local newCF = lastCF:Lerp(targetCF, alpha)
		ghostPart.CFrame = newCF
		self.ghostLastCFrames[ghostPart] = newCF

		local dist = (newCF.Position - srcPart.Position).Magnitude

		if dist < self.GHOST_FADE_RADIUS then
			local k = math.clamp(1 - (dist / self.GHOST_FADE_RADIUS), 0, 1)
			k = k ^ self.GHOST_FADE_POWER
			ghostPart.Transparency = math.clamp(
				self.GHOST_BASE_TRANSPARENCY + k * (1 - self.GHOST_BASE_TRANSPARENCY),
				0,
				1
			)
		else
			ghostPart.Transparency = self.GHOST_BASE_TRANSPARENCY
		end
	end
end

	self.ghostExpireAt = tick() + self.BACKTRACK_GHOST_DURATION
end

function VisualsModule:SnapshotFirstEffect(className)
	local inst = self.Lighting:FindFirstChildOfClass(className)
	if not inst then return nil end
	local c = inst:Clone()
	c.Name = "NemesisOriginal_" .. className
	return c
end

function VisualsModule:WipeClass(className)
	for _, inst in ipairs(self.Lighting:GetDescendants()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
	for _, inst in ipairs(self.Lighting:GetChildren()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
end

function VisualsModule:ApplySingleEffect(className, enabled, applyFn)
	if enabled then
		self:WipeClass(className)
		local fx = Instance.new(className)
		fx.Name = "Nemesis_" .. className
		fx.Parent = self.Lighting
		applyFn(fx)
	else
		self:WipeClass(className)
		local original = self.ORIGINAL_EFFECTS[className]
		if original then
			original:Clone().Parent = self.Lighting
		end
	end
end

function VisualsModule:UpdateAtmosphere()
	self:ApplySingleEffect("Atmosphere", self.ATMOSPHERE_ENABLED, function(atmosphere)
		atmosphere.Density = self.ATMOSPHERE_DENSITY
		atmosphere.Offset = self.ATMOSPHERE_OFFSET
		atmosphere.Color = self.ATMOSPHERE_COLOR
		atmosphere.Decay = self.ATMOSPHERE_DECAY
		atmosphere.Glare = self.ATMOSPHERE_GLARE
		atmosphere.Haze = self.ATMOSPHERE_HAZE
	end)
end

function VisualsModule:SetAtmosphereEnabled(value)
	self.ATMOSPHERE_ENABLED = value
	self:UpdateAtmosphere()
end

function VisualsModule:SetAtmosphereDensity(value)
	self.ATMOSPHERE_DENSITY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereOffset(value)
	self.ATMOSPHERE_OFFSET = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereColor(value)
	self.ATMOSPHERE_COLOR = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereDecay(value)
	self.ATMOSPHERE_DECAY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereGlare(value)
	self.ATMOSPHERE_GLARE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereHaze(value)
	self.ATMOSPHERE_HAZE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:UpdateBloom()
	self:ApplySingleEffect("BloomEffect", self.BLOOM_ENABLED, function(bloom)
		bloom.Enabled = true
		bloom.Intensity = self.BLOOM_INTENSITY
		bloom.Size = self.BLOOM_SIZE
		bloom.Threshold = self.BLOOM_THRESHOLD
	end)
end

function VisualsModule:SetBloomEnabled(value)
	self.BLOOM_ENABLED = value
	self:UpdateBloom()
end

function VisualsModule:SetBloomIntensity(value)
	self.BLOOM_INTENSITY = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomSize(value)
	self.BLOOM_SIZE = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomThreshold(value)
	self.BLOOM_THRESHOLD = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:UpdateColorCorrection()
	self:ApplySingleEffect("ColorCorrectionEffect", self.COLOR_CORRECTION_ENABLED, function(cc)
		cc.Brightness = self.COLOR_CORRECTION_BRIGHTNESS
		cc.Contrast = self.COLOR_CORRECTION_CONTRAST
		cc.Saturation = self.COLOR_CORRECTION_SATURATION
		cc.TintColor = self.COLOR_CORRECTION_TINT
	end)
end

function VisualsModule:SetColorCorrectionEnabled(value)
	self.COLOR_CORRECTION_ENABLED = value
	self:UpdateColorCorrection()
end

function VisualsModule:SetColorCorrectionBrightness(value)
	self.COLOR_CORRECTION_BRIGHTNESS = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionContrast(value)
	self.COLOR_CORRECTION_CONTRAST = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionSaturation(value)
	self.COLOR_CORRECTION_SATURATION = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionTint(value)
	self.COLOR_CORRECTION_TINT = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetHitlogEnabled(value)
	self.HITLOG_ENABLED = value
	if self.hitlogContainer then
		self.hitlogContainer.Visible = value
	end
end

function VisualsModule:SetHitSoundEnabled(value)
	self.HITSOUND_ENABLED = value
end

function VisualsModule:SetHitSoundPreset(value)
	self.HITSOUND_PRESET = value
end

function VisualsModule:SetHitSoundVolume(value)
	self.HITSOUND_VOLUME = value
end

function VisualsModule:SetTracerEnabled(value)
	self.TRACER_ENABLED = value
end

function VisualsModule:SetTracerColor(value)
	self.TRACER_COLOR = value
end

function VisualsModule:SetTracerLifetime(value)
	self.TRACER_LIFETIME = value
end

function VisualsModule:SetTracerWidth(value)
	self.TRACER_WIDTH = value
end

function VisualsModule:SetTracerNeon(value)
	self.TRACER_NEON = value
	if value then
		self.TRACER_BRIGHTNESS = 40
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0
	else
		self.TRACER_BRIGHTNESS = 20
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0.95
	end
end

function VisualsModule:SetChinaHatEnabled(value)
	self.CHINA_HAT_ENABLED = value
	if value then
		self:SpawnChinaHat()
	else
		self:DestroyChinaHat()
	end
end

function VisualsModule:SetChinaHatColor(value)
	self.CHINA_HAT_COLOR = value
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p.Color = value end
	end
end

function VisualsModule:SetWingsEnabled(value)
	self.WINGS_ENABLED = value
	if value then
		self:SpawnWings()
	else
		self:DestroyWings()
	end
end

function VisualsModule:SetWingsColor(value)
	self.WINGS_COLOR = value
	if self._wingData then
		for _, f in ipairs(self._wingData.feathers) do
			if f.part and f.part.Parent then
				f.part.Color = value
			end
			if f.trail then
				f.trail.Color = ColorSequence.new(value)
			end
		end
	end
end

function VisualsModule:SetAuraEnabled(value)
	self.AURA_ENABLED = value
	if value then
		self:SpawnAura()
	else
		self:DestroyAura()
	end
end

function VisualsModule:SetAuraColor(value)
	self.AURA_COLOR = value
	if self._auraData then
		local function colorOrb(orb)
			if orb and orb.Parent then
				orb.Color = value
				local light = orb:FindFirstChildOfClass("PointLight")
				if light then light.Color = value end
				local trail = orb:FindFirstChildOfClass("Trail")
				if trail then trail.Color = ColorSequence.new(value) end
			end
		end
		for _, orb in ipairs(self._auraData.mainOrbs) do colorOrb(orb) end
		for _, orb in ipairs(self._auraData.innerOrbs) do colorOrb(orb) end
		if self._auraData.groundRing and self._auraData.groundRing.Parent then
			self._auraData.groundRing.Color = value
		end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter.Color = ColorSequence.new(value)
		end
	end
end

function VisualsModule:SetJumpCirclesEnabled(value)
	self.JUMP_CIRCLES_ENABLED = value
	if value then
		self:ConnectJumpCircles()
	else
		self:DisconnectJumpCircles()
	end
end

function VisualsModule:SetJumpCirclesColor(value)
	self.JUMP_CIRCLES_COLOR = value
end

function VisualsModule:SetHitMarkerEnabled(value)
	self.HIT_MARKER_ENABLED = value
end


function VisualsModule:SetWallbangEnabled(value)
	self.WALLBANG_ENABLED = value
end

function VisualsModule:SetWallbangEntryColor(value)
	self.WALLBANG_ENTRY_COLOR = value
end

function VisualsModule:SetWallbangExitColor(value)
	self.WALLBANG_EXIT_COLOR = value
end

function VisualsModule:SetWallbangMarkerSize(value)
	if typeof(value) == "number" then
		self.WALLBANG_MARKER_SIZE = Vector3.new(value, value, value)
	elseif typeof(value) == "Vector3" then
		self.WALLBANG_MARKER_SIZE = value
	end
end

function VisualsModule:SetWallbangLifetime(value)
	self.WALLBANG_LIFETIME = value
end

function VisualsModule:SetKillFXEnabled(value)
	self.KILLFX_ENABLED = value
end

function VisualsModule:SetKillFXType(value)
	self.KILLFX_TYPE = value
end

function VisualsModule:SetKillFXColor(value)
	self.KILLFX_COLOR = value
end

function VisualsModule:SetKillFXLightColor(value)
	self.KILLFX_LIGHT_COLOR = value
end

function VisualsModule:SetKillFXDuration(value)
	self.KILLFX_CUSTOM_DURATION = value
end

function VisualsModule:SetKillFXLightRange(value)
	self.KILLFX_LIGHT_RANGE = value
end

function VisualsModule:SetKillFXLightBrightness(value)
	self.KILLFX_LIGHT_BRIGHTNESS = value
end

function VisualsModule:SetOffscreenEnabled(value)
	self.OFFSCREEN_ENABLED = value
end

function VisualsModule:SetOffscreenColor(value)
	self.OFFSCREEN_COLOR = value
end

function VisualsModule:SetBacktrackGhostEnabled(value)
	self.BACKTRACK_GHOST_ENABLED = value
	if not value then
		self:ClearBacktrackGhost()
	end
end

function VisualsModule:SetBacktrackGhostColor(value)
	self.BACKTRACK_GHOST_COLOR = value
	for _, p in ipairs(self.ghostParts) do
		p.Color = value
		p.Transparency = self.GHOST_BASE_TRANSPARENCY
	end
end

function VisualsModule:SetBacktrackGhostDuration(value)
	self.BACKTRACK_GHOST_DURATION = value
end

function VisualsModule:SetKillImageEnabled(value)
	self.KILLIMAGE_ENABLED = value
end

function VisualsModule:SetKillImageColor(value)
	self.KILLIMAGE_COLOR = value
end

function VisualsModule:SetKillImageMaxAlpha(value)
	self.KILLIMAGE_MAX_ALPHA = value
end

function VisualsModule:GetSettings()
	local function colorToTable(c)
		return { math.floor(c.R * 255), math.floor(c.G * 255), math.floor(c.B * 255) }
	end

	return {
		HITLOG_ENABLED = self.HITLOG_ENABLED,
		HITSOUND_ENABLED = self.HITSOUND_ENABLED,
		HITSOUND_PRESET = self.HITSOUND_PRESET,
		HITSOUND_VOLUME = self.HITSOUND_VOLUME,

		OFFSCREEN_ENABLED = self.OFFSCREEN_ENABLED,
		OFFSCREEN_COLOR = colorToTable(self.OFFSCREEN_COLOR),

		WALLBANG_ENABLED = self.WALLBANG_ENABLED,
		WALLBANG_ENTRY_COLOR = colorToTable(self.WALLBANG_ENTRY_COLOR),
		WALLBANG_EXIT_COLOR = colorToTable(self.WALLBANG_EXIT_COLOR),
		WALLBANG_MARKER_SIZE = self.WALLBANG_MARKER_SIZE.X,
		WALLBANG_LIFETIME = self.WALLBANG_LIFETIME,

		KILLFX_ENABLED = self.KILLFX_ENABLED,
		KILLFX_TYPE = self.KILLFX_TYPE,
		KILLFX_COLOR = colorToTable(self.KILLFX_COLOR),
		KILLFX_LIGHT_COLOR = colorToTable(self.KILLFX_LIGHT_COLOR),
		KILLFX_CUSTOM_DURATION = self.KILLFX_CUSTOM_DURATION,
		KILLFX_LIGHT_RANGE = self.KILLFX_LIGHT_RANGE,
		KILLFX_LIGHT_BRIGHTNESS = self.KILLFX_LIGHT_BRIGHTNESS,

		KILLIMAGE_ENABLED = self.KILLIMAGE_ENABLED,
		KILLIMAGE_COLOR = colorToTable(self.KILLIMAGE_COLOR),
		KILLIMAGE_MAX_ALPHA = self.KILLIMAGE_MAX_ALPHA,

		BACKTRACK_GHOST_ENABLED = self.BACKTRACK_GHOST_ENABLED,
		BACKTRACK_GHOST_COLOR = colorToTable(self.BACKTRACK_GHOST_COLOR),
		BACKTRACK_GHOST_DURATION = self.BACKTRACK_GHOST_DURATION,

		TRACER_ENABLED = self.TRACER_ENABLED,
		TRACER_COLOR = colorToTable(self.TRACER_COLOR),
		TRACER_LIFETIME = self.TRACER_LIFETIME,
		TRACER_WIDTH = self.TRACER_WIDTH,
		TRACER_NEON = self.TRACER_NEON,

		CHINA_HAT_ENABLED = self.CHINA_HAT_ENABLED,
		CHINA_HAT_COLOR = colorToTable(self.CHINA_HAT_COLOR),
		WINGS_ENABLED = self.WINGS_ENABLED,
		WINGS_COLOR = colorToTable(self.WINGS_COLOR),
		AURA_ENABLED = self.AURA_ENABLED,
		AURA_COLOR = colorToTable(self.AURA_COLOR),
		JUMP_CIRCLES_ENABLED = self.JUMP_CIRCLES_ENABLED,
		JUMP_CIRCLES_COLOR = colorToTable(self.JUMP_CIRCLES_COLOR),

		HIT_MARKER_ENABLED = self.HIT_MARKER_ENABLED,

		ATMOSPHERE_ENABLED = self.ATMOSPHERE_ENABLED,
		ATMOSPHERE_DENSITY = self.ATMOSPHERE_DENSITY,
		ATMOSPHERE_OFFSET = self.ATMOSPHERE_OFFSET,
		ATMOSPHERE_COLOR = colorToTable(self.ATMOSPHERE_COLOR),
		ATMOSPHERE_DECAY = colorToTable(self.ATMOSPHERE_DECAY),
		ATMOSPHERE_GLARE = self.ATMOSPHERE_GLARE,
		ATMOSPHERE_HAZE = self.ATMOSPHERE_HAZE,

		BLOOM_ENABLED = self.BLOOM_ENABLED,
		BLOOM_INTENSITY = self.BLOOM_INTENSITY,
		BLOOM_SIZE = self.BLOOM_SIZE,
		BLOOM_THRESHOLD = self.BLOOM_THRESHOLD,

		COLOR_CORRECTION_ENABLED = self.COLOR_CORRECTION_ENABLED,
		COLOR_CORRECTION_BRIGHTNESS = self.COLOR_CORRECTION_BRIGHTNESS,
		COLOR_CORRECTION_CONTRAST = self.COLOR_CORRECTION_CONTRAST,
		COLOR_CORRECTION_SATURATION = self.COLOR_CORRECTION_SATURATION,
		COLOR_CORRECTION_TINT = colorToTable(self.COLOR_CORRECTION_TINT),
	}
end

function VisualsModule:ApplySettings(settings)
	if not settings then return end

	local function toColor3(arr)
		if type(arr) == "table" and #arr >= 3 then
			return Color3.fromRGB(arr[1], arr[2], arr[3])
		end
		return nil
	end

	if settings.HITLOG_ENABLED ~= nil then self:SetHitlogEnabled(settings.HITLOG_ENABLED) end
	if settings.HITSOUND_ENABLED ~= nil then self:SetHitSoundEnabled(settings.HITSOUND_ENABLED) end
	if settings.HITSOUND_PRESET ~= nil then self:SetHitSoundPreset(settings.HITSOUND_PRESET) end
	if settings.HITSOUND_VOLUME ~= nil then self:SetHitSoundVolume(settings.HITSOUND_VOLUME) end

	if settings.OFFSCREEN_ENABLED ~= nil then self:SetOffscreenEnabled(settings.OFFSCREEN_ENABLED) end
	if settings.OFFSCREEN_COLOR then self:SetOffscreenColor(toColor3(settings.OFFSCREEN_COLOR) or self.OFFSCREEN_COLOR) end

	if settings.WALLBANG_ENABLED ~= nil then self:SetWallbangEnabled(settings.WALLBANG_ENABLED) end
	if settings.WALLBANG_ENTRY_COLOR then self:SetWallbangEntryColor(toColor3(settings.WALLBANG_ENTRY_COLOR) or self.WALLBANG_ENTRY_COLOR) end
	if settings.WALLBANG_EXIT_COLOR then self:SetWallbangExitColor(toColor3(settings.WALLBANG_EXIT_COLOR) or self.WALLBANG_EXIT_COLOR) end
	if settings.WALLBANG_MARKER_SIZE ~= nil then self:SetWallbangMarkerSize(settings.WALLBANG_MARKER_SIZE) end
	if settings.WALLBANG_LIFETIME ~= nil then self:SetWallbangLifetime(settings.WALLBANG_LIFETIME) end

	if settings.KILLFX_ENABLED ~= nil then self:SetKillFXEnabled(settings.KILLFX_ENABLED) end
	if settings.KILLFX_TYPE ~= nil then self:SetKillFXType(settings.KILLFX_TYPE) end
	if settings.KILLFX_COLOR then self:SetKillFXColor(toColor3(settings.KILLFX_COLOR) or self.KILLFX_COLOR) end
	if settings.KILLFX_LIGHT_COLOR then self:SetKillFXLightColor(toColor3(settings.KILLFX_LIGHT_COLOR) or self.KILLFX_LIGHT_COLOR) end
	if settings.KILLFX_CUSTOM_DURATION ~= nil then self:SetKillFXDuration(settings.KILLFX_CUSTOM_DURATION) end
	if settings.KILLFX_LIGHT_RANGE ~= nil then self:SetKillFXLightRange(settings.KILLFX_LIGHT_RANGE) end
	if settings.KILLFX_LIGHT_BRIGHTNESS ~= nil then self:SetKillFXLightBrightness(settings.KILLFX_LIGHT_BRIGHTNESS) end

	if settings.KILLIMAGE_ENABLED ~= nil then self:SetKillImageEnabled(settings.KILLIMAGE_ENABLED) end
	if settings.KILLIMAGE_COLOR then self:SetKillImageColor(toColor3(settings.KILLIMAGE_COLOR) or self.KILLIMAGE_COLOR) end
	if settings.KILLIMAGE_MAX_ALPHA ~= nil then self:SetKillImageMaxAlpha(settings.KILLIMAGE_MAX_ALPHA) end

	if settings.BACKTRACK_GHOST_ENABLED ~= nil then self:SetBacktrackGhostEnabled(settings.BACKTRACK_GHOST_ENABLED) end
	if settings.BACKTRACK_GHOST_COLOR then self:SetBacktrackGhostColor(toColor3(settings.BACKTRACK_GHOST_COLOR) or self.BACKTRACK_GHOST_COLOR) end
	if settings.BACKTRACK_GHOST_DURATION ~= nil then self:SetBacktrackGhostDuration(settings.BACKTRACK_GHOST_DURATION) end

	if settings.TRACER_ENABLED ~= nil then self:SetTracerEnabled(settings.TRACER_ENABLED) end
	if settings.TRACER_COLOR then self:SetTracerColor(toColor3(settings.TRACER_COLOR) or self.TRACER_COLOR) end
	if settings.TRACER_LIFETIME ~= nil then self:SetTracerLifetime(settings.TRACER_LIFETIME) end
	if settings.TRACER_WIDTH ~= nil then self:SetTracerWidth(settings.TRACER_WIDTH) end
	if settings.TRACER_NEON ~= nil then self:SetTracerNeon(settings.TRACER_NEON) end

	if settings.CHINA_HAT_ENABLED ~= nil then self:SetChinaHatEnabled(settings.CHINA_HAT_ENABLED) end
	if settings.CHINA_HAT_COLOR then self:SetChinaHatColor(toColor3(settings.CHINA_HAT_COLOR) or self.CHINA_HAT_COLOR) end
	if settings.WINGS_ENABLED ~= nil then self:SetWingsEnabled(settings.WINGS_ENABLED) end
	if settings.WINGS_COLOR then self:SetWingsColor(toColor3(settings.WINGS_COLOR) or self.WINGS_COLOR) end
	if settings.AURA_ENABLED ~= nil then self:SetAuraEnabled(settings.AURA_ENABLED) end
	if settings.AURA_COLOR then self:SetAuraColor(toColor3(settings.AURA_COLOR) or self.AURA_COLOR) end
	if settings.JUMP_CIRCLES_ENABLED ~= nil then self:SetJumpCirclesEnabled(settings.JUMP_CIRCLES_ENABLED) end
	if settings.JUMP_CIRCLES_COLOR then self:SetJumpCirclesColor(toColor3(settings.JUMP_CIRCLES_COLOR) or self.JUMP_CIRCLES_COLOR) end

	if settings.HIT_MARKER_ENABLED ~= nil then self:SetHitMarkerEnabled(settings.HIT_MARKER_ENABLED) end

	if settings.ATMOSPHERE_ENABLED ~= nil then self:SetAtmosphereEnabled(settings.ATMOSPHERE_ENABLED) end
	if settings.ATMOSPHERE_DENSITY ~= nil then self:SetAtmosphereDensity(settings.ATMOSPHERE_DENSITY) end
	if settings.ATMOSPHERE_OFFSET ~= nil then self:SetAtmosphereOffset(settings.ATMOSPHERE_OFFSET) end
	if settings.ATMOSPHERE_COLOR then self:SetAtmosphereColor(toColor3(settings.ATMOSPHERE_COLOR) or self.ATMOSPHERE_COLOR) end
	if settings.ATMOSPHERE_DECAY then self:SetAtmosphereDecay(toColor3(settings.ATMOSPHERE_DECAY) or self.ATMOSPHERE_DECAY) end
	if settings.ATMOSPHERE_GLARE ~= nil then self:SetAtmosphereGlare(settings.ATMOSPHERE_GLARE) end
	if settings.ATMOSPHERE_HAZE ~= nil then self:SetAtmosphereHaze(settings.ATMOSPHERE_HAZE) end

	if settings.BLOOM_ENABLED ~= nil then self:SetBloomEnabled(settings.BLOOM_ENABLED) end
	if settings.BLOOM_INTENSITY ~= nil then self:SetBloomIntensity(settings.BLOOM_INTENSITY) end
	if settings.BLOOM_SIZE ~= nil then self:SetBloomSize(settings.BLOOM_SIZE) end
	if settings.BLOOM_THRESHOLD ~= nil then self:SetBloomThreshold(settings.BLOOM_THRESHOLD) end

	if settings.COLOR_CORRECTION_ENABLED ~= nil then self:SetColorCorrectionEnabled(settings.COLOR_CORRECTION_ENABLED) end
	if settings.COLOR_CORRECTION_BRIGHTNESS ~= nil then self:SetColorCorrectionBrightness(settings.COLOR_CORRECTION_BRIGHTNESS) end
	if settings.COLOR_CORRECTION_CONTRAST ~= nil then self:SetColorCorrectionContrast(settings.COLOR_CORRECTION_CONTRAST) end
	if settings.COLOR_CORRECTION_SATURATION ~= nil then self:SetColorCorrectionSaturation(settings.COLOR_CORRECTION_SATURATION) end
	if settings.COLOR_CORRECTION_TINT then self:SetColorCorrectionTint(toColor3(settings.COLOR_CORRECTION_TINT) or self.COLOR_CORRECTION_TINT) end
end

function VisualsModule:Start()
end

return VisualsModule
