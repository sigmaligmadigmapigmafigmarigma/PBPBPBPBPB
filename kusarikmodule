local VisualsModule = {}
VisualsModule.__index = VisualsModule

function VisualsModule.new(config)
	local self = setmetatable({}, VisualsModule)

	self.player = config.Player
	self.guiParent = config.GuiParent
	self.Services = config.Services or {}

	self.Players = self.Services.Players
	self.TweenService = self.Services.TweenService
	self.RunService = self.Services.RunService
	self.UserInputService = self.Services.UserInputService
	self.ReplicatedStorage = self.Services.ReplicatedStorage
	self.Workspace = self.Services.Workspace
	self.Lighting = self.Services.Lighting
	self.Debris = self.Services.Debris
	self.SoundService = self.Services.SoundService
	self.HttpService = self.Services.HttpService

	self.Notification = config.Notification
	self.IsFakeLagEnabled = config.IsFakeLagEnabled

	self.HITLOG_ENABLED = false
	self.HITSOUND_ENABLED = true
	self.HITSOUND_VOLUME = 1
	self.HITSOUND_PRESET = "bell"

self.GHOST_BASE_TRANSPARENCY = 0.7
self.GHOST_FADE_RADIUS = 1.6
self.GHOST_FADE_POWER = 1.2

	self.TRACER_ENABLED = false
	self.TRACER_COLOR = Color3.fromRGB(255, 255, 255)
	self.TRACER_LIFETIME = 0.45
	self.TRACER_WIDTH = 0.12
	self.TRACER_NEON = false
	self.TRACER_STYLE = "Classic"

	self.TRACER_BRIGHTNESS = 20
	self.TRACER_LIGHTEMISSION = 1
	self.TRACER_LIGHTINFLUENCE = 0.95
	self.TRACER_TAIL = 2
	self.TRACER_TRANSPARENCY = NumberSequence.new({
		NumberSequenceKeypoint.new(0.00, 1.00),
		NumberSequenceKeypoint.new(0.125, 0.05),
		NumberSequenceKeypoint.new(0.89, 0.0562),
		NumberSequenceKeypoint.new(1.00, 1.00),
	})

	self.WALLBANG_ENABLED = false
	self.WALLBANG_ENTRY_COLOR = Color3.fromRGB(255, 50, 50)
	self.WALLBANG_EXIT_COLOR = Color3.fromRGB(50, 255, 50)
	self.WALLBANG_MARKER_SIZE = Vector3.new(0.5, 0.5, 0.5)
	self.WALLBANG_LIFETIME = 3

	self.KILLFX_ENABLED = false
	self.KILLFX_TYPE = "Sparkle"
	self.KILLFX_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLFX_LIGHT_COLOR = Color3.fromRGB(120, 180, 255)
	self.KILLFX_CUSTOM_DURATION = 0.25
	self.KILLFX_LIGHT_RANGE = 15
	self.KILLFX_LIGHT_BRIGHTNESS = 1

	self.OFFSCREEN_ENABLED = false
	self.OFFSCREEN_COLOR = Color3.fromRGB(255, 80, 80)

	self.BACKTRACK_GHOST_ENABLED = false
	self.BACKTRACK_GHOST_COLOR = Color3.fromRGB(80, 160, 255)
	self.BACKTRACK_GHOST_DURATION = 0.3

	self.KILLIMAGE_ENABLED = false
	self.KILLIMAGE_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLIMAGE_FADE_IN = 0.08
	self.KILLIMAGE_HOLD = 0.1
	self.KILLIMAGE_FADE_OUT = 0.6
	self.KILLIMAGE_MAX_ALPHA = 0.45

	self.ATMOSPHERE_ENABLED = false
	self.ATMOSPHERE_DENSITY = 0.3
	self.ATMOSPHERE_OFFSET = 0.25
	self.ATMOSPHERE_COLOR = Color3.fromRGB(200, 200, 200)
	self.ATMOSPHERE_DECAY = Color3.fromRGB(128, 128, 128)
	self.ATMOSPHERE_GLARE = 0.5
	self.ATMOSPHERE_HAZE = 0.5

	self.BLOOM_ENABLED = false
	self.BLOOM_INTENSITY = 2
	self.BLOOM_SIZE = 56
	self.BLOOM_THRESHOLD = 0.8

	self.COLOR_CORRECTION_ENABLED = false
	self.COLOR_CORRECTION_BRIGHTNESS = 0
	self.COLOR_CORRECTION_CONTRAST = 0
	self.COLOR_CORRECTION_SATURATION = 0
	self.COLOR_CORRECTION_TINT = Color3.fromRGB(255, 255, 255)

	self.CHINA_HAT_ENABLED = false
	self.CHINA_HAT_COLOR = Color3.fromRGB(255, 255, 255)
	self._chinaHatParts = {}

	self.WINGS_ENABLED = false
	self.WINGS_COLOR = Color3.fromRGB(255, 255, 255)
	self._wingData = nil

	self.AURA_ENABLED = false
	self.AURA_COLOR = Color3.fromRGB(255, 255, 255)
	self._auraData = nil

	self.JUMP_CIRCLES_ENABLED = false
	self.JUMP_CIRCLES_COLOR = Color3.fromRGB(255, 255, 255)
	self._jumpConn = nil

	self.HIT_MARKER_ENABLED = false
	self._hitMarkerGui = nil
	self._hitMarkerLines = {}

	self.NEON_PLAYER_ENABLED = false
	self.NEON_PLAYER_COLOR = Color3.fromRGB(255, 255, 255)
	self._neonConn = nil
	self._neonGlow = nil
	self._origMaterials = {}

	self.tracerPool = {}
	self.MAX_TRACER_POOL = 12

	self.arrows = {}
	self.hitlogContainer = nil
	self.hitlogOrder = 0

	self._bindInputBegan = nil
	self._bindInputEnded = nil

	self.ghostModel = nil
	self.ghostExpireAt = 0
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
	self.ghostParts = {}
	self.ghostLastCFrames = {}
	self.GHOST_SMOOTH_SPEED = 45
	self._hbLast = tick()
	self._ghostDt = 1 / 60

	self.killImage = nil

	self:Initialize()

	return self
end

function VisualsModule:Initialize()
	self.Camera = self.Workspace.CurrentCamera
	self.FX_ROOT = self.ReplicatedStorage:WaitForChild("FXTemplates")
	local playerGui = self.player:FindFirstChildOfClass("PlayerGui")
	if playerGui then
		local sg = playerGui:FindFirstChild("ScreenGui")
		if sg then
			self.HITSOUND_STORAGE = sg:FindFirstChild("storage")
		end
	end

	self.ORIGINAL_EFFECTS = {
		Atmosphere = self:SnapshotFirstEffect("Atmosphere"),
		BloomEffect = self:SnapshotFirstEffect("BloomEffect"),
		ColorCorrectionEffect = self:SnapshotFirstEffect("ColorCorrectionEffect"),
	}

	self:CreateHitlogUI()
	self:CreateOffscreenArrows()
	self:CreateKillImageGUI()
	self:CreateHitMarkerUI()
	self:SetupBacktrackGhost()
	self:SetupKillFXListener()
	self:SetupPlayerEffects()
end

function VisualsModule:CreateHitlogUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "NemesisHitlogs"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.Parent = self.guiParent

	local container = Instance.new("Frame")
	container.Name = "HitlogList"
	container.Active = false
	container.Selectable = false
	container.Size = UDim2.new(0, 300, 0, 200)
	container.Position = UDim2.new(0.5, -150, 0.55, 20)
	container.AnchorPoint = Vector2.new(0, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.Parent = screenGui

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 2)
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.Parent = container

	self.hitlogContainer = container
	self.hitlogOrder = 0
end

function VisualsModule:ShowHitlog(hitType, info)
	if not self.HITLOG_ENABLED then return end
	if not self.hitlogContainer then return end

	self.hitlogOrder += 1

	local text
	if hitType == "Hit" and info then
		text = string.format("HIT  %s  %d DMG  %d studs",
			tostring(info.bodyPart or "Body"),
			math.floor(tonumber(info.damage) or 0),
			math.floor(tonumber(info.distance) or 0))
	elseif hitType == "Miss" and info then
		local reason = info.reason or "unknown"
		if reason == "hitchance_failed" then
			text = string.format("MISS  %d%% (%d)  %d studs",
				tonumber(info.hitchance) or 0, tonumber(info.roll) or 0, tonumber(info.distance) or 0)
		elseif reason == "min_damage" then
			text = string.format("MISS  DMG < %d  %d studs", tonumber(info.minDamage) or 0, tonumber(info.distance) or 0)
		elseif reason == "wall_blocking_target" then
			text = string.format("MISS  WALL  %d studs", tonumber(info.distance) or 0)
		elseif reason == "too_far" then
			text = string.format("MISS  TOO FAR  %d studs", tonumber(info.distance) or 0)
		elseif reason == "no_target" then text = "MISS  NO TARGET"
		elseif reason == "target_dead" then text = "MISS  DEAD"
		elseif reason == "friendly_fire" then text = "MISS  TEAM"
		else text = "MISS"
		end
	elseif hitType == "Hit" then text = "HIT"
	else text = "MISS"
	end

	local isHit = (hitType == "Hit")
	local accentColor = isHit and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(90, 90, 100)

	local row = Instance.new("Frame")
	row.Name = "Hitlog_" .. self.hitlogOrder
	row.Size = UDim2.new(1, 0, 0, 22)
	row.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
	row.BackgroundTransparency = 0.25
	row.BorderSizePixel = 0
	row.LayoutOrder = self.hitlogOrder
	row.Parent = self.hitlogContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = row

	local stripe = Instance.new("Frame")
	stripe.Size = UDim2.new(0, 2, 1, -4)
	stripe.Position = UDim2.new(0, 2, 0, 2)
	stripe.BackgroundColor3 = accentColor
	stripe.BorderSizePixel = 0
	stripe.Parent = row
	local stripeCorner = Instance.new("UICorner")
	stripeCorner.CornerRadius = UDim.new(0, 1)
	stripeCorner.Parent = stripe

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -14, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(220, 220, 225)
	label.TextSize = 11
	label.Font = Enum.Font.Code
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextTransparency = 1
	label.Parent = row

	row.BackgroundTransparency = 1
	stripe.BackgroundTransparency = 1

	local showInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
	self.TweenService:Create(row, showInfo, {BackgroundTransparency = 0.25}):Play()
	self.TweenService:Create(stripe, showInfo, {BackgroundTransparency = 0}):Play()
	self.TweenService:Create(label, showInfo, {TextTransparency = 0}):Play()

	task.spawn(function()
		task.wait(2.5)
		if not row or not row.Parent then return end
		local hideInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
		self.TweenService:Create(row, hideInfo, {BackgroundTransparency = 1}):Play()
		self.TweenService:Create(stripe, hideInfo, {BackgroundTransparency = 1}):Play()
		local t = self.TweenService:Create(label, hideInfo, {TextTransparency = 1})
		t:Play()
		t.Completed:Connect(function()
			if row and row.Parent then row:Destroy() end
		end)
	end)
end

function VisualsModule:PlayHitSound()
	if not self.HITSOUND_ENABLED then return end

	local HITSOUND_MAP = {
		correct = "HitSfx13",
		skeet = "HitSfx",
		orchestra = "HitSfx2",
		bow = "HitSfx3",
		uwu = "HitSfx4",
		tf2 = "HitSfx5",
		b8 = "HitSfx6",
		basketball = "HitSfx7",
		idk = "HitSfx8",
		orb = "HitSfx9",
		balltap = "HitSfx10",
		softbell = "HitSfx11",
		softhit = "HitSfx12",
		soft = "HitSfx14",
		bell2 = "HitSfx15",
		tank1 = "HitSfx16",
		rampage = "HitSfx18",
		headshot = "HitSfx19",
		tank2 = "HitSfx20",
		rust = "HitSfx22",
	}

	local CUSTOM_SOUNDS = {
		bell = "rbxassetid://7112391013",
		["Apple Pay"] = "rbxassetid://82415663525492",
		["Low Honour"] = "rbxassetid://116963486461562",
		["Error"] = "rbxassetid://95509039020568",
		["Fatality"] = "rbxassetid://138378419413244",
		["Bite"] = "rbxassetid://100889026666638",
		["Fart"] = "rbxassetid://84308809034758",
	}

	if CUSTOM_SOUNDS[self.HITSOUND_PRESET] then
		local s = Instance.new("Sound")
		s.SoundId = CUSTOM_SOUNDS[self.HITSOUND_PRESET]
		s.Volume = self.HITSOUND_VOLUME
		s.Parent = self.SoundService
		s:Play()
		self.Debris:AddItem(s, 3)
		return
	end

	if not self.HITSOUND_STORAGE then return end

	local assetName = HITSOUND_MAP[self.HITSOUND_PRESET]
	if not assetName then return end

	local src = self.HITSOUND_STORAGE:FindFirstChild(assetName)
	if not src then return end

	local sound
	if src:IsA("Sound") then
		sound = src:Clone()
	else
		sound = src:FindFirstChildWhichIsA("Sound", true)
		if sound then sound = sound:Clone() end
	end
	if not sound then return end

	sound.Volume = self.HITSOUND_VOLUME
	sound.Parent = self.SoundService
	sound:Play()
	self.Debris:AddItem(sound, math.max(sound.TimeLength + 0.3, 2))
end

function VisualsModule:CreateOffscreenArrows()
	local gui = Instance.new("ScreenGui")
	gui.Name = "ArcPointers"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = self.guiParent
	self.OffscreenGui = gui

	local function isEnemy(plr)
		if self.player.Team and plr.Team then return self.player.Team ~= plr.Team end
		return true
	end

	local function createPointer(plr)
		local c = Instance.new("Frame")
		c.Name = plr.Name .. "_Ptr"
		c.Size = UDim2.fromOffset(44, 52)
		c.AnchorPoint = Vector2.new(0.5, 0.5)
		c.BackgroundTransparency = 1
		c.Visible = false
		c.Parent = gui

		local chevL = Instance.new("Frame")
		chevL.Size = UDim2.fromOffset(4, 18)
		chevL.AnchorPoint = Vector2.new(0.5, 1)
		chevL.Position = UDim2.new(0.5, -4, 0, 22)
		chevL.BackgroundColor3 = self.OFFSCREEN_COLOR
		chevL.Rotation = -30
		chevL.Parent = c
		Instance.new("UICorner", chevL).CornerRadius = UDim.new(0, 2)

		local chevR = Instance.new("Frame")
		chevR.Size = UDim2.fromOffset(4, 18)
		chevR.AnchorPoint = Vector2.new(0.5, 1)
		chevR.Position = UDim2.new(0.5, 4, 0, 22)
		chevR.BackgroundColor3 = self.OFFSCREEN_COLOR
		chevR.Rotation = 30
		chevR.Parent = c
		Instance.new("UICorner", chevR).CornerRadius = UDim.new(0, 2)

		local dot = Instance.new("Frame")
		dot.Size = UDim2.fromOffset(5, 5)
		dot.AnchorPoint = Vector2.new(0.5, 0.5)
		dot.Position = UDim2.new(0.5, 0, 0, 4)
		dot.BackgroundColor3 = self.OFFSCREEN_COLOR
		dot.Parent = c
		Instance.new("UICorner", dot).CornerRadius = UDim.new(1, 0)

		local hpBg = Instance.new("Frame")
		hpBg.Size = UDim2.fromOffset(26, 3)
		hpBg.AnchorPoint = Vector2.new(0.5, 0)
		hpBg.Position = UDim2.new(0.5, 0, 0, 26)
		hpBg.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		hpBg.BackgroundTransparency = 0.4
		hpBg.BorderSizePixel = 0
		hpBg.Parent = c
		Instance.new("UICorner", hpBg).CornerRadius = UDim.new(1, 0)

		local hpFill = Instance.new("Frame")
		hpFill.Size = UDim2.new(1, 0, 1, 0)
		hpFill.BackgroundColor3 = self.OFFSCREEN_COLOR
		hpFill.BorderSizePixel = 0
		hpFill.Parent = hpBg
		Instance.new("UICorner", hpFill).CornerRadius = UDim.new(1, 0)

		local dist = Instance.new("TextLabel")
		dist.Size = UDim2.fromOffset(44, 11)
		dist.AnchorPoint = Vector2.new(0.5, 0)
		dist.Position = UDim2.new(0.5, 0, 0, 31)
		dist.BackgroundTransparency = 1
		dist.TextColor3 = Color3.fromRGB(200, 200, 200)
		dist.Font = Enum.Font.GothamBold
		dist.TextSize = 8
		dist.Text = ""
		dist.TextStrokeTransparency = 0.3
		dist.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		dist.Parent = c

		self.arrows[plr] = {
			container = c,
			chevL = chevL, chevR = chevR, dot = dot,
			hpBg = hpBg, hpFill = hpFill, distLabel = dist,
		}
	end

	local function removePointer(plr)
		if self.arrows[plr] then
			self.arrows[plr].container:Destroy()
			self.arrows[plr] = nil
		end
	end

	self.Players.PlayerAdded:Connect(function(plr)
		if plr ~= self.player and isEnemy(plr) then createPointer(plr) end
	end)
	self.Players.PlayerRemoving:Connect(removePointer)

	for _, p in ipairs(self.Players:GetPlayers()) do
		if p ~= self.player and isEnemy(p) then createPointer(p) end
	end

	local function refresh()
		for plr, d in pairs(self.arrows) do
			if not isEnemy(plr) then d.container:Destroy(); self.arrows[plr] = nil end
		end
		for _, plr in ipairs(self.Players:GetPlayers()) do
			if plr ~= self.player and isEnemy(plr) and not self.arrows[plr] then createPointer(plr) end
		end
	end
	self.player:GetPropertyChangedSignal("Team"):Connect(refresh)

	self.RunService.RenderStepped:Connect(function()
		local t = tick()
		self.Camera = self.Workspace.CurrentCamera or self.Camera
		local cam = self.Camera
		if not cam then return end

		if not self.OFFSCREEN_ENABLED then
			for _, d in pairs(self.arrows) do d.container.Visible = false end
			return
		end

		local camCF = cam.CFrame
		local camPos = camCF.Position
		local vp = cam.ViewportSize
		local cx, cy = vp.X / 2, vp.Y / 2
		local color = self.OFFSCREEN_COLOR

		for plr, d in pairs(self.arrows) do
			if not isEnemy(plr) then d.container.Visible = false; continue end

			local char = plr.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local hum = char and char:FindFirstChildOfClass("Humanoid")

			if not hrp or not hum or hum.Health <= 0 then
				d.container.Visible = false
				continue
			end

			local _, onScreen = cam:WorldToViewportPoint(hrp.Position)
			local sp = cam:WorldToViewportPoint(hrp.Position)

			if onScreen and sp.Z > 0 and sp.X > 0 and sp.X < vp.X and sp.Y > 0 and sp.Y < vp.Y then
				d.container.Visible = false
				continue
			end

			local toP = (hrp.Position - camPos).Unit
			local x = toP:Dot(camCF.RightVector)
			local z = toP:Dot(camCF.LookVector)
			local angle = math.atan2(x, z)
			local rot = math.deg(angle)

			local distance = (hrp.Position - camPos).Magnitude
			local maxR = math.min(360, math.min(vp.X, vp.Y) * 0.4)
			local px = cx + math.sin(angle) * maxR
			local py = cy - math.cos(angle) * maxR

			d.container.Position = UDim2.fromOffset(px, py)
			d.container.Rotation = rot + 180

			local pulse = 0.9 + math.sin(t * 4) * 0.1
			d.chevL.BackgroundColor3 = color
			d.chevL.BackgroundTransparency = 1 - pulse
			d.chevR.BackgroundColor3 = color
			d.chevR.BackgroundTransparency = 1 - pulse
			d.dot.BackgroundColor3 = color
			d.dot.BackgroundTransparency = 1 - pulse

			local hpPct = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
			d.hpFill.Size = UDim2.new(hpPct, 0, 1, 0)
			d.hpFill.BackgroundColor3 = Color3.fromRGB(
				255 * (1 - hpPct), 255 * hpPct, 40
			)
			d.hpBg.Rotation = -(rot + 180)

			d.distLabel.Rotation = -(rot + 180)
			d.distLabel.Text = math.floor(distance) .. "m"

			d.container.Visible = true
		end
	end)
end

function VisualsModule:CreateHelixTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "helix_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit
	local right = dir:Cross(Vector3.new(0, 1, 0))
	if right.Magnitude < 0.01 then right = dir:Cross(Vector3.new(1, 0, 0)) end
	right = right.Unit
	local up = dir:Cross(right).Unit

	local segments = math.clamp(math.floor(distance / 2), 6, 30)
	local radius = 0.8
	local twists = distance / 5

	local strandColors = {
		color,
		Color3.new(
			math.min(color.R * 0.6 + 0.4, 1),
			math.min(color.G * 0.6 + 0.4, 1),
			math.min(color.B * 0.6 + 0.4, 1)
		),
	}

	for strand = 0, 1 do
		local phase = strand * math.pi
		local sc = strandColors[strand + 1]

		local mover = Instance.new("Part")
		mover.Name = "HelixMover_" .. strand
		mover.Anchored = true; mover.CanCollide = false
		mover.CanQuery = false; mover.CanTouch = false; mover.CastShadow = false
		mover.Transparency = 1
		mover.Size = Vector3.new(0.1, 0.1, 0.1)
		mover.Parent = folder

		local a0 = Instance.new("Attachment"); a0.Name = "A0"; a0.Parent = mover
		local a1 = Instance.new("Attachment"); a1.Name = "A1"
		a1.Position = Vector3.new(0.15, 0, 0); a1.Parent = mover

		local trail = Instance.new("Trail")
		trail.Attachment0 = a0; trail.Attachment1 = a1
		trail.Color = ColorSequence.new(sc)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.1),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.5
		trail.FaceCamera = true
		trail.LightEmission = 0.9
		trail.WidthScale = NumberSequence.new(0.12)
		trail.Enabled = true
		trail.Parent = mover

		local pts = {}
		for i = 0, segments do
			local t = i / segments
			local basePos = startPos + dir * (distance * t)
			local angle = t * twists * math.pi * 2 + phase
			local offset = right * math.cos(angle) * radius + up * math.sin(angle) * radius
			table.insert(pts, basePos + offset)
		end

		task.spawn(function()
			local flyTime = math.clamp(distance / 1800, 0.05, 0.25)
			local stepTime = flyTime / #pts
			for _, p in ipairs(pts) do
				if not mover or not mover.Parent then break end
				mover.CFrame = CFrame.new(p)
				task.wait(stepTime)
			end
		end)
	end

	local corePart = Instance.new("Part")
	corePart.Anchored = true; corePart.CanCollide = false
	corePart.CanQuery = false; corePart.CanTouch = false; corePart.CastShadow = false
	corePart.Material = Enum.Material.Neon
	corePart.Color = color
	corePart.Size = Vector3.new(0.04, 0.04, distance)
	corePart.CFrame = CFrame.lookAt((startPos + endPos) / 2, endPos)
	corePart.Transparency = 0.5
	corePart.Parent = folder

	local lifetime = self.TRACER_LIFETIME
	task.delay(lifetime * 0.4, function()
		if corePart and corePart.Parent then
			self.TweenService:Create(corePart,
				TweenInfo.new(lifetime * 0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
			end
		end)
	self.Debris:AddItem(folder, lifetime + 0.8)
end

function VisualsModule:CreatePulseTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "pulse_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit

	local core = Instance.new("Part")
	core.Name = "PulseCore"
	core.Anchored = true; core.CanCollide = false
	core.CanQuery = false; core.CanTouch = false; core.CastShadow = false
	core.Material = Enum.Material.Neon
	core.Color = color
	core.Size = Vector3.new(0.08, 0.08, distance)
	core.CFrame = CFrame.lookAt((startPos + endPos) / 2, endPos)
	core.Transparency = 0.3
	core.Parent = folder

	local NUM_PULSES = math.clamp(math.floor(distance / 5), 3, 12)
	local pulses = {}
	for i = 1, NUM_PULSES do
		local t = i / (NUM_PULSES + 1)
		local pos = startPos + dir * (distance * t)

		local ring = Instance.new("Part")
		ring.Shape = Enum.PartType.Cylinder
		ring.Anchored = true; ring.CanCollide = false
		ring.CanQuery = false; ring.CanTouch = false; ring.CastShadow = false
		ring.Material = Enum.Material.Neon
		ring.Color = color
		ring.Size = Vector3.new(0.04, 0.3, 0.3)
		ring.Transparency = 0.2
		ring.Parent = folder

		local lookCF = CFrame.lookAt(pos, pos + dir)
		ring.CFrame = lookCF * CFrame.Angles(0, 0, math.rad(90))

		table.insert(pulses, {ring = ring, basePos = pos, delay = (1 - t) * 0.3})
	end

	for _, p in ipairs(pulses) do
		task.delay(p.delay, function()
			if p.ring and p.ring.Parent then
				self.TweenService:Create(p.ring,
					TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					{Size = Vector3.new(0.04, 1.8, 1.8), Transparency = 1}
				):Play()
			end
		end)
	end

	local lifetime = self.TRACER_LIFETIME
	task.delay(lifetime * 0.4, function()
		if core and core.Parent then
			self.TweenService:Create(core,
				TweenInfo.new(lifetime * 0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
		end
	end)
	self.Debris:AddItem(folder, lifetime + 0.5)
end

function VisualsModule:CreateLightningTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "lightning_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit
	local segments = math.clamp(math.floor(distance / 3), 4, 16)
	local segLen = distance / segments
	local jitter = 1.2

	local points = {startPos}
	for i = 1, segments - 1 do
		local basePoint = startPos + dir * (segLen * i)
		local right = dir:Cross(Vector3.new(0, 1, 0))
		if right.Magnitude < 0.01 then right = dir:Cross(Vector3.new(1, 0, 0)) end
		right = right.Unit
		local up = dir:Cross(right).Unit
		local offsetR = (math.random() - 0.5) * 2 * jitter
		local offsetU = (math.random() - 0.5) * 2 * jitter
		table.insert(points, basePoint + right * offsetR + up * offsetU)
	end
	table.insert(points, endPos)

	for i = 1, #points - 1 do
		local p1 = points[i]
		local p2 = points[i + 1]
		local mid = (p1 + p2) / 2
		local len = (p2 - p1).Magnitude

		local seg = Instance.new("Part")
		seg.Name = "BoltSeg"
		seg.Anchored = true
		seg.CanCollide = false
		seg.CanQuery = false
		seg.CanTouch = false
		seg.CastShadow = false
		seg.Material = Enum.Material.Neon
		seg.Color = color
		seg.Size = Vector3.new(0.08, 0.08, len)
		seg.CFrame = CFrame.lookAt(mid, p2)
		seg.Transparency = 0.1
		seg.Parent = folder

		if i == 1 or i == #points - 1 then
			local glow = Instance.new("PointLight")
			glow.Color = color
			glow.Range = 6
			glow.Brightness = 1
			glow.Parent = seg
			end
		end

	local lifetime = self.TRACER_LIFETIME * 0.7
	task.delay(lifetime * 0.3, function()
		for _, child in pairs(folder:GetChildren()) do
			if child:IsA("BasePart") then
				self.TweenService:Create(child,
					TweenInfo.new(lifetime * 0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1}
				):Play()
			end
		end
	end)

	self.Debris:AddItem(folder, lifetime + 0.2)
end

function VisualsModule:CreateCometTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "comet_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit

	local head = Instance.new("Part")
	head.Shape = Enum.PartType.Ball
	head.Anchored = true; head.CanCollide = false
	head.CanQuery = false; head.CanTouch = false; head.CastShadow = false
	head.Material = Enum.Material.Neon
	head.Color = color
	head.Size = Vector3.new(0.5, 0.5, 0.5)
	head.CFrame = CFrame.new(startPos)
	head.Transparency = 0
	head.Parent = folder

	local headLight = Instance.new("PointLight")
	headLight.Color = color; headLight.Range = 12; headLight.Brightness = 3
	headLight.Parent = head

	local a0 = Instance.new("Attachment"); a0.Name = "A0"; a0.Parent = head
	local a1 = Instance.new("Attachment"); a1.Name = "A1"
	a1.Position = Vector3.new(0, 0, 0.4); a1.Parent = head

	local trail = Instance.new("Trail")
	trail.Attachment0 = a0; trail.Attachment1 = a1
	trail.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, color),
		ColorSequenceKeypoint.new(1, Color3.new(
			math.min(color.R * 0.3 + 0.7, 1),
			math.min(color.G * 0.3 + 0.7, 1),
			math.min(color.B * 0.3 + 0.7, 1)
		)),
	})
	trail.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.5, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	trail.Lifetime = 0.6
	trail.FaceCamera = true
	trail.LightEmission = 1
	trail.WidthScale = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.3, 0.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	trail.Enabled = true
	trail.Parent = head

	local pe = Instance.new("ParticleEmitter")
	pe.Color = ColorSequence.new(color)
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.25),
		NumberSequenceKeypoint.new(1, 0),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Lifetime = NumberRange.new(0.2, 0.5)
	pe.Speed = NumberRange.new(1, 4)
	pe.SpreadAngle = Vector2.new(120, 120)
	pe.Rate = 60
	pe.LightEmission = 1; pe.LightInfluence = 0
	pe.Drag = 5
	pe.Texture = "rbxassetid://6490035152"
	pe.Parent = head

	local flyTime = math.clamp(distance / 1800, 0.06, 0.3)
	local tween = self.TweenService:Create(head,
		TweenInfo.new(flyTime, Enum.EasingStyle.Linear),
		{CFrame = CFrame.new(endPos)}
	)
	tween:Play()

	tween.Completed:Once(function()
		pe.Rate = 0
		pe:Emit(15)
		self.TweenService:Create(head,
			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{Transparency = 1, Size = Vector3.new(0.05, 0.05, 0.05)}
		):Play()
	end)

	self.Debris:AddItem(folder, self.TRACER_LIFETIME + 1)
end

function VisualsModule:CreateRazorTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "razor_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit

	local core = Instance.new("Part")
	core.Anchored = true; core.CanCollide = false
	core.CanQuery = false; core.CanTouch = false; core.CastShadow = false
	core.Material = Enum.Material.Neon
	core.Color = color
	core.Size = Vector3.new(0.06, 0.06, distance)
	core.CFrame = CFrame.lookAt((startPos + endPos) / 2, endPos)
	core.Transparency = 0
	core.Parent = folder

	local right = dir:Cross(Vector3.new(0, 1, 0))
	if right.Magnitude < 0.01 then right = dir:Cross(Vector3.new(1, 0, 0)) end
	right = right.Unit
	local up = dir:Cross(right).Unit

	local echoCount = 4
	for i = 1, echoCount do
		local offset = right * (math.random() - 0.5) * 0.6 + up * (math.random() - 0.5) * 0.6
		local echoStart = startPos + offset
		local echoEnd = endPos + offset

		local echo = Instance.new("Part")
		echo.Anchored = true; echo.CanCollide = false
		echo.CanQuery = false; echo.CanTouch = false; echo.CastShadow = false
		echo.Material = Enum.Material.Neon
		echo.Color = color
		echo.Size = Vector3.new(0.03, 0.03, distance)
		echo.CFrame = CFrame.lookAt((echoStart + echoEnd) / 2, echoEnd)
		echo.Transparency = 0.4 + i * 0.1
		echo.Parent = folder

		task.delay(i * 0.03, function()
			if echo and echo.Parent then
				self.TweenService:Create(echo,
					TweenInfo.new(0.3 + i * 0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1, Size = Vector3.new(0.01, 0.01, distance * 0.5)}
				):Play()
			end
		end)
	end

	local bladeCount = math.clamp(math.floor(distance / 6), 2, 8)
	for i = 1, bladeCount do
		local t = i / (bladeCount + 1)
		local pos = startPos + dir * distance * t

		local blade = Instance.new("Part")
		blade.Anchored = true; blade.CanCollide = false
		blade.CanQuery = false; blade.CanTouch = false; blade.CastShadow = false
		blade.Material = Enum.Material.Neon
		blade.Color = color
		blade.Size = Vector3.new(1.2, 0.04, 0.04)
		blade.CFrame = CFrame.lookAt(pos, pos + dir) * CFrame.Angles(0, 0, math.rad(45 * i))
		blade.Transparency = 0.2
		blade.Parent = folder

		task.delay(0.15, function()
			if blade and blade.Parent then
				self.TweenService:Create(blade,
					TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1, Size = Vector3.new(2, 0.02, 0.02)}
				):Play()
			end
		end)
	end

	local lifetime = self.TRACER_LIFETIME
	task.delay(lifetime * 0.3, function()
		if core and core.Parent then
			self.TweenService:Create(core,
				TweenInfo.new(lifetime * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
		end
	end)

	self.Debris:AddItem(folder, lifetime + 0.3)
end

function VisualsModule:CreateTracer(startPos, endPos)
	if not self.TRACER_ENABLED then return end

	if self.TRACER_STYLE == "Lightning" then
		self:CreateLightningTracer(startPos, endPos)
		return
	elseif self.TRACER_STYLE == "Helix" then
		self:CreateHelixTracer(startPos, endPos)
		return
	elseif self.TRACER_STYLE == "Pulse" then
		self:CreatePulseTracer(startPos, endPos)
		return
	elseif self.TRACER_STYLE == "Comet" then
		self:CreateCometTracer(startPos, endPos)
		return
	elseif self.TRACER_STYLE == "Razor" then
		self:CreateRazorTracer(startPos, endPos)
		return
	end

	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	if self.WALLBANG_ENABLED then
		local direction = (endPos - startPos)
		local dirUnit = direction.Unit

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local char = self.player.Character
		if char then
			params.FilterDescendantsInstances = { char }
		end

		local rayForward = self.Workspace:Raycast(startPos, dirUnit * distance, params)
		if rayForward then
			local rayBackward = self.Workspace:Raycast(endPos, -dirUnit * distance, params)
			if rayBackward then
				local penetrationDepth = (rayForward.Position - rayBackward.Position).Magnitude
				if penetrationDepth > 0.5 and penetrationDepth < (distance * 0.95) then
					task.spawn(function()
						self:CreateWallbangMarker(rayForward.Position, self.WALLBANG_ENTRY_COLOR)
						self:CreateWallbangMarker(rayBackward.Position, self.WALLBANG_EXIT_COLOR)
					end)
				end
			end
		end
	end

	local tracerObj = table.remove(self.tracerPool)
	if not tracerObj then
		local folder = Instance.new("Folder")
		folder.Name = "tracer_fx"

		local mover = Instance.new("Part")
		mover.Name = "Mover"
		mover.Anchored = true
		mover.Transparency = 1
		mover.CanCollide = false
		mover.CanQuery = false
		mover.CanTouch = false
		mover.Size = Vector3.new(0.05, 0.05, 0.05)
		mover.Parent = folder

		local a0 = Instance.new("Attachment")
		a0.Name = "A0"
		a0.Parent = mover

		local a1 = Instance.new("Attachment")
		a1.Name = "A1"
		a1.Parent = mover

		local trail = Instance.new("Trail")
		trail.Name = "Trace"
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Enabled = false
		trail.FaceCamera = true
		trail.Brightness = self.TRACER_BRIGHTNESS
		trail.LightEmission = self.TRACER_LIGHTEMISSION
		trail.LightInfluence = self.TRACER_LIGHTINFLUENCE
		trail.TextureMode = Enum.TextureMode.Stretch
		trail.Texture = "rbxassetid://93746968407218"
		trail.TextureLength = 3
		trail.Transparency = self.TRACER_TRANSPARENCY
		trail.Parent = mover

		tracerObj = { folder = folder, mover = mover, a0 = a0, a1 = a1, trail = trail }
	end

	local w = math.clamp(self.TRACER_WIDTH, 0.02, 0.25)

	tracerObj.trail.Color = ColorSequence.new(self.TRACER_COLOR)
	tracerObj.trail.Lifetime = self.TRACER_LIFETIME
	tracerObj.trail.WidthScale = NumberSequence.new(w)
	tracerObj.trail.Transparency = self.TRACER_TRANSPARENCY
	tracerObj.trail.Brightness = self.TRACER_BRIGHTNESS
	tracerObj.trail.LightEmission = self.TRACER_LIGHTEMISSION
	tracerObj.trail.LightInfluence = self.TRACER_LIGHTINFLUENCE

	local dir = (endPos - startPos)
	local unit = dir.Unit

	tracerObj.folder.Parent = self.Workspace
	tracerObj.mover.CFrame = CFrame.lookAt(startPos, startPos + unit)
	tracerObj.a0.Position = Vector3.new(0, 0, 0)
	tracerObj.a1.Position = Vector3.new(0, 0, -self.TRACER_TAIL)
	tracerObj.trail.Enabled = true

	local flyTime = math.clamp(distance / 2200, 0.06, 0.22)
	local tween = self.TweenService:Create(tracerObj.mover, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
		CFrame = CFrame.lookAt(endPos, endPos + unit),
	})
	tween:Play()

	tween.Completed:Once(function()
		task.delay(tracerObj.trail.Lifetime + 0.05, function()
			if not tracerObj or not tracerObj.folder then return end
			tracerObj.trail.Enabled = false
			tracerObj.folder.Parent = nil
			if #self.tracerPool < self.MAX_TRACER_POOL then
				table.insert(self.tracerPool, tracerObj)
			else
				tracerObj.folder:Destroy()
			end
		end)
	end)
end

function VisualsModule:CreateWallbangMarker(pos, color)
	local part = Instance.new("Part")
	part.Name = "WallbangMarker"
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CastShadow = false
	part.Material = Enum.Material.ForceField
	part.Color = color
	part.Size = self.WALLBANG_MARKER_SIZE
	part.CFrame = CFrame.new(pos)
	part.Parent = self.Workspace

	part.Transparency = 0
	local tIn = self.TweenService:Create(part, TweenInfo.new(0.3), { Transparency = 0 })
	tIn:Play()

	self.Debris:AddItem(part, self.WALLBANG_LIFETIME)

	task.delay(self.WALLBANG_LIFETIME - 0.5, function()
		if part.Parent then
			self.TweenService:Create(part, TweenInfo.new(0.5), { Transparency = 1, Size = Vector3.new(0, 0, 0) }):Play()
		end
	end)
end

function VisualsModule:CreateKillImageGUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisKillImage"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.DisplayOrder = 9999
	gui.Parent = self.guiParent

	local img = Instance.new("ImageLabel")
	img.Name = "Effect"
	img.Size = UDim2.fromScale(1, 1)
	img.Position = UDim2.fromScale(0.5, 0.5)
	img.AnchorPoint = Vector2.new(0.5, 0.5)
	img.BackgroundTransparency = 1
	img.Image = "http://www.roblox.com/asset/?id=3124804643"
	img.ImageTransparency = 1
	img.ScaleType = Enum.ScaleType.Stretch
	img.ZIndex = 999
	img.Parent = gui

	self.killImage = img
end

function VisualsModule:PlayKillImage()
	if not self.KILLIMAGE_ENABLED then return end
	if not self.killImage then return end

	self.killImage.ImageColor3 = self.KILLIMAGE_COLOR
	self.killImage.ImageTransparency = 1

	local tIn = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_IN, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ ImageTransparency = 1 - self.KILLIMAGE_MAX_ALPHA }
	)

	local tOut = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{ ImageTransparency = 1 }
	)

	tIn:Play()
	tIn.Completed:Wait()
	task.wait(self.KILLIMAGE_HOLD)
	tOut:Play()
end

function VisualsModule:CreateHitMarkerUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisHitMarker"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.DisplayOrder = 100
	gui.Parent = self.guiParent

	local holder = Instance.new("Frame")
	holder.Name = "HitMarker"
	holder.Size = UDim2.new(0, 40, 0, 40)
	holder.AnchorPoint = Vector2.new(0.5, 0.5)
	holder.Position = UDim2.new(0.5, 0, 0.5, 0)
	holder.BackgroundTransparency = 1
	holder.Visible = false
	holder.Parent = gui

	self._hitMarkerLines = {}

	local function makeLine(rot)
		local line = Instance.new("Frame")
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.Position = UDim2.new(0.5, 0, 0.5, 0)
		line.Size = UDim2.new(0, 2, 0, 24)
		line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		line.BorderSizePixel = 0
		line.Rotation = rot
		line.BackgroundTransparency = 1
		line.Parent = holder

		local hole = Instance.new("Frame")
		hole.AnchorPoint = Vector2.new(0.5, 0.5)
		hole.Position = UDim2.new(0.5, 0, 0.5, 0)
		hole.Size = UDim2.new(0, 4, 0, 8)
		hole.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		hole.BackgroundTransparency = 1
		hole.BorderSizePixel = 0
		hole.Parent = line

		return line
	end

	table.insert(self._hitMarkerLines, makeLine(45))
	table.insert(self._hitMarkerLines, makeLine(-45))

	self._hitMarkerGui = holder
end

function VisualsModule:FlashHitMarker()
	if not self.HIT_MARKER_ENABLED then return end
	if not self._hitMarkerGui then return end

	self._hitMarkerGui.Visible = true
	self._hitMarkerGui.Size = UDim2.new(0, 50, 0, 50)
	for _, l in ipairs(self._hitMarkerLines) do
		l.BackgroundTransparency = 0
	end

	local shrink = self.TweenService:Create(self._hitMarkerGui,
		TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 40, 0, 40)}
	)
	shrink:Play()

	task.spawn(function()
		task.wait(0.15)
		if not self._hitMarkerGui then return end
		local fadeInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		for _, l in ipairs(self._hitMarkerLines) do
			self.TweenService:Create(l, fadeInfo, {BackgroundTransparency = 1}):Play()
		end
		task.wait(0.2)
		if self._hitMarkerGui then self._hitMarkerGui.Visible = false end
	end)
end

function VisualsModule:SetupPlayerEffects()
	self.player.CharacterAdded:Connect(function(char)
		task.wait(0.5)
		if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
		if self.WINGS_ENABLED then self:SpawnWings() end
		if self.AURA_ENABLED then self:SpawnAura() end
		if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
	end)

	if self.player.Character then
		task.defer(function()
			if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
			if self.WINGS_ENABLED then self:SpawnWings() end
			if self.AURA_ENABLED then self:SpawnAura() end
			if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
		end)
	end
end

function VisualsModule:SpawnChinaHat()
	self:DestroyChinaHat()
	local char = self.player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end

	local parts = {}
	local SLICES = 8
	local RADIUS = 1.6
	local HEIGHT = 1.0

	for i = 1, SLICES do
		local angle = (i - 1) * (math.pi * 2 / SLICES)
		local nextAngle = i * (math.pi * 2 / SLICES)
		local midAngle = (angle + nextAngle) / 2

		local wedge = Instance.new("WedgePart")
		wedge.Name = "ArcHatSlice"
		wedge.Material = Enum.Material.SmoothPlastic
		wedge.Color = self.CHINA_HAT_COLOR
		wedge.Anchored = false
		wedge.CanCollide = false
		wedge.CanTouch = false
		wedge.CanQuery = false
		wedge.CastShadow = false
		wedge.Massless = true
		wedge.Transparency = 0.05

		local sliceWidth = 2 * RADIUS * math.sin(math.pi / SLICES)
		wedge.Size = Vector3.new(sliceWidth, HEIGHT, RADIUS)

		local cf = head.CFrame
			* CFrame.new(0, 0.6, 0)
			* CFrame.Angles(0, midAngle, 0)
			* CFrame.new(0, 0, -RADIUS / 2)
			* CFrame.Angles(0, 0, 0)

		wedge.CFrame = cf
		wedge.Parent = char

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = head
		weld.Part1 = wedge
		weld.Parent = wedge

		table.insert(parts, wedge)
	end

	local brim = Instance.new("Part")
	brim.Name = "ArcHatBrim"
	brim.Shape = Enum.PartType.Cylinder
	brim.Size = Vector3.new(0.06, RADIUS * 2.3, RADIUS * 2.3)
	brim.Material = Enum.Material.SmoothPlastic
	brim.Color = self.CHINA_HAT_COLOR
	brim.Anchored = false
	brim.CanCollide = false
	brim.CanTouch = false
	brim.CanQuery = false
	brim.CastShadow = false
	brim.Massless = true
	brim.Transparency = 0.05
	brim.CFrame = head.CFrame * CFrame.new(0, 0.58, 0) * CFrame.Angles(0, 0, math.rad(90))
	brim.Parent = char

	local brimWeld = Instance.new("WeldConstraint")
	brimWeld.Part0 = head
	brimWeld.Part1 = brim
	brimWeld.Parent = brim

	table.insert(parts, brim)
	self._chinaHatParts = parts
end

function VisualsModule:DestroyChinaHat()
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p:Destroy() end
	end
	self._chinaHatParts = {}
end

function VisualsModule:SpawnWings()
	self:DestroyWings()
	local char = self.player.Character
	if not char then return end
	local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
	if not torso then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcWings"
	folder.Parent = char

	local allParts = {}
	local allTrails = {}

	local mainFeathers = {
		{side = -1, x = 0.4, y = 1.0, z = 0.45, ry = 6,  flapMult = 0.6, w = 0.9, h = 1.5, d = 0.14},
		{side = -1, x = 0.9, y = 0.85, z = 0.5, ry = 10, flapMult = 0.75, w = 1.1, h = 2.1, d = 0.12},
		{side = -1, x = 1.5, y = 0.6, z = 0.55, ry = 16, flapMult = 0.9, w = 1.2, h = 2.7, d = 0.10},
		{side = -1, x = 2.1, y = 0.3, z = 0.6, ry = 22, flapMult = 1.05, w = 1.15, h = 3.1, d = 0.09},
		{side = -1, x = 2.7, y = -0.1, z = 0.65, ry = 28, flapMult = 1.2, w = 1.0, h = 3.0, d = 0.08},
		{side = -1, x = 3.2, y = -0.5, z = 0.7, ry = 33, flapMult = 1.35, w = 0.85, h = 2.5, d = 0.07},
		{side = -1, x = 3.6, y = -0.9, z = 0.75, ry = 37, flapMult = 1.5, w = 0.6, h = 1.8, d = 0.06},
	}

	local secondaryFeathers = {
		{side = -1, x = 0.6, y = 0.4, z = 0.55, ry = 12, flapMult = 0.8, w = 0.5, h = 1.2, d = 0.08},
		{side = -1, x = 1.2, y = 0.15, z = 0.6, ry = 18, flapMult = 0.95, w = 0.6, h = 1.6, d = 0.07},
		{side = -1, x = 1.8, y = -0.1, z = 0.65, ry = 24, flapMult = 1.1, w = 0.55, h = 1.8, d = 0.06},
		{side = -1, x = 2.3, y = -0.35, z = 0.7, ry = 29, flapMult = 1.25, w = 0.45, h = 1.5, d = 0.06},
	}

	local featherDefs = {}
	for _, def in ipairs(mainFeathers) do
		table.insert(featherDefs, def)
		local mirror = {}; for k, v in pairs(def) do mirror[k] = v end
		mirror.side = 1
		table.insert(featherDefs, mirror)
	end
	for _, def in ipairs(secondaryFeathers) do
		table.insert(featherDefs, def)
		local mirror = {}; for k, v in pairs(def) do mirror[k] = v end
		mirror.side = 1
		table.insert(featherDefs, mirror)
	end

	local feathers = {}
	for _, def in ipairs(featherDefs) do
		local feather = Instance.new("Part")
		feather.Name = "ArcFeather"
		feather.Size = Vector3.new(def.d, def.h, def.w)
		feather.Material = Enum.Material.Neon
		feather.Color = self.WINGS_COLOR
		feather.Anchored = true; feather.CanCollide = false
		feather.CanTouch = false; feather.CanQuery = false
		feather.CastShadow = false
		feather.Transparency = 0.12
		feather.Parent = folder
		table.insert(allParts, feather)

		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, def.h * 0.4, 0)
		a0.Parent = feather
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -def.h * 0.4, 0)
		a1.Parent = feather
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0; trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.WINGS_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.5),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.4
		trail.FaceCamera = true
		trail.LightEmission = 0.8
		trail.Parent = feather
		table.insert(allTrails, trail)

		table.insert(feathers, {part = feather, def = def})
	end

	local tipL = Instance.new("Part")
	tipL.Name = "ArcWingTipL"
	tipL.Shape = Enum.PartType.Ball
	tipL.Size = Vector3.new(0.3, 0.3, 0.3)
	tipL.Material = Enum.Material.Neon; tipL.Color = self.WINGS_COLOR
	tipL.Anchored = true; tipL.CanCollide = false; tipL.CanQuery = false
	tipL.CastShadow = false; tipL.Transparency = 0.3
	tipL.Parent = folder
	table.insert(allParts, tipL)

	local tipR = tipL:Clone()
	tipR.Name = "ArcWingTipR"
	tipR.Parent = folder
	table.insert(allParts, tipR)

	local glowPart = Instance.new("Part")
	glowPart.Name = "ArcWingGlow"
	glowPart.Size = Vector3.new(0.5, 0.5, 0.5)
	glowPart.Transparency = 1; glowPart.Anchored = true
	glowPart.CanCollide = false; glowPart.CanQuery = false
	glowPart.Parent = folder

	local glow = Instance.new("PointLight")
	glow.Color = self.WINGS_COLOR
	glow.Range = 10; glow.Brightness = 0.8
	glow.Parent = glowPart

	local particles = Instance.new("ParticleEmitter")
	particles.Color = ColorSequence.new(self.WINGS_COLOR)
	particles.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(1, 0),
	})
	particles.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.25),
		NumberSequenceKeypoint.new(1, 1),
	})
	particles.Lifetime = NumberRange.new(0.4, 1.0)
	particles.Rate = 20
	particles.Speed = NumberRange.new(0.5, 2.5)
	particles.SpreadAngle = Vector2.new(180, 180)
	particles.LightEmission = 0.9; particles.LightInfluence = 0
	particles.Texture = "rbxassetid://6490035152"
	particles.Parent = glowPart

	table.insert(allParts, glowPart)

	local conn = self.RunService.Heartbeat:Connect(function()
		if not torso or not torso.Parent then
			self:DestroyWings()
			return
		end
		local t = tick()
		local torsoCF = torso.CFrame
		local flapBase = math.sin(t * 2.8) * 14
		local flapSec = math.sin(t * 2.8 + 0.4) * 10

		for _, f in ipairs(feathers) do
			local d = f.def
			local side = d.side
			local isSecondary = d.h < 2
			local flap = isSecondary and flapSec or flapBase
			local flapAngle = flap * d.flapMult
			local breathe = math.sin(t * 1.8 + d.x * 0.7) * 2.5
			local flutter = math.sin(t * 6 + d.x * 3.5) * 1.0 * d.flapMult
			local wave = math.sin(t * 3.2 + d.x * 2) * 1.2

			local localCF = CFrame.new(side * d.x, d.y, d.z)
				* CFrame.Angles(
					math.rad(breathe + flutter + wave),
					math.rad(side * d.ry),
					math.rad(side * (flapAngle - 12))
				)

			f.part.CFrame = torsoCF * localCF
		end

		local tipFlap = flapBase * 1.5
		tipL.CFrame = torsoCF * CFrame.new(-3.7, -1.0, 0.75)
			* CFrame.Angles(0, 0, math.rad(-1 * (tipFlap - 12)))
		tipR.CFrame = torsoCF * CFrame.new(3.7, -1.0, 0.75)
			* CFrame.Angles(0, 0, math.rad(1 * (tipFlap - 12)))

		glow.Brightness = 0.6 + math.sin(t * 2) * 0.3

		glowPart.CFrame = torsoCF * CFrame.new(0, 0.3, 0.5)
	end)

	self._wingData = {
		folder = folder,
		allParts = allParts,
		allTrails = allTrails,
		glow = glow,
		particles = particles,
		conn = conn,
	}
end

function VisualsModule:DestroyWings()
	if self._wingData then
		if self._wingData.conn then
			self._wingData.conn:Disconnect()
		end
		if self._wingData.folder and self._wingData.folder.Parent then
			self._wingData.folder:Destroy()
		end
		self._wingData = nil
	end
end

function VisualsModule:SpawnAura()
	self:DestroyAura()
	local char = self.player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcAura"
	folder.Parent = char

	local NUM_MAIN = 5
	local NUM_INNER = 3
	local RADIUS_MAIN = 3.2
	local RADIUS_INNER = 1.8

	local function makeOrb(name, size, transp)
		local orb = Instance.new("Part")
		orb.Name = name
		orb.Shape = Enum.PartType.Ball
		orb.Size = Vector3.new(size, size, size)
		orb.Material = Enum.Material.Neon
		orb.Color = self.AURA_COLOR
		orb.Anchored = true
		orb.CanCollide = false
		orb.CanTouch = false
		orb.CanQuery = false
		orb.CastShadow = false
		orb.Transparency = transp

		local light = Instance.new("PointLight")
		light.Color = self.AURA_COLOR
		light.Range = 4
		light.Brightness = 0.4
		light.Parent = orb

		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, 0.1, 0)
		a0.Parent = orb
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -0.1, 0)
		a1.Parent = orb
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.AURA_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.4),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.5
		trail.FaceCamera = true
		trail.LightEmission = 0.7
		trail.Parent = orb

		orb.Parent = folder
		return orb
	end

	local mainOrbs = {}
	for i = 1, NUM_MAIN do
		table.insert(mainOrbs, makeOrb("AuraOrb_" .. i, 0.35, 0.25))
	end

	local innerOrbs = {}
	for i = 1, NUM_INNER do
		table.insert(innerOrbs, makeOrb("AuraInner_" .. i, 0.2, 0.4))
	end

	local rising = Instance.new("ParticleEmitter")
	rising.Name = "AuraRise"
	rising.Color = ColorSequence.new(self.AURA_COLOR)
	rising.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(0.5, 0.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	rising.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.6, 0.6),
		NumberSequenceKeypoint.new(1, 1),
	})
	rising.Lifetime = NumberRange.new(0.8, 1.5)
	rising.Rate = 18
	rising.Speed = NumberRange.new(1.5, 3.5)
	rising.SpreadAngle = Vector2.new(20, 20)
	rising.RotSpeed = NumberRange.new(-60, 60)
	rising.LightEmission = 0.8
	rising.LightInfluence = 0.1
	rising.Texture = "rbxassetid://6490035152"
	rising.EmissionDirection = Enum.NormalId.Top
	rising.Parent = hrp

	self._auraData = {
		folder = folder,
		mainOrbs = mainOrbs,
		innerOrbs = innerOrbs,
		emitter = rising,
		conn = nil,
	}

	self._auraData.conn = self.RunService.Heartbeat:Connect(function()
		if not hrp or not hrp.Parent then
			self:DestroyAura()
			return
		end
		local t = tick()
		local basePos = hrp.Position

		for idx, orb in ipairs(mainOrbs) do
			if orb and orb.Parent then
				local angle = (t * 1.8) + (idx - 1) * (math.pi * 2 / NUM_MAIN)
				local yOff = math.sin(t * 2.5 + idx * 1.3) * 0.7
				local pulse = 0.35 + math.sin(t * 4 + idx) * 0.08
				orb.Size = Vector3.new(pulse, pulse, pulse)
				local x = math.cos(angle) * RADIUS_MAIN
				local z = math.sin(angle) * RADIUS_MAIN
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

		for idx, orb in ipairs(innerOrbs) do
			if orb and orb.Parent then
				local angle = -(t * 2.8) + (idx - 1) * (math.pi * 2 / NUM_INNER)
				local yOff = math.sin(t * 3.0 + idx * 2.1) * 0.4 + 1.0
				local x = math.cos(angle) * RADIUS_INNER
				local z = math.sin(angle) * RADIUS_INNER
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

	end)
end

function VisualsModule:DestroyAura()
	if self._auraData then
		if self._auraData.conn then
			self._auraData.conn:Disconnect()
		end
		if self._auraData.folder and self._auraData.folder.Parent then
			self._auraData.folder:Destroy()
		end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter:Destroy()
		end
		self._auraData = nil
	end
end

function VisualsModule:ConnectJumpCircles()
	self:DisconnectJumpCircles()

	local wasGrounded = true
	local cooldown = 0

	local function hookChar(char)
		if self._jumpHumConn then
			pcall(function() self._jumpHumConn:Disconnect() end)
		end
		local hum = char:WaitForChild("Humanoid", 10)
		if not hum then return end
		wasGrounded = true; cooldown = 0

		self._jumpHumConn = hum.StateChanged:Connect(function(_, newState)
			if not self.JUMP_CIRCLES_ENABLED then return end
			if newState == Enum.HumanoidStateType.Jumping then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp and tick() > cooldown then
					cooldown = tick() + 0.3
					self:SpawnJumpCircle(hrp.Position - Vector3.new(0, 3, 0))
				end
			end
		end)

		if self._jumpPollConn then pcall(function() self._jumpPollConn:Disconnect() end) end
		self._jumpPollConn = self.RunService.Heartbeat:Connect(function()
			if not self.JUMP_CIRCLES_ENABLED then return end
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			local vel = hrp.AssemblyLinearVelocity
			local grounded = math.abs(vel.Y) < 1
			if wasGrounded and not grounded and vel.Y > 3 then
				if tick() > cooldown then
					cooldown = tick() + 0.3
					self:SpawnJumpCircle(hrp.Position - Vector3.new(0, 3, 0))
				end
			end
			wasGrounded = grounded
		end)
	end

	if self.player.Character then
		task.spawn(function() hookChar(self.player.Character) end)
	end
	self._jumpCharConn = self.player.CharacterAdded:Connect(function(c)
		task.wait(0.3)
		hookChar(c)
	end)
end

function VisualsModule:DisconnectJumpCircles()
	if self._jumpHumConn then
		pcall(function() self._jumpHumConn:Disconnect() end)
		self._jumpHumConn = nil
	end
	if self._jumpPollConn then
		pcall(function() self._jumpPollConn:Disconnect() end)
		self._jumpPollConn = nil
	end
	if self._jumpCharConn then
		pcall(function() self._jumpCharConn:Disconnect() end)
		self._jumpCharConn = nil
	end
end

function VisualsModule:SpawnJumpCircle(position)
	local color = self.JUMP_CIRCLES_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcJumpCircle"
	folder.Parent = self.Workspace

	local ring = Instance.new("Part")
	ring.Shape = Enum.PartType.Cylinder
	ring.Anchored = true
	ring.CanCollide = false
	ring.CanTouch = false
	ring.CanQuery = false
	ring.CastShadow = false
	ring.Material = Enum.Material.Neon
	ring.Color = color
	ring.Size = Vector3.new(0.06, 0.8, 0.8)
	ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	ring.Transparency = 0.2
	ring.Parent = folder

	local inner = Instance.new("Part")
	inner.Shape = Enum.PartType.Cylinder
	inner.Anchored = true
	inner.CanCollide = false
	inner.CanTouch = false
	inner.CanQuery = false
	inner.CastShadow = false
	inner.Material = Enum.Material.Neon
	inner.Color = color
	inner.Size = Vector3.new(0.04, 0.4, 0.4)
	inner.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	inner.Transparency = 0
	inner.Parent = folder

	local spark = Instance.new("Part")
	spark.Anchored = true
	spark.CanCollide = false
	spark.CanQuery = false
	spark.Transparency = 1
	spark.Size = Vector3.new(1, 1, 1)
	spark.CFrame = CFrame.new(position)
	spark.Parent = folder

	local emitter = Instance.new("ParticleEmitter")
	emitter.Color = ColorSequence.new(color)
	emitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.15),
		NumberSequenceKeypoint.new(1, 0),
	})
	emitter.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	emitter.Lifetime = NumberRange.new(0.3, 0.6)
	emitter.Rate = 0
	emitter.Speed = NumberRange.new(3, 8)
	emitter.SpreadAngle = Vector2.new(360, 30)
	emitter.LightEmission = 1
	emitter.LightInfluence = 0
	emitter.Texture = "rbxassetid://6490035152"
	emitter.Parent = spark
	emitter:Emit(20)

	self.TweenService:Create(ring,
		TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.06, 7, 7), Transparency = 1}
	):Play()
	self.TweenService:Create(inner,
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.04, 4, 4), Transparency = 1}
	):Play()

	self.Debris:AddItem(folder, 1)
end

function VisualsModule:PlaySparkleFX(position)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcSparkleFX"
	folder.Parent = self.Workspace

	local base = Instance.new("Part")
	base.Anchored = true; base.CanCollide = false; base.CanQuery = false
	base.CanTouch = false; base.Transparency = 1
	base.Size = Vector3.new(1, 1, 1)
	base.CFrame = CFrame.new(position)
	base.Parent = folder

	local burst = Instance.new("ParticleEmitter")
	burst.Color = ColorSequence.new(col)
	burst.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.6),
		NumberSequenceKeypoint.new(0.4, 0.35),
		NumberSequenceKeypoint.new(1, 0),
	})
	burst.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.5, 0.15),
		NumberSequenceKeypoint.new(1, 1),
	})
	burst.Lifetime = NumberRange.new(0.4, 1.0)
	burst.Speed = NumberRange.new(12, 28)
	burst.SpreadAngle = Vector2.new(360, 360)
	burst.Rate = 0
	burst.RotSpeed = NumberRange.new(-250, 250)
	burst.Rotation = NumberRange.new(-180, 180)
	burst.LightEmission = 1; burst.LightInfluence = 0
	burst.Texture = "rbxassetid://6490035152"
	burst.Parent = base
	burst:Emit(55)

	local shimmer = Instance.new("ParticleEmitter")
	shimmer.Color = ColorSequence.new(col)
	shimmer.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.18),
		NumberSequenceKeypoint.new(1, 0),
	})
	shimmer.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	shimmer.Lifetime = NumberRange.new(0.7, 1.4)
	shimmer.Speed = NumberRange.new(2, 7)
	shimmer.SpreadAngle = Vector2.new(360, 360)
	shimmer.Rate = 0
	shimmer.LightEmission = 1; shimmer.LightInfluence = 0
	shimmer.Texture = "rbxassetid://6490035152"
	shimmer.EmissionDirection = Enum.NormalId.Top
	shimmer.Parent = base
	shimmer:Emit(25)

	local flash = Instance.new("Part")
	flash.Shape = Enum.PartType.Ball
	flash.Anchored = true; flash.CanCollide = false
	flash.CanQuery = false; flash.CastShadow = false
	flash.Material = Enum.Material.Neon
	flash.Color = col
	flash.Size = Vector3.new(1.2, 1.2, 1.2)
	flash.CFrame = CFrame.new(position)
	flash.Transparency = 0.2
	flash.Parent = folder

	self.TweenService:Create(flash,
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(6, 6, 6), Transparency = 1}
	):Play()

	local light = Instance.new("PointLight")
	light.Color = col
	light.Range = 22
	light.Brightness = 3
	light.Parent = base
	self.TweenService:Create(light, TweenInfo.new(0.7), {Range = 0, Brightness = 0}):Play()

	self.Debris:AddItem(folder, 2)
end

function VisualsModule:PlayRingFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcRingFX"
	folder.Parent = self.Workspace

	local rings = {}
	local ringConfigs = {
		{tiltX = 0,  tiltZ = 0,  speed = 4.5, startSize = 2.5},
		{tiltX = 65, tiltZ = 25, speed = 3.5, startSize = 3.0},
		{tiltX = 25, tiltZ = 75, speed = 5.5, startSize = 2.0},
		{tiltX = 45, tiltZ = 45, speed = 2.8, startSize = 3.5},
	}

	for i, cfg in ipairs(ringConfigs) do
		local ring = Instance.new("Part")
		ring.Name = "Ring_" .. i
		ring.Shape = Enum.PartType.Cylinder
		ring.Anchored = true; ring.CanCollide = false
		ring.CanQuery = false; ring.CanTouch = false; ring.CastShadow = false
		ring.Material = Enum.Material.Neon
		ring.Color = col
		ring.Size = Vector3.new(0.05, cfg.startSize, cfg.startSize)
		ring.Transparency = 0.1
		ring.Parent = folder
		table.insert(rings, {part = ring, cfg = cfg})
	end

	local light = Instance.new("PointLight")
	light.Color = col
	light.Range = 26
	light.Brightness = 3
	light.Parent = rings[1].part

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(1.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	local startT = tick()
	local conn
	conn = self.RunService.Heartbeat:Connect(function()
		local elapsed = tick() - startT
		if elapsed > 2.5 then conn:Disconnect(); return end

		for _, r in ipairs(rings) do
			local ring = r.part
			local cfg = r.cfg
			if ring and ring.Parent then
				local rot = elapsed * cfg.speed
				local sz = cfg.startSize + elapsed * 2
				ring.Size = Vector3.new(0.05, sz, sz)
				ring.CFrame = CFrame.new(position)
					* CFrame.Angles(math.rad(cfg.tiltX), rot, math.rad(cfg.tiltZ))
					* CFrame.Angles(0, 0, math.rad(90))
				ring.Transparency = 0.1 + math.clamp((elapsed - 1.2) / 1.3, 0, 0.9)
			end
		end
	end)

	self.TweenService:Create(light, TweenInfo.new(2.2), {Range = 0, Brightness = 0}):Play()
	self.Debris:AddItem(folder, 3.5)
end

function VisualsModule:PlayBeamFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcBeamFX"
	folder.Parent = self.Workspace

	local H = 65
	local midPos = position + Vector3.new(0, H / 2, 0)

	local beam = Instance.new("Part")
	beam.Name = "BeamOuter"
	beam.Anchored = true; beam.CanCollide = false
	beam.CanQuery = false; beam.CanTouch = false; beam.CastShadow = false
	beam.Material = Enum.Material.Neon
	beam.Color = col
	beam.Size = Vector3.new(3, H, 3)
	beam.CFrame = CFrame.new(midPos)
	beam.Transparency = 0.25
	beam.Parent = folder

	local inner = Instance.new("Part")
	inner.Name = "BeamInner"
	inner.Anchored = true; inner.CanCollide = false
	inner.CanQuery = false; inner.CanTouch = false; inner.CastShadow = false
	inner.Material = Enum.Material.Neon
	inner.Color = Color3.new(
		math.min(col.R * 1.3, 1),
		math.min(col.G * 1.3, 1),
		math.min(col.B * 1.3, 1)
	)
	inner.Size = Vector3.new(1, H, 1)
	inner.CFrame = CFrame.new(midPos)
	inner.Transparency = 0
	inner.Parent = folder

	local light = Instance.new("PointLight")
	light.Color = col
	light.Range = 40
	light.Brightness = 4.5
	light.Parent = inner

	local impactRing = Instance.new("Part")
	impactRing.Shape = Enum.PartType.Cylinder
	impactRing.Anchored = true; impactRing.CanCollide = false
	impactRing.CanQuery = false; impactRing.CanTouch = false; impactRing.CastShadow = false
	impactRing.Material = Enum.Material.Neon
	impactRing.Color = col
	impactRing.Size = Vector3.new(0.06, 2, 2)
	impactRing.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	impactRing.Transparency = 0.15
	impactRing.Parent = folder

	self.TweenService:Create(impactRing,
		TweenInfo.new(0.45, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.06, 16, 16), Transparency = 1}
	):Play()

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	task.delay(0.4, function()
		if beam and beam.Parent then
			self.TweenService:Create(beam,
				TweenInfo.new(0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Size = Vector3.new(0.15, H, 0.15), Transparency = 1}
			):Play()
		end
		if inner and inner.Parent then
			self.TweenService:Create(inner,
				TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
		end
		if light then
			self.TweenService:Create(light, TweenInfo.new(0.7), {Range = 0, Brightness = 0}):Play()
		end
	end)

	self.Debris:AddItem(folder, 2)
end

function VisualsModule:PlayInfernoFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcInfernoFX"
	folder.Parent = self.Workspace

	local baseP = Instance.new("Part")
	baseP.Anchored = true; baseP.CanCollide = false
	baseP.CanQuery = false; baseP.CanTouch = false
	baseP.Transparency = 1
	baseP.Size = Vector3.new(1, 1, 1)
	baseP.CFrame = CFrame.new(position)
	baseP.Parent = folder

	local darkCol = Color3.new(col.R * 0.6, col.G * 0.6, col.B * 0.6)

	local fire = Instance.new("ParticleEmitter")
	fire.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, col),
		ColorSequenceKeypoint.new(0.5, Color3.new(
			math.min(col.R * 1.2, 1), math.min(col.G * 1.2, 1), math.min(col.B * 1.2, 1)
		)),
		ColorSequenceKeypoint.new(1, darkCol),
	})
	fire.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(0.3, 2.5),
		NumberSequenceKeypoint.new(0.7, 1.8),
		NumberSequenceKeypoint.new(1, 0),
	})
	fire.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(0.4, 0.25),
		NumberSequenceKeypoint.new(1, 1),
	})
	fire.Lifetime = NumberRange.new(0.3, 0.8)
	fire.Rate = 70
	fire.Speed = NumberRange.new(6, 14)
	fire.SpreadAngle = Vector2.new(25, 25)
	fire.RotSpeed = NumberRange.new(-120, 120)
	fire.Rotation = NumberRange.new(-180, 180)
	fire.LightEmission = 1; fire.LightInfluence = 0
	fire.Texture = "rbxassetid://6490035152"
	fire.EmissionDirection = Enum.NormalId.Top
	fire.Parent = baseP

	local embers = Instance.new("ParticleEmitter")
	embers.Color = ColorSequence.new(col)
	embers.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.12),
		NumberSequenceKeypoint.new(1, 0),
	})
	embers.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	embers.Lifetime = NumberRange.new(0.5, 1.4)
	embers.Rate = 30
	embers.Speed = NumberRange.new(6, 14)
	embers.SpreadAngle = Vector2.new(50, 50)
	embers.LightEmission = 1; embers.LightInfluence = 0
	embers.Texture = "rbxassetid://6490035152"
	embers.EmissionDirection = Enum.NormalId.Top
	embers.Parent = baseP

	local light = Instance.new("PointLight")
	light.Color = col
	light.Range = 28
	light.Brightness = 3.5
	light.Parent = baseP

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(1.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	task.delay(0.8, function()
		if fire then fire.Rate = 0 end
		if embers then embers.Rate = 0 end
		if light and light.Parent then
			self.TweenService:Create(light, TweenInfo.new(0.8), {Range = 0, Brightness = 0}):Play()
		end
	end)

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:PlayVortexFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcVortexFX"
	folder.Parent = self.Workspace

	local base = Instance.new("Part")
	base.Anchored = true; base.CanCollide = false; base.CanQuery = false
	base.CanTouch = false; base.Transparency = 1
	base.Size = Vector3.new(1, 1, 1)
	base.CFrame = CFrame.new(position)
	base.Parent = folder

	local NUM_SPIRAL = 12
	local spiralParts = {}
	for i = 1, NUM_SPIRAL do
		local p = Instance.new("Part")
		p.Shape = Enum.PartType.Ball
		p.Anchored = true; p.CanCollide = false
		p.CanQuery = false; p.CanTouch = false; p.CastShadow = false
		p.Material = Enum.Material.Neon
		p.Color = col
		p.Size = Vector3.new(0.5, 0.5, 0.5)
		p.Transparency = 0.2
		p.CFrame = CFrame.new(position)
		p.Parent = folder

		local a0 = Instance.new("Attachment"); a0.Parent = p
		local a1 = Instance.new("Attachment"); a1.Position = Vector3.new(0, 0, 0.3); a1.Parent = p
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0; trail.Attachment1 = a1
		trail.Color = ColorSequence.new(col)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.3),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.4
		trail.FaceCamera = true
		trail.LightEmission = 0.8
		trail.Parent = p

		table.insert(spiralParts, p)
	end

	local light = Instance.new("PointLight")
	light.Color = col; light.Range = 24; light.Brightness = 3
	light.Parent = base

	local startT = tick()
	local conn
	conn = self.RunService.Heartbeat:Connect(function()
		local elapsed = tick() - startT
		if elapsed > 2.2 then conn:Disconnect(); return end

		local progress = math.clamp(elapsed / 2.2, 0, 1)
		local radius = 3 + elapsed * 1.5

		for i, p in ipairs(spiralParts) do
			if p and p.Parent then
				local baseAngle = (i / NUM_SPIRAL) * math.pi * 2
				local spin = elapsed * 6
				local angle = baseAngle + spin
				local h = (i / NUM_SPIRAL) * 6 * (1 - progress * 0.5)
				local r = radius * (1 - progress * 0.6)

				p.CFrame = CFrame.new(
					position.X + math.cos(angle) * r,
					position.Y + h - 1,
					position.Z + math.sin(angle) * r
				)
				p.Size = Vector3.new(0.5 - progress * 0.3, 0.5 - progress * 0.3, 0.5 - progress * 0.3)
				p.Transparency = 0.2 + progress * 0.8
			end
		end
	end)

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(1.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	self.TweenService:Create(light, TweenInfo.new(2.0), {Range = 0, Brightness = 0}):Play()
	self.Debris:AddItem(folder, 3)
end

function VisualsModule:PlayShatterFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcShatterFX"
	folder.Parent = self.Workspace

	local NUM_SHARDS = 18
	for i = 1, NUM_SHARDS do
		local shard = Instance.new("Part")
		shard.Anchored = true; shard.CanCollide = false
		shard.CanQuery = false; shard.CanTouch = false; shard.CastShadow = false
		shard.Material = Enum.Material.Neon
		shard.Color = col
		local sx = math.random(3, 8) * 0.1
		local sy = math.random(5, 14) * 0.1
		local sz = math.random(1, 4) * 0.1
		shard.Size = Vector3.new(sx, sy, sz)
		shard.Transparency = 0.1
		shard.CFrame = CFrame.new(position)
			* CFrame.Angles(math.random() * math.pi * 2, math.random() * math.pi * 2, math.random() * math.pi * 2)
		shard.Parent = folder

		local dir = (CFrame.Angles(
			math.random() * math.pi * 2,
			math.random() * math.pi * 2, 0
		).LookVector) * (8 + math.random() * 10)

		local targetCF = CFrame.new(position + dir)
			* CFrame.Angles(math.random() * math.pi, math.random() * math.pi, 0)

		self.TweenService:Create(shard,
			TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{CFrame = targetCF}
		):Play()

		task.delay(0.5, function()
			if shard and shard.Parent then
				self.TweenService:Create(shard,
					TweenInfo.new(1.0, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1, Size = Vector3.new(0.05, 0.05, 0.05)}
				):Play()
			end
		end)
	end

	local flash = Instance.new("Part")
	flash.Shape = Enum.PartType.Ball
	flash.Anchored = true; flash.CanCollide = false
	flash.CanQuery = false; flash.CastShadow = false
	flash.Material = Enum.Material.Neon
	flash.Color = col
	flash.Size = Vector3.new(2, 2, 2)
	flash.CFrame = CFrame.new(position)
	flash.Transparency = 0
	flash.Parent = folder

	self.TweenService:Create(flash,
		TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(5, 5, 5), Transparency = 1}
	):Play()

	local light = Instance.new("PointLight")
	light.Color = col; light.Range = 30; light.Brightness = 4
	light.Parent = flash
	self.TweenService:Create(light, TweenInfo.new(0.8), {Range = 0, Brightness = 0}):Play()

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon; part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:PlayNovaFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcNovaFX"
	folder.Parent = self.Workspace

	local shell = Instance.new("Part")
	shell.Shape = Enum.PartType.Ball
	shell.Anchored = true; shell.CanCollide = false
	shell.CanQuery = false; shell.CanTouch = false; shell.CastShadow = false
	shell.Material = Enum.Material.Neon
	shell.Color = col
	shell.Size = Vector3.new(0.5, 0.5, 0.5)
	shell.CFrame = CFrame.new(position)
	shell.Transparency = 0
	shell.Parent = folder

	self.TweenService:Create(shell,
		TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(18, 18, 18), Transparency = 0.95}
	):Play()

	local hRing = Instance.new("Part")
	hRing.Shape = Enum.PartType.Cylinder
	hRing.Anchored = true; hRing.CanCollide = false
	hRing.CanQuery = false; hRing.CastShadow = false
	hRing.Material = Enum.Material.Neon
	hRing.Color = col
	hRing.Size = Vector3.new(0.08, 1, 1)
	hRing.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	hRing.Transparency = 0.1
	hRing.Parent = folder

	self.TweenService:Create(hRing,
		TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.08, 22, 22), Transparency = 1}
	):Play()

	local base = Instance.new("Part")
	base.Anchored = true; base.CanCollide = false; base.CanQuery = false
	base.CanTouch = false; base.Transparency = 1
	base.Size = Vector3.new(1, 1, 1)
	base.CFrame = CFrame.new(position)
	base.Parent = folder

	local pe = Instance.new("ParticleEmitter")
	pe.Color = ColorSequence.new(col)
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.5, 0.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Lifetime = NumberRange.new(0.5, 1.0)
	pe.Speed = NumberRange.new(15, 30)
	pe.SpreadAngle = Vector2.new(360, 360)
	pe.Rate = 0
	pe.LightEmission = 1; pe.LightInfluence = 0
	pe.Texture = "rbxassetid://6490035152"
	pe.Parent = base
	pe:Emit(40)

	local light = Instance.new("PointLight")
	light.Color = col; light.Range = 45; light.Brightness = 5
	light.Parent = base
	self.TweenService:Create(light, TweenInfo.new(1.0), {Range = 0, Brightness = 0}):Play()

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon; part.Color = col
					self.TweenService:Create(part,
						TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:PlayCascadeFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcCascadeFX"
	folder.Parent = self.Workspace

	local pillarCount = 8
	local baseRadius = 4

	for i = 1, pillarCount do
		local angle = (i / pillarCount) * math.pi * 2
		local offset = Vector3.new(math.cos(angle) * baseRadius, 0, math.sin(angle) * baseRadius)
		local pillarPos = position + offset

		local pillar = Instance.new("Part")
		pillar.Anchored = true; pillar.CanCollide = false
		pillar.CanQuery = false; pillar.CanTouch = false; pillar.CastShadow = false
		pillar.Material = Enum.Material.Neon
		pillar.Color = col
		pillar.Size = Vector3.new(0.3, 0.1, 0.3)
		pillar.CFrame = CFrame.new(pillarPos.X, pillarPos.Y - 2, pillarPos.Z)
		pillar.Transparency = 0.2
		pillar.Shape = Enum.PartType.Block
		pillar.Parent = folder

		local delayTime = i * 0.06
		task.delay(delayTime, function()
			if not pillar or not pillar.Parent then return end
			self.TweenService:Create(pillar,
				TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
				{Size = Vector3.new(0.3, 14 + math.random() * 6, 0.3), CFrame = CFrame.new(pillarPos.X, pillarPos.Y + 5, pillarPos.Z)}
			):Play()

			task.delay(0.6, function()
				if not pillar or not pillar.Parent then return end
				self.TweenService:Create(pillar,
					TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1, Size = Vector3.new(0.05, 20, 0.05)}
				):Play()
			end)
		end)

		local glow = Instance.new("PointLight")
		glow.Color = col; glow.Range = 8; glow.Brightness = 3
		glow.Parent = pillar
	end

	local flash = Instance.new("Part")
	flash.Shape = Enum.PartType.Cylinder
	flash.Anchored = true; flash.CanCollide = false
	flash.CanQuery = false; flash.CastShadow = false
	flash.Material = Enum.Material.Neon
	flash.Color = col
	flash.Size = Vector3.new(0.08, 0.5, 0.5)
	flash.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	flash.Transparency = 0
	flash.Parent = folder

	self.TweenService:Create(flash,
		TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.08, 20, 20), Transparency = 1}
	):Play()

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:PlayPlasmaFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcPlasmaFX"
	folder.Parent = self.Workspace

	local core = Instance.new("Part")
	core.Shape = Enum.PartType.Ball
	core.Anchored = true; core.CanCollide = false
	core.CanQuery = false; core.CanTouch = false; core.CastShadow = false
	core.Material = Enum.Material.Neon
	core.Color = col
	core.Size = Vector3.new(1, 1, 1)
	core.CFrame = CFrame.new(position)
	core.Transparency = 0
	core.Parent = folder

	local coreLight = Instance.new("PointLight")
	coreLight.Color = col; coreLight.Range = 35; coreLight.Brightness = 6
	coreLight.Parent = core

	self.TweenService:Create(core,
		TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
		{Size = Vector3.new(5, 5, 5)}
	):Play()

	task.delay(0.3, function()
		if not core or not core.Parent then return end
		self.TweenService:Create(core,
			TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
			{Size = Vector3.new(0.5, 0.5, 0.5), Transparency = 1}
		):Play()
	end)

	local boltCount = 6
	for i = 1, boltCount do
		task.delay(0.05 * i, function()
			local angle1 = math.random() * math.pi * 2
			local angle2 = math.random() * math.pi - math.pi / 2
			local endDir = Vector3.new(
				math.cos(angle1) * math.cos(angle2),
				math.sin(angle2),
				math.sin(angle1) * math.cos(angle2)
			)
			local boltLen = 8 + math.random() * 6

			local segs = 5
			local prevPt = position
			for s = 1, segs do
				local t = s / segs
				local idealPt = position + endDir * boltLen * t
				local jitter = Vector3.new(
					(math.random() - 0.5) * 2,
					(math.random() - 0.5) * 2,
					(math.random() - 0.5) * 2
				)
				local pt = (s == segs) and (position + endDir * boltLen) or (idealPt + jitter)

				local seg = Instance.new("Part")
				seg.Anchored = true; seg.CanCollide = false
				seg.CanQuery = false; seg.CanTouch = false; seg.CastShadow = false
				seg.Material = Enum.Material.Neon
				seg.Color = col
				local segLen = (pt - prevPt).Magnitude
				seg.Size = Vector3.new(0.12, 0.12, segLen)
				seg.CFrame = CFrame.lookAt((prevPt + pt) / 2, pt)
				seg.Transparency = 0.1
				seg.Parent = folder

				self.TweenService:Create(seg,
					TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1, Size = Vector3.new(0.02, 0.02, segLen)}
				):Play()

				prevPt = pt
			end

			local tip = Instance.new("Part")
			tip.Shape = Enum.PartType.Ball
			tip.Anchored = true; tip.CanCollide = false
			tip.CanQuery = false; tip.CanTouch = false; tip.CastShadow = false
			tip.Material = Enum.Material.Neon
			tip.Color = col
			tip.Size = Vector3.new(0.8, 0.8, 0.8)
			tip.CFrame = CFrame.new(position + endDir * boltLen)
			tip.Transparency = 0
			tip.Parent = folder

			self.TweenService:Create(tip,
				TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1, Size = Vector3.new(0.1, 0.1, 0.1)}
			):Play()
		end)
	end

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:PlayReaperFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcReaperFX"
	folder.Parent = self.Workspace

	local slashCount = 3
	for i = 1, slashCount do
		local slash = Instance.new("Part")
		slash.Anchored = true; slash.CanCollide = false
		slash.CanQuery = false; slash.CanTouch = false; slash.CastShadow = false
		slash.Material = Enum.Material.Neon
		slash.Color = col
		slash.Size = Vector3.new(8, 0.08, 0.5)
		local rotAngle = (i - 1) * 60
		slash.CFrame = CFrame.new(position) * CFrame.Angles(
			math.rad(rotAngle + math.random(-15, 15)),
			math.rad(math.random(-30, 30)),
			math.rad(math.random(-20, 20))
		)
		slash.Transparency = 0.8
		slash.Parent = folder

		local targetSize = Vector3.new(12, 0.06, 0.15)
		self.TweenService:Create(slash,
			TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{Transparency = 0, Size = targetSize}
		):Play()

		task.delay(0.15, function()
			if not slash or not slash.Parent then return end
			self.TweenService:Create(slash,
				TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1, Size = Vector3.new(14, 0.02, 0.02)}
			):Play()
		end)
	end

	local base = Instance.new("Part")
	base.Anchored = true; base.CanCollide = false; base.CanQuery = false
	base.CanTouch = false; base.Transparency = 1
	base.Size = Vector3.new(1, 1, 1)
	base.CFrame = CFrame.new(position)
	base.Parent = folder

	local pe = Instance.new("ParticleEmitter")
	pe.Color = ColorSequence.new(col)
	pe.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.4, 0.15),
		NumberSequenceKeypoint.new(1, 0),
	})
	pe.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	pe.Lifetime = NumberRange.new(0.4, 0.8)
	pe.Speed = NumberRange.new(4, 12)
	pe.SpreadAngle = Vector2.new(360, 360)
	pe.Rate = 0
	pe.LightEmission = 1; pe.LightInfluence = 0
	pe.Texture = "rbxassetid://6490035152"
	pe.Drag = 3
	pe.Parent = base
	pe:Emit(25)

	local darkCore = Instance.new("Part")
	darkCore.Shape = Enum.PartType.Ball
	darkCore.Anchored = true; darkCore.CanCollide = false
	darkCore.CanQuery = false; darkCore.CanTouch = false; darkCore.CastShadow = false
	darkCore.Material = Enum.Material.Neon
	darkCore.Color = Color3.new(0, 0, 0)
	darkCore.Size = Vector3.new(2, 2, 2)
	darkCore.CFrame = CFrame.new(position)
	darkCore.Transparency = 0.5
	darkCore.Parent = folder

	self.TweenService:Create(darkCore,
		TweenInfo.new(0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.2, 0.2, 0.2), Transparency = 1}
	):Play()

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					local stroke = Instance.new("SelectionBox")
					stroke.Adornee = part; stroke.Color3 = col
					stroke.LineThickness = 0.03; stroke.SurfaceTransparency = 0.9
					stroke.Parent = part
					self.TweenService:Create(stroke,
						TweenInfo.new(0.8), {SurfaceTransparency = 1}
					):Play()
					self.Debris:AddItem(stroke, 1)
				end)
			end
		end
	end

	self.Debris:AddItem(folder, 2.0)
end

function VisualsModule:PlayPixelFX(position, victimChar)
	local col = self.KILLFX_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcPixelFX"
	folder.Parent = self.Workspace

	local cubeCount = 24
	for i = 1, cubeCount do
		local cube = Instance.new("Part")
		cube.Shape = Enum.PartType.Block
		cube.Anchored = true; cube.CanCollide = false
		cube.CanQuery = false; cube.CanTouch = false; cube.CastShadow = false
		cube.Material = Enum.Material.Neon

		local shade = 0.6 + math.random() * 0.4
		cube.Color = Color3.new(col.R * shade, col.G * shade, col.B * shade)

		local s = 0.25 + math.random() * 0.5
		cube.Size = Vector3.new(s, s, s)

		local spread = 1.5
		cube.CFrame = CFrame.new(
			position.X + (math.random() - 0.5) * spread,
			position.Y + (math.random() - 0.5) * spread,
			position.Z + (math.random() - 0.5) * spread
		) * CFrame.Angles(math.random() * math.pi, math.random() * math.pi, math.random() * math.pi)
		cube.Transparency = 0
		cube.Parent = folder

		local targetDir = Vector3.new(
			(math.random() - 0.5) * 2,
			(math.random() - 0.5) * 2,
			(math.random() - 0.5) * 2
		).Unit

		local dist = 4 + math.random() * 8
		local targetPos = position + targetDir * dist

		task.delay(math.random() * 0.15, function()
			if not cube or not cube.Parent then return end
			self.TweenService:Create(cube,
				TweenInfo.new(0.5 + math.random() * 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
				{
					CFrame = CFrame.new(targetPos) * CFrame.Angles(math.random() * math.pi * 2, math.random() * math.pi * 2, 0),
					Transparency = 1,
					Size = Vector3.new(0.05, 0.05, 0.05),
				}
			):Play()
		end)
	end

	local flash = Instance.new("Part")
	flash.Shape = Enum.PartType.Ball
	flash.Anchored = true; flash.CanCollide = false
	flash.CanQuery = false; flash.CanTouch = false; flash.CastShadow = false
	flash.Material = Enum.Material.Neon
	flash.Color = col
	flash.Size = Vector3.new(2, 2, 2)
	flash.CFrame = CFrame.new(position)
	flash.Transparency = 0.3
	flash.Parent = folder

	self.TweenService:Create(flash,
		TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(5, 5, 5), Transparency = 1}
	):Play()

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:FixFxInstance(fx, cf)
	if fx:IsA("Model") then
		for _, d in ipairs(fx:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
				d.CanQuery = false
				d.CanTouch = false
			end
		end
		fx:PivotTo(cf)
	elseif fx:IsA("BasePart") then
		fx.Anchored = true
		fx.CanCollide = false
		fx.CanQuery = false
		fx.CanTouch = false
		fx.CFrame = cf
	end
end

function VisualsModule:RecolorParticles(root, color)
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Color = ColorSequence.new(color)
		end
	end
end

function VisualsModule:PlayImpactFX(position)
	local template = self.FX_ROOT:FindFirstChild("ImpactFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(0.15, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:PlayCustomFX(position)
	local template = self.FX_ROOT:FindFirstChild("CustomFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	local light = fx:FindFirstChild("PointLight") or fx:FindFirstChildWhichIsA("PointLight", true)
	if light then
		light.Color = self.KILLFX_LIGHT_COLOR
		light.Range = 0
		light.Brightness = self.KILLFX_LIGHT_BRIGHTNESS
		light.Enabled = true

		local tIn = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = self.KILLFX_LIGHT_RANGE })
		local tOut = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = 0 })

		tIn:Play()
		tIn.Completed:Once(function()
			tOut:Play()
		end)
	end

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(self.KILLFX_CUSTOM_DURATION, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:SetupKillFXListener()
	local InfEvent = self.ReplicatedStorage:WaitForChild("inf", 10)
	if InfEvent then
		InfEvent.OnClientEvent:Connect(function(killedPlayerName)
			if not self.KILLFX_ENABLED then return end

			local killedPlayer = self.Players:FindFirstChild(killedPlayerName)
			if not killedPlayer then return end

			local char = killedPlayer.Character
			if not char then return end

			local head = char:FindFirstChild("Head")
			if not head then return end

			local pos = head.Position
			if self.KILLFX_TYPE == "Sparkle" then
				self:PlaySparkleFX(pos)
			elseif self.KILLFX_TYPE == "Ring" then
				self:PlayRingFX(pos, char)
			elseif self.KILLFX_TYPE == "Beam" then
				self:PlayBeamFX(pos, char)
			elseif self.KILLFX_TYPE == "Inferno" then
				self:PlayInfernoFX(pos, char)
			elseif self.KILLFX_TYPE == "Vortex" then
				self:PlayVortexFX(pos, char)
			elseif self.KILLFX_TYPE == "Shatter" then
				self:PlayShatterFX(pos, char)
			elseif self.KILLFX_TYPE == "Nova" then
				self:PlayNovaFX(pos, char)
			elseif self.KILLFX_TYPE == "Cascade" then
				self:PlayCascadeFX(pos, char)
			elseif self.KILLFX_TYPE == "Plasma" then
				self:PlayPlasmaFX(pos, char)
			elseif self.KILLFX_TYPE == "Reaper" then
				self:PlayReaperFX(pos, char)
			elseif self.KILLFX_TYPE == "Pixel" then
				self:PlayPixelFX(pos, char)
			end

		end)
	end

	task.spawn(function()
		local htl = self.ReplicatedStorage:WaitForChild("htl", 10)
		if not htl then return end

		htl.OnClientEvent:Connect(function(hitType, info)
			if hitType == "Hit" then
				self:PlayHitSound()
				self:FlashHitMarker()
			end

			if hitType == "Hit" and info and self.KILLIMAGE_ENABLED then
				local dmg = info.damage or 0
				if dmg > 99 then
					self:PlayKillImage()
				end
			end

			if self.HITLOG_ENABLED then
				self:ShowHitlog(hitType, info)
			end
		end)
	end)
end

function VisualsModule:IsFakeLagEnabledFallback()
	if typeof(self.IsFakeLagEnabled) == "function" then
		local ok, v = pcall(self.IsFakeLagEnabled)
		if ok then return v == true end
	end
	if _G.ConfigSystem and _G.ConfigSystem.settings then
		return _G.ConfigSystem.settings["FakeLag"] == true
	end
	return false
end

function VisualsModule:SetupBacktrackGhost()
	local backtrackRemote = self.ReplicatedStorage:WaitForChild("btl")
	local lastSend = 0

	local ghostsFolder = self.Workspace:FindFirstChild("BacktrackGhosts") or Instance.new("Folder", self.Workspace)
	ghostsFolder.Name = "BacktrackGhosts"
	self._ghostsFolder = ghostsFolder

	self.RunService.Heartbeat:Connect(function()
		local now = tick()
		local dt = now - self._hbLast
		self._hbLast = now
		self._ghostDt = dt

		if self.ghostModel and now > self.ghostExpireAt then
			self:ClearBacktrackGhost()
		end

		if self.BACKTRACK_GHOST_ENABLED and self.player.Character then
			local hrp = self.player.Character:FindFirstChild("HumanoidRootPart")
			if hrp then
				if now - lastSend > 0.05 then
					lastSend = now
					backtrackRemote:FireServer(self:IsFakeLagEnabledFallback())
				end
			end
		end
	end)

	backtrackRemote.OnClientEvent:Connect(function(cframe, isFakelag, ping)
		if not self.BACKTRACK_GHOST_ENABLED then return end

		if not isFakelag and ping then
			local char = self.player.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local velocity = hrp.AssemblyLinearVelocity
					local pingOffset = velocity * (ping * 0.5)
					cframe = hrp.CFrame - pingOffset
				end
			end
		end

		self:UpdateBacktrackGhostPose(cframe, isFakelag)
	end)

	self.player.CharacterAdded:Connect(function()
		self:ClearBacktrackGhost()
	end)

	self.player.CharacterRemoving:Connect(function()
		self:ClearBacktrackGhost()
	end)
end

function VisualsModule:ClearBacktrackGhost()
	if self.ghostModel then
		self.ghostModel:Destroy()
		self.ghostModel = nil
		table.clear(self.ghostParts)
		table.clear(self.ghostLastCFrames)
	end
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
end

function VisualsModule:CreateBacktrackGhost()
	local srcChar = self.player.Character
	if not srcChar then return nil end

	local root = srcChar:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	srcChar.Archivable = true
	local ghost = srcChar:Clone()
	srcChar.Archivable = false
	if not ghost then return nil end

	ghost.Name = self.player.Name .. "_BacktrackGhost"

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("Sound")
			or v:IsA("BillboardGui") or v:IsA("Humanoid")
			or v:IsA("AlignPosition") or v:IsA("AlignOrientation")
			or v:IsA("BodyMover") or v:IsA("BodyGyro") or v:IsA("BodyVelocity")
			or v:IsA("BodyPosition") or v:IsA("BodyForce") or v:IsA("VectorForce")
			or v:IsA("LineForce") or v:IsA("Animator") then
			v:Destroy()
		end
	end

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Motor6D") or v:IsA("Weld") or v:IsA("WeldConstraint")
			or v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint")
			or v:IsA("Constraint") or v:IsA("JointInstance") then
			v:Destroy()
		end
	end

	local hasParts = false
	local col = self.BACKTRACK_GHOST_COLOR
	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			hasParts = true
			v.Anchored = true
			v.CanCollide = false
			v.CanTouch = false
			v.CanQuery = false
			v.Massless = true
			v.Material = Enum.Material.Neon
			v.Transparency = self.GHOST_BASE_TRANSPARENCY
			v.Color = col
			v.CastShadow = false

			if v.Name == "Head" then
				local face = v:FindFirstChild("face")
				if face then face:Destroy() end
			end

			local selBox = Instance.new("SelectionBox")
			selBox.Adornee = v
			selBox.Color3 = col
			selBox.LineThickness = 0.02
			selBox.Transparency = 0.5
			selBox.SurfaceTransparency = 0.85
			selBox.SurfaceColor3 = col
			selBox.Parent = v
		end
	end

	if not hasParts then
		ghost:Destroy()
		return nil
	end

	table.clear(self.ghostParts)
	for _, v in ipairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			table.insert(self.ghostParts, v)
		end
	end

	local rootP = ghost:FindFirstChild("HumanoidRootPart")
	if rootP then
		local glow = Instance.new("PointLight")
		glow.Color = col
		glow.Range = 6
		glow.Brightness = 0.4
		glow.Parent = rootP
	end

	ghost.Parent = self._ghostsFolder
	return ghost
end

function VisualsModule:UpdateBacktrackGhostPose(targetCFrame, isFakelag)
	if not self.BACKTRACK_GHOST_ENABLED then return end

	local srcChar = self.player.Character
	if not srcChar then return end

	local humanoid = srcChar:FindFirstChild("Humanoid")
	if humanoid and humanoid.Health <= 0 then
		self:ClearBacktrackGhost()
		return
	end

	if (not self.ghostModel) or (self.sourceCharacter ~= srcChar) or (self.lastFakeLagState ~= isFakelag) or (not self.ghostModel.Parent) then
		self:ClearBacktrackGhost()
		self.ghostModel = self:CreateBacktrackGhost()
		if self.ghostModel then
			self.sourceCharacter = srcChar
			self.lastFakeLagState = isFakelag
		else
			return
		end
	end

	local srcRoot = srcChar:FindFirstChild("HumanoidRootPart")
	if not srcRoot then return end

	local currentRootCFrame = srcRoot.CFrame
	local offset = targetCFrame * currentRootCFrame:Inverse()

	local dt = tonumber(self._ghostDt) or (1 / 60)
	local alpha = math.clamp(self.GHOST_SMOOTH_SPEED * dt, 0, 1)

for _, ghostPart in ipairs(self.ghostParts) do
	local srcPart = srcChar:FindFirstChild(ghostPart.Name, true)
	if srcPart then
		local targetCF = offset * srcPart.CFrame
		local lastCF = self.ghostLastCFrames[ghostPart] or ghostPart.CFrame
		local newCF = lastCF:Lerp(targetCF, alpha)
		ghostPart.CFrame = newCF
		self.ghostLastCFrames[ghostPart] = newCF

		local dist = (newCF.Position - srcPart.Position).Magnitude

		if dist < self.GHOST_FADE_RADIUS then
			local k = math.clamp(1 - (dist / self.GHOST_FADE_RADIUS), 0, 1)
			k = k ^ self.GHOST_FADE_POWER
			ghostPart.Transparency = math.clamp(
				self.GHOST_BASE_TRANSPARENCY + k * (1 - self.GHOST_BASE_TRANSPARENCY),
				0,
				1
			)
		else
			ghostPart.Transparency = self.GHOST_BASE_TRANSPARENCY
		end
	end
end

	self.ghostExpireAt = tick() + self.BACKTRACK_GHOST_DURATION
end

function VisualsModule:SnapshotFirstEffect(className)
	local inst = self.Lighting:FindFirstChildOfClass(className)
	if not inst then return nil end
	local c = inst:Clone()
	c.Name = "NemesisOriginal_" .. className
	return c
end

function VisualsModule:WipeClass(className)
	for _, inst in ipairs(self.Lighting:GetDescendants()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
	for _, inst in ipairs(self.Lighting:GetChildren()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
end

function VisualsModule:ApplySingleEffect(className, enabled, applyFn)
	if enabled then
		self:WipeClass(className)
		local fx = Instance.new(className)
		fx.Name = "Nemesis_" .. className
		fx.Parent = self.Lighting
		applyFn(fx)
	else
		self:WipeClass(className)
		local original = self.ORIGINAL_EFFECTS[className]
		if original then
			original:Clone().Parent = self.Lighting
		end
	end
end

function VisualsModule:UpdateAtmosphere()
	self:ApplySingleEffect("Atmosphere", self.ATMOSPHERE_ENABLED, function(atmosphere)
		atmosphere.Density = self.ATMOSPHERE_DENSITY
		atmosphere.Offset = self.ATMOSPHERE_OFFSET
		atmosphere.Color = self.ATMOSPHERE_COLOR
		atmosphere.Decay = self.ATMOSPHERE_DECAY
		atmosphere.Glare = self.ATMOSPHERE_GLARE
		atmosphere.Haze = self.ATMOSPHERE_HAZE
	end)
end

function VisualsModule:SetAtmosphereEnabled(value)
	self.ATMOSPHERE_ENABLED = value
	self:UpdateAtmosphere()
end

function VisualsModule:SetAtmosphereDensity(value)
	self.ATMOSPHERE_DENSITY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereOffset(value)
	self.ATMOSPHERE_OFFSET = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereColor(value)
	self.ATMOSPHERE_COLOR = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereDecay(value)
	self.ATMOSPHERE_DECAY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereGlare(value)
	self.ATMOSPHERE_GLARE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereHaze(value)
	self.ATMOSPHERE_HAZE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:UpdateBloom()
	self:ApplySingleEffect("BloomEffect", self.BLOOM_ENABLED, function(bloom)
		bloom.Enabled = true
		bloom.Intensity = self.BLOOM_INTENSITY
		bloom.Size = self.BLOOM_SIZE
		bloom.Threshold = self.BLOOM_THRESHOLD
	end)
end

function VisualsModule:SetBloomEnabled(value)
	self.BLOOM_ENABLED = value
	self:UpdateBloom()
end

function VisualsModule:SetBloomIntensity(value)
	self.BLOOM_INTENSITY = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomSize(value)
	self.BLOOM_SIZE = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomThreshold(value)
	self.BLOOM_THRESHOLD = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:UpdateColorCorrection()
	self:ApplySingleEffect("ColorCorrectionEffect", self.COLOR_CORRECTION_ENABLED, function(cc)
		cc.Brightness = self.COLOR_CORRECTION_BRIGHTNESS
		cc.Contrast = self.COLOR_CORRECTION_CONTRAST
		cc.Saturation = self.COLOR_CORRECTION_SATURATION
		cc.TintColor = self.COLOR_CORRECTION_TINT
	end)
end

function VisualsModule:SetColorCorrectionEnabled(value)
	self.COLOR_CORRECTION_ENABLED = value
	self:UpdateColorCorrection()
end

function VisualsModule:SetColorCorrectionBrightness(value)
	self.COLOR_CORRECTION_BRIGHTNESS = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionContrast(value)
	self.COLOR_CORRECTION_CONTRAST = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionSaturation(value)
	self.COLOR_CORRECTION_SATURATION = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionTint(value)
	self.COLOR_CORRECTION_TINT = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetHitlogEnabled(value)
	self.HITLOG_ENABLED = value
	if self.hitlogContainer then
		self.hitlogContainer.Visible = value
	end
end

function VisualsModule:SetHitSoundEnabled(value)
	self.HITSOUND_ENABLED = value
end

function VisualsModule:SetHitSoundPreset(value)
	self.HITSOUND_PRESET = value
end

function VisualsModule:SetHitSoundVolume(value)
	self.HITSOUND_VOLUME = value
end

function VisualsModule:SetTracerEnabled(value)
	self.TRACER_ENABLED = value
end

function VisualsModule:SetTracerColor(value)
	self.TRACER_COLOR = value
end

function VisualsModule:SetTracerLifetime(value)
	self.TRACER_LIFETIME = value
end

function VisualsModule:SetTracerWidth(value)
	self.TRACER_WIDTH = value
end

function VisualsModule:SetTracerStyle(value)
	self.TRACER_STYLE = value
end

function VisualsModule:SetTracerNeon(value)
	self.TRACER_NEON = value
	if value then
		self.TRACER_BRIGHTNESS = 40
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0
	else
		self.TRACER_BRIGHTNESS = 20
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0.95
	end
end

function VisualsModule:SetChinaHatEnabled(value)
	self.CHINA_HAT_ENABLED = value
	if value then
		self:SpawnChinaHat()
	else
		self:DestroyChinaHat()
	end
end

function VisualsModule:SetChinaHatColor(value)
	self.CHINA_HAT_COLOR = value
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p.Color = value end
	end
end

function VisualsModule:SetWingsEnabled(value)
	self.WINGS_ENABLED = value
	if value then
		self:SpawnWings()
	else
		self:DestroyWings()
	end
end

function VisualsModule:SetWingsColor(value)
	self.WINGS_COLOR = value
	if self._wingData then
		for _, p in ipairs(self._wingData.allParts) do
			if p and p.Parent then
				if not p:IsA("Part") or p.Transparency < 1 then
					pcall(function() p.Color = value end)
				end
			end
		end
		for _, trail in ipairs(self._wingData.allTrails) do
			trail.Color = ColorSequence.new(value)
		end
		if self._wingData.glow then self._wingData.glow.Color = value end
		if self._wingData.particles then
			self._wingData.particles.Color = ColorSequence.new(value)
		end
	end
end

function VisualsModule:SetAuraEnabled(value)
	self.AURA_ENABLED = value
	if value then
		self:SpawnAura()
	else
		self:DestroyAura()
	end
end

function VisualsModule:SetAuraColor(value)
	self.AURA_COLOR = value
	if self._auraData then
		local function colorOrb(orb)
			if orb and orb.Parent then
				orb.Color = value
				local light = orb:FindFirstChildOfClass("PointLight")
				if light then light.Color = value end
				local trail = orb:FindFirstChildOfClass("Trail")
				if trail then trail.Color = ColorSequence.new(value) end
			end
		end
		for _, orb in ipairs(self._auraData.mainOrbs) do colorOrb(orb) end
		for _, orb in ipairs(self._auraData.innerOrbs) do colorOrb(orb) end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter.Color = ColorSequence.new(value)
		end
	end
end

function VisualsModule:SetJumpCirclesEnabled(value)
	self.JUMP_CIRCLES_ENABLED = value
	if value then
		self:ConnectJumpCircles()
	else
		self:DisconnectJumpCircles()
	end
end

function VisualsModule:SetJumpCirclesColor(value)
	self.JUMP_CIRCLES_COLOR = value
end

function VisualsModule:SetHitMarkerEnabled(value)
	self.HIT_MARKER_ENABLED = value
end

function VisualsModule:SetNeonPlayerEnabled(value)
	self.NEON_PLAYER_ENABLED = value
	if value then
		self:ApplyNeonPlayer()
	else
		self:RemoveNeonPlayer()
	end
end

function VisualsModule:SetNeonPlayerColor(value)
	self.NEON_PLAYER_COLOR = value
	if self.NEON_PLAYER_ENABLED then
		self:ApplyNeonPlayer()
	end
end

function VisualsModule:ApplyNeonPlayer()
	self:RemoveNeonPlayer()
	local char = self.player.Character
	if not char then return end
	local col = self.NEON_PLAYER_COLOR

	for _, v in pairs(char:GetDescendants()) do
		if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then
			self._origMaterials[v] = v.Material
			v.Material = Enum.Material.Neon
			v.Color = col
		end
	end

	local hrp = char:FindFirstChild("HumanoidRootPart")
	if hrp then
		local glow = Instance.new("PointLight")
		glow.Name = "ArcNeonGlow"
		glow.Color = col
		glow.Range = 14
		glow.Brightness = 1.2
		glow.Parent = hrp
		self._neonGlow = glow
	end

	self._neonConn = self.RunService.Heartbeat:Connect(function()
		if not char or not char.Parent then
			self:RemoveNeonPlayer()
			return
		end
		for v, _ in pairs(self._origMaterials) do
			if v and v.Parent then
				v.Material = Enum.Material.Neon
				v.Color = col
			end
		end
	end)

	if not self._neonCharConn then
		self._neonCharConn = self.player.CharacterAdded:Connect(function()
			task.wait(0.5)
			if self.NEON_PLAYER_ENABLED then
				self:ApplyNeonPlayer()
			end
		end)
	end
end

function VisualsModule:RemoveNeonPlayer()
	if self._neonConn then
		pcall(function() self._neonConn:Disconnect() end)
		self._neonConn = nil
	end
	if self._neonGlow and self._neonGlow.Parent then
		self._neonGlow:Destroy()
		self._neonGlow = nil
	end
	for v, origMat in pairs(self._origMaterials) do
		pcall(function()
			if v and v.Parent then v.Material = origMat end
		end)
	end
	self._origMaterials = {}
end

function VisualsModule:SetWallbangEnabled(value)
	self.WALLBANG_ENABLED = value
end

function VisualsModule:SetWallbangEntryColor(value)
	self.WALLBANG_ENTRY_COLOR = value
end

function VisualsModule:SetWallbangExitColor(value)
	self.WALLBANG_EXIT_COLOR = value
end

function VisualsModule:SetWallbangMarkerSize(value)
	if typeof(value) == "number" then
		self.WALLBANG_MARKER_SIZE = Vector3.new(value, value, value)
	elseif typeof(value) == "Vector3" then
		self.WALLBANG_MARKER_SIZE = value
	end
end

function VisualsModule:SetWallbangLifetime(value)
	self.WALLBANG_LIFETIME = value
end

function VisualsModule:SetKillFXEnabled(value)
	self.KILLFX_ENABLED = value
end

function VisualsModule:SetKillFXType(value)
	self.KILLFX_TYPE = value
end

function VisualsModule:SetKillFXColor(value)
	self.KILLFX_COLOR = value
end

function VisualsModule:SetKillFXLightColor(value)
	self.KILLFX_LIGHT_COLOR = value
end

function VisualsModule:SetKillFXDuration(value)
	self.KILLFX_CUSTOM_DURATION = value
end

function VisualsModule:SetKillFXLightRange(value)
	self.KILLFX_LIGHT_RANGE = value
end

function VisualsModule:SetKillFXLightBrightness(value)
	self.KILLFX_LIGHT_BRIGHTNESS = value
end

function VisualsModule:SetOffscreenEnabled(value)
	self.OFFSCREEN_ENABLED = value
end

function VisualsModule:SetOffscreenColor(value)
	self.OFFSCREEN_COLOR = value
end

function VisualsModule:SetBacktrackGhostEnabled(value)
	self.BACKTRACK_GHOST_ENABLED = value
	if not value then
		self:ClearBacktrackGhost()
	end
end

function VisualsModule:SetBacktrackGhostColor(value)
	self.BACKTRACK_GHOST_COLOR = value
	for _, p in ipairs(self.ghostParts) do
		p.Color = value
		p.Transparency = self.GHOST_BASE_TRANSPARENCY
	end
end

function VisualsModule:SetBacktrackGhostDuration(value)
	self.BACKTRACK_GHOST_DURATION = value
end

function VisualsModule:SetKillImageEnabled(value)
	self.KILLIMAGE_ENABLED = value
end

function VisualsModule:SetKillImageColor(value)
	self.KILLIMAGE_COLOR = value
end

function VisualsModule:SetKillImageMaxAlpha(value)
	self.KILLIMAGE_MAX_ALPHA = value
end

function VisualsModule:GetSettings()
	local function colorToTable(c)
		return { math.floor(c.R * 255), math.floor(c.G * 255), math.floor(c.B * 255) }
	end

	return {
		HITLOG_ENABLED = self.HITLOG_ENABLED,
		HITSOUND_ENABLED = self.HITSOUND_ENABLED,
		HITSOUND_PRESET = self.HITSOUND_PRESET,
		HITSOUND_VOLUME = self.HITSOUND_VOLUME,

		OFFSCREEN_ENABLED = self.OFFSCREEN_ENABLED,
		OFFSCREEN_COLOR = colorToTable(self.OFFSCREEN_COLOR),

		WALLBANG_ENABLED = self.WALLBANG_ENABLED,
		WALLBANG_ENTRY_COLOR = colorToTable(self.WALLBANG_ENTRY_COLOR),
		WALLBANG_EXIT_COLOR = colorToTable(self.WALLBANG_EXIT_COLOR),
		WALLBANG_MARKER_SIZE = self.WALLBANG_MARKER_SIZE.X,
		WALLBANG_LIFETIME = self.WALLBANG_LIFETIME,

		KILLFX_ENABLED = self.KILLFX_ENABLED,
		KILLFX_TYPE = self.KILLFX_TYPE,
		KILLFX_COLOR = colorToTable(self.KILLFX_COLOR),
		KILLFX_LIGHT_COLOR = colorToTable(self.KILLFX_LIGHT_COLOR),
		KILLFX_CUSTOM_DURATION = self.KILLFX_CUSTOM_DURATION,
		KILLFX_LIGHT_RANGE = self.KILLFX_LIGHT_RANGE,
		KILLFX_LIGHT_BRIGHTNESS = self.KILLFX_LIGHT_BRIGHTNESS,

		KILLIMAGE_ENABLED = self.KILLIMAGE_ENABLED,
		KILLIMAGE_COLOR = colorToTable(self.KILLIMAGE_COLOR),
		KILLIMAGE_MAX_ALPHA = self.KILLIMAGE_MAX_ALPHA,

		BACKTRACK_GHOST_ENABLED = self.BACKTRACK_GHOST_ENABLED,
		BACKTRACK_GHOST_COLOR = colorToTable(self.BACKTRACK_GHOST_COLOR),
		BACKTRACK_GHOST_DURATION = self.BACKTRACK_GHOST_DURATION,

		TRACER_ENABLED = self.TRACER_ENABLED,
		TRACER_COLOR = colorToTable(self.TRACER_COLOR),
		TRACER_LIFETIME = self.TRACER_LIFETIME,
		TRACER_WIDTH = self.TRACER_WIDTH,
		TRACER_NEON = self.TRACER_NEON,
		TRACER_STYLE = self.TRACER_STYLE,

		CHINA_HAT_ENABLED = self.CHINA_HAT_ENABLED,
		CHINA_HAT_COLOR = colorToTable(self.CHINA_HAT_COLOR),
		WINGS_ENABLED = self.WINGS_ENABLED,
		WINGS_COLOR = colorToTable(self.WINGS_COLOR),
		AURA_ENABLED = self.AURA_ENABLED,
		AURA_COLOR = colorToTable(self.AURA_COLOR),
		JUMP_CIRCLES_ENABLED = self.JUMP_CIRCLES_ENABLED,
		JUMP_CIRCLES_COLOR = colorToTable(self.JUMP_CIRCLES_COLOR),

		HIT_MARKER_ENABLED = self.HIT_MARKER_ENABLED,

		NEON_PLAYER_ENABLED = self.NEON_PLAYER_ENABLED,
		NEON_PLAYER_COLOR = colorToTable(self.NEON_PLAYER_COLOR),

		ATMOSPHERE_ENABLED = self.ATMOSPHERE_ENABLED,
		ATMOSPHERE_DENSITY = self.ATMOSPHERE_DENSITY,
		ATMOSPHERE_OFFSET = self.ATMOSPHERE_OFFSET,
		ATMOSPHERE_COLOR = colorToTable(self.ATMOSPHERE_COLOR),
		ATMOSPHERE_DECAY = colorToTable(self.ATMOSPHERE_DECAY),
		ATMOSPHERE_GLARE = self.ATMOSPHERE_GLARE,
		ATMOSPHERE_HAZE = self.ATMOSPHERE_HAZE,

		BLOOM_ENABLED = self.BLOOM_ENABLED,
		BLOOM_INTENSITY = self.BLOOM_INTENSITY,
		BLOOM_SIZE = self.BLOOM_SIZE,
		BLOOM_THRESHOLD = self.BLOOM_THRESHOLD,

		COLOR_CORRECTION_ENABLED = self.COLOR_CORRECTION_ENABLED,
		COLOR_CORRECTION_BRIGHTNESS = self.COLOR_CORRECTION_BRIGHTNESS,
		COLOR_CORRECTION_CONTRAST = self.COLOR_CORRECTION_CONTRAST,
		COLOR_CORRECTION_SATURATION = self.COLOR_CORRECTION_SATURATION,
		COLOR_CORRECTION_TINT = colorToTable(self.COLOR_CORRECTION_TINT),
	}
end

function VisualsModule:ApplySettings(settings)
	if not settings then return end

	local function toColor3(arr)
		if type(arr) == "table" and #arr >= 3 then
			return Color3.fromRGB(arr[1], arr[2], arr[3])
		end
		return nil
	end

	if settings.HITLOG_ENABLED ~= nil then self:SetHitlogEnabled(settings.HITLOG_ENABLED) end
	if settings.HITSOUND_ENABLED ~= nil then self:SetHitSoundEnabled(settings.HITSOUND_ENABLED) end
	if settings.HITSOUND_PRESET ~= nil then self:SetHitSoundPreset(settings.HITSOUND_PRESET) end
	if settings.HITSOUND_VOLUME ~= nil then self:SetHitSoundVolume(settings.HITSOUND_VOLUME) end

	if settings.OFFSCREEN_ENABLED ~= nil then self:SetOffscreenEnabled(settings.OFFSCREEN_ENABLED) end
	if settings.OFFSCREEN_COLOR then self:SetOffscreenColor(toColor3(settings.OFFSCREEN_COLOR) or self.OFFSCREEN_COLOR) end

	if settings.WALLBANG_ENABLED ~= nil then self:SetWallbangEnabled(settings.WALLBANG_ENABLED) end
	if settings.WALLBANG_ENTRY_COLOR then self:SetWallbangEntryColor(toColor3(settings.WALLBANG_ENTRY_COLOR) or self.WALLBANG_ENTRY_COLOR) end
	if settings.WALLBANG_EXIT_COLOR then self:SetWallbangExitColor(toColor3(settings.WALLBANG_EXIT_COLOR) or self.WALLBANG_EXIT_COLOR) end
	if settings.WALLBANG_MARKER_SIZE ~= nil then self:SetWallbangMarkerSize(settings.WALLBANG_MARKER_SIZE) end
	if settings.WALLBANG_LIFETIME ~= nil then self:SetWallbangLifetime(settings.WALLBANG_LIFETIME) end

	if settings.KILLFX_ENABLED ~= nil then self:SetKillFXEnabled(settings.KILLFX_ENABLED) end
	if settings.KILLFX_TYPE ~= nil then self:SetKillFXType(settings.KILLFX_TYPE) end
	if settings.KILLFX_COLOR then self:SetKillFXColor(toColor3(settings.KILLFX_COLOR) or self.KILLFX_COLOR) end
	if settings.KILLFX_LIGHT_COLOR then self:SetKillFXLightColor(toColor3(settings.KILLFX_LIGHT_COLOR) or self.KILLFX_LIGHT_COLOR) end
	if settings.KILLFX_CUSTOM_DURATION ~= nil then self:SetKillFXDuration(settings.KILLFX_CUSTOM_DURATION) end
	if settings.KILLFX_LIGHT_RANGE ~= nil then self:SetKillFXLightRange(settings.KILLFX_LIGHT_RANGE) end
	if settings.KILLFX_LIGHT_BRIGHTNESS ~= nil then self:SetKillFXLightBrightness(settings.KILLFX_LIGHT_BRIGHTNESS) end

	if settings.KILLIMAGE_ENABLED ~= nil then self:SetKillImageEnabled(settings.KILLIMAGE_ENABLED) end
	if settings.KILLIMAGE_COLOR then self:SetKillImageColor(toColor3(settings.KILLIMAGE_COLOR) or self.KILLIMAGE_COLOR) end
	if settings.KILLIMAGE_MAX_ALPHA ~= nil then self:SetKillImageMaxAlpha(settings.KILLIMAGE_MAX_ALPHA) end

	if settings.BACKTRACK_GHOST_ENABLED ~= nil then self:SetBacktrackGhostEnabled(settings.BACKTRACK_GHOST_ENABLED) end
	if settings.BACKTRACK_GHOST_COLOR then self:SetBacktrackGhostColor(toColor3(settings.BACKTRACK_GHOST_COLOR) or self.BACKTRACK_GHOST_COLOR) end
	if settings.BACKTRACK_GHOST_DURATION ~= nil then self:SetBacktrackGhostDuration(settings.BACKTRACK_GHOST_DURATION) end

	if settings.TRACER_ENABLED ~= nil then self:SetTracerEnabled(settings.TRACER_ENABLED) end
	if settings.TRACER_COLOR then self:SetTracerColor(toColor3(settings.TRACER_COLOR) or self.TRACER_COLOR) end
	if settings.TRACER_LIFETIME ~= nil then self:SetTracerLifetime(settings.TRACER_LIFETIME) end
	if settings.TRACER_WIDTH ~= nil then self:SetTracerWidth(settings.TRACER_WIDTH) end
	if settings.TRACER_NEON ~= nil then self:SetTracerNeon(settings.TRACER_NEON) end
	if settings.TRACER_STYLE then self:SetTracerStyle(settings.TRACER_STYLE) end

	if settings.CHINA_HAT_ENABLED ~= nil then self:SetChinaHatEnabled(settings.CHINA_HAT_ENABLED) end
	if settings.CHINA_HAT_COLOR then self:SetChinaHatColor(toColor3(settings.CHINA_HAT_COLOR) or self.CHINA_HAT_COLOR) end
	if settings.WINGS_ENABLED ~= nil then self:SetWingsEnabled(settings.WINGS_ENABLED) end
	if settings.WINGS_COLOR then self:SetWingsColor(toColor3(settings.WINGS_COLOR) or self.WINGS_COLOR) end
	if settings.AURA_ENABLED ~= nil then self:SetAuraEnabled(settings.AURA_ENABLED) end
	if settings.AURA_COLOR then self:SetAuraColor(toColor3(settings.AURA_COLOR) or self.AURA_COLOR) end
	if settings.JUMP_CIRCLES_ENABLED ~= nil then self:SetJumpCirclesEnabled(settings.JUMP_CIRCLES_ENABLED) end
	if settings.JUMP_CIRCLES_COLOR then self:SetJumpCirclesColor(toColor3(settings.JUMP_CIRCLES_COLOR) or self.JUMP_CIRCLES_COLOR) end

	if settings.HIT_MARKER_ENABLED ~= nil then self:SetHitMarkerEnabled(settings.HIT_MARKER_ENABLED) end

	if settings.NEON_PLAYER_ENABLED ~= nil then self:SetNeonPlayerEnabled(settings.NEON_PLAYER_ENABLED) end
	if settings.NEON_PLAYER_COLOR then self:SetNeonPlayerColor(toColor3(settings.NEON_PLAYER_COLOR) or self.NEON_PLAYER_COLOR) end

	if settings.ATMOSPHERE_ENABLED ~= nil then self:SetAtmosphereEnabled(settings.ATMOSPHERE_ENABLED) end
	if settings.ATMOSPHERE_DENSITY ~= nil then self:SetAtmosphereDensity(settings.ATMOSPHERE_DENSITY) end
	if settings.ATMOSPHERE_OFFSET ~= nil then self:SetAtmosphereOffset(settings.ATMOSPHERE_OFFSET) end
	if settings.ATMOSPHERE_COLOR then self:SetAtmosphereColor(toColor3(settings.ATMOSPHERE_COLOR) or self.ATMOSPHERE_COLOR) end
	if settings.ATMOSPHERE_DECAY then self:SetAtmosphereDecay(toColor3(settings.ATMOSPHERE_DECAY) or self.ATMOSPHERE_DECAY) end
	if settings.ATMOSPHERE_GLARE ~= nil then self:SetAtmosphereGlare(settings.ATMOSPHERE_GLARE) end
	if settings.ATMOSPHERE_HAZE ~= nil then self:SetAtmosphereHaze(settings.ATMOSPHERE_HAZE) end

	if settings.BLOOM_ENABLED ~= nil then self:SetBloomEnabled(settings.BLOOM_ENABLED) end
	if settings.BLOOM_INTENSITY ~= nil then self:SetBloomIntensity(settings.BLOOM_INTENSITY) end
	if settings.BLOOM_SIZE ~= nil then self:SetBloomSize(settings.BLOOM_SIZE) end
	if settings.BLOOM_THRESHOLD ~= nil then self:SetBloomThreshold(settings.BLOOM_THRESHOLD) end

	if settings.COLOR_CORRECTION_ENABLED ~= nil then self:SetColorCorrectionEnabled(settings.COLOR_CORRECTION_ENABLED) end
	if settings.COLOR_CORRECTION_BRIGHTNESS ~= nil then self:SetColorCorrectionBrightness(settings.COLOR_CORRECTION_BRIGHTNESS) end
	if settings.COLOR_CORRECTION_CONTRAST ~= nil then self:SetColorCorrectionContrast(settings.COLOR_CORRECTION_CONTRAST) end
	if settings.COLOR_CORRECTION_SATURATION ~= nil then self:SetColorCorrectionSaturation(settings.COLOR_CORRECTION_SATURATION) end
	if settings.COLOR_CORRECTION_TINT then self:SetColorCorrectionTint(toColor3(settings.COLOR_CORRECTION_TINT) or self.COLOR_CORRECTION_TINT) end
end

function VisualsModule:Start()
end

return VisualsModule
