local VisualsModule = {}
VisualsModule.__index = VisualsModule

function VisualsModule.new(config)
	local self = setmetatable({}, VisualsModule)

	self.player = config.Player
	self.guiParent = config.GuiParent
	self.Services = config.Services or {}

	self.Players = self.Services.Players
	self.TweenService = self.Services.TweenService
	self.RunService = self.Services.RunService
	self.UserInputService = self.Services.UserInputService
	self.ReplicatedStorage = self.Services.ReplicatedStorage
	self.Workspace = self.Services.Workspace
	self.Lighting = self.Services.Lighting
	self.Debris = self.Services.Debris
	self.SoundService = self.Services.SoundService
	self.HttpService = self.Services.HttpService

	self.Notification = config.Notification
	self.IsFakeLagEnabled = config.IsFakeLagEnabled

	self.HITLOG_ENABLED = false
	self.HITSOUND_ENABLED = true
	self.HITSOUND_VOLUME = 1
	self.HITSOUND_PRESET = "bell"

self.GHOST_BASE_TRANSPARENCY = 0.7
self.GHOST_FADE_RADIUS = 1.6
self.GHOST_FADE_POWER = 1.2

	self.TRACER_ENABLED = false
	self.TRACER_COLOR = Color3.fromRGB(255, 255, 255)
	self.TRACER_LIFETIME = 0.45
	self.TRACER_WIDTH = 0.12
	self.TRACER_NEON = false
	self.TRACER_STYLE = "Classic"

	self.TRACER_BRIGHTNESS = 20
	self.TRACER_LIGHTEMISSION = 1
	self.TRACER_LIGHTINFLUENCE = 0.95
	self.TRACER_TAIL = 2
	self.TRACER_TRANSPARENCY = NumberSequence.new({
		NumberSequenceKeypoint.new(0.00, 1.00),
		NumberSequenceKeypoint.new(0.125, 0.05),
		NumberSequenceKeypoint.new(0.89, 0.0562),
		NumberSequenceKeypoint.new(1.00, 1.00),
	})

	self.WALLBANG_ENABLED = false
	self.WALLBANG_ENTRY_COLOR = Color3.fromRGB(255, 50, 50)
	self.WALLBANG_EXIT_COLOR = Color3.fromRGB(50, 255, 50)
	self.WALLBANG_MARKER_SIZE = Vector3.new(0.5, 0.5, 0.5)
	self.WALLBANG_LIFETIME = 3

	self.KILLFX_ENABLED = false
	self.KILLFX_TYPE = "Sparkle"
	self.KILLFX_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLFX_LIGHT_COLOR = Color3.fromRGB(120, 180, 255)
	self.KILLFX_CUSTOM_DURATION = 0.25
	self.KILLFX_LIGHT_RANGE = 15
	self.KILLFX_LIGHT_BRIGHTNESS = 1

	self.OFFSCREEN_ENABLED = false
	self.OFFSCREEN_COLOR = Color3.fromRGB(255, 80, 80)

	self.BACKTRACK_GHOST_ENABLED = false
	self.BACKTRACK_GHOST_COLOR = Color3.fromRGB(80, 160, 255)
	self.BACKTRACK_GHOST_DURATION = 0.3

	self.KILLIMAGE_ENABLED = false
	self.KILLIMAGE_COLOR = Color3.fromRGB(80, 160, 255)
	self.KILLIMAGE_FADE_IN = 0.08
	self.KILLIMAGE_HOLD = 0.1
	self.KILLIMAGE_FADE_OUT = 0.6
	self.KILLIMAGE_MAX_ALPHA = 0.45

	self.ATMOSPHERE_ENABLED = false
	self.ATMOSPHERE_DENSITY = 0.3
	self.ATMOSPHERE_OFFSET = 0.25
	self.ATMOSPHERE_COLOR = Color3.fromRGB(200, 200, 200)
	self.ATMOSPHERE_DECAY = Color3.fromRGB(128, 128, 128)
	self.ATMOSPHERE_GLARE = 0.5
	self.ATMOSPHERE_HAZE = 0.5

	self.BLOOM_ENABLED = false
	self.BLOOM_INTENSITY = 2
	self.BLOOM_SIZE = 56
	self.BLOOM_THRESHOLD = 0.8

	self.COLOR_CORRECTION_ENABLED = false
	self.COLOR_CORRECTION_BRIGHTNESS = 0
	self.COLOR_CORRECTION_CONTRAST = 0
	self.COLOR_CORRECTION_SATURATION = 0
	self.COLOR_CORRECTION_TINT = Color3.fromRGB(255, 255, 255)

	self.CHINA_HAT_ENABLED = false
	self.CHINA_HAT_COLOR = Color3.fromRGB(255, 255, 255)
	self._chinaHatParts = {}

	self.WINGS_ENABLED = false
	self.WINGS_COLOR = Color3.fromRGB(255, 255, 255)
	self._wingData = nil

	self.AURA_ENABLED = false
	self.AURA_COLOR = Color3.fromRGB(255, 255, 255)
	self._auraData = nil

	self.JUMP_CIRCLES_ENABLED = false
	self.JUMP_CIRCLES_COLOR = Color3.fromRGB(255, 255, 255)
	self._jumpConn = nil

	self.HIT_MARKER_ENABLED = false
	self._hitMarkerGui = nil
	self._hitMarkerLines = {}

	self.tracerPool = {}
	self.MAX_TRACER_POOL = 12

	self.arrows = {}
	self.hitlogContainer = nil
	self.hitlogOrder = 0

	self._bindInputBegan = nil
	self._bindInputEnded = nil

	self.ghostModel = nil
	self.ghostExpireAt = 0
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
	self.ghostParts = {}
	self.ghostLastCFrames = {}
	self.GHOST_SMOOTH_SPEED = 45
	self._hbLast = tick()
	self._ghostDt = 1 / 60

	self.killImage = nil

	self:Initialize()

	return self
end

function VisualsModule:Initialize()
	self.Camera = self.Workspace.CurrentCamera
	self.FX_ROOT = self.ReplicatedStorage:WaitForChild("FXTemplates")
	self.HITSOUND_STORAGE = self.guiParent:WaitForChild("ScreenGui"):WaitForChild("storage")

	self.ORIGINAL_EFFECTS = {
		Atmosphere = self:SnapshotFirstEffect("Atmosphere"),
		BloomEffect = self:SnapshotFirstEffect("BloomEffect"),
		ColorCorrectionEffect = self:SnapshotFirstEffect("ColorCorrectionEffect"),
	}

	self:CreateHitlogUI()
	self:CreateOffscreenArrows()
	self:CreateKillImageGUI()
	self:CreateHitMarkerUI()
	self:SetupBacktrackGhost()
	self:SetupKillFXListener()
	self:SetupPlayerEffects()
end

function VisualsModule:CreateHitlogUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "NemesisHitlogs"
	screenGui.ResetOnSpawn = false
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	screenGui.Parent = self.guiParent

	local container = Instance.new("Frame")
	container.Name = "HitlogList"
	container.Active = false
	container.Selectable = false
	container.Size = UDim2.new(0, 300, 0, 200)
	container.Position = UDim2.new(0.5, -150, 0.55, 20)
	container.AnchorPoint = Vector2.new(0, 0)
	container.BackgroundTransparency = 1
	container.BorderSizePixel = 0
	container.Parent = screenGui

	local listLayout = Instance.new("UIListLayout")
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Padding = UDim.new(0, 2)
	listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	listLayout.Parent = container

	self.hitlogContainer = container
	self.hitlogOrder = 0
end

function VisualsModule:ShowHitlog(hitType, info)
	if not self.HITLOG_ENABLED then return end
	if not self.hitlogContainer then return end

	self.hitlogOrder += 1

	local text
	if hitType == "Hit" and info then
		text = string.format("HIT  %s  %d DMG  %d studs",
			tostring(info.bodyPart or "Body"),
			math.floor(tonumber(info.damage) or 0),
			math.floor(tonumber(info.distance) or 0))
	elseif hitType == "Miss" and info then
		local reason = info.reason or "unknown"
		if reason == "hitchance_failed" then
			text = string.format("MISS  %d%% (%d)  %d studs",
				tonumber(info.hitchance) or 0, tonumber(info.roll) or 0, tonumber(info.distance) or 0)
		elseif reason == "min_damage" then
			text = string.format("MISS  DMG < %d  %d studs", tonumber(info.minDamage) or 0, tonumber(info.distance) or 0)
		elseif reason == "wall_blocking_target" then
			text = string.format("MISS  WALL  %d studs", tonumber(info.distance) or 0)
		elseif reason == "too_far" then
			text = string.format("MISS  TOO FAR  %d studs", tonumber(info.distance) or 0)
		elseif reason == "no_target" then text = "MISS  NO TARGET"
		elseif reason == "target_dead" then text = "MISS  DEAD"
		elseif reason == "friendly_fire" then text = "MISS  TEAM"
		else text = "MISS"
		end
	elseif hitType == "Hit" then text = "HIT"
	else text = "MISS"
	end

	local isHit = (hitType == "Hit")
	local accentColor = isHit and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(90, 90, 100)

	local row = Instance.new("Frame")
	row.Name = "Hitlog_" .. self.hitlogOrder
	row.Size = UDim2.new(1, 0, 0, 22)
	row.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
	row.BackgroundTransparency = 0.25
	row.BorderSizePixel = 0
	row.LayoutOrder = self.hitlogOrder
	row.Parent = self.hitlogContainer

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = row

	local stripe = Instance.new("Frame")
	stripe.Size = UDim2.new(0, 2, 1, -4)
	stripe.Position = UDim2.new(0, 2, 0, 2)
	stripe.BackgroundColor3 = accentColor
	stripe.BorderSizePixel = 0
	stripe.Parent = row
	local stripeCorner = Instance.new("UICorner")
	stripeCorner.CornerRadius = UDim.new(0, 1)
	stripeCorner.Parent = stripe

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -14, 1, 0)
	label.Position = UDim2.new(0, 10, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.TextColor3 = Color3.fromRGB(220, 220, 225)
	label.TextSize = 11
	label.Font = Enum.Font.Code
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextTransparency = 1
	label.Parent = row

	row.BackgroundTransparency = 1
	stripe.BackgroundTransparency = 1

	local showInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
	self.TweenService:Create(row, showInfo, {BackgroundTransparency = 0.25}):Play()
	self.TweenService:Create(stripe, showInfo, {BackgroundTransparency = 0}):Play()
	self.TweenService:Create(label, showInfo, {TextTransparency = 0}):Play()

	task.spawn(function()
		task.wait(2.5)
		if not row or not row.Parent then return end
		local hideInfo = TweenInfo.new(0.4, Enum.EasingStyle.Quint, Enum.EasingDirection.In)
		self.TweenService:Create(row, hideInfo, {BackgroundTransparency = 1}):Play()
		self.TweenService:Create(stripe, hideInfo, {BackgroundTransparency = 1}):Play()
		local t = self.TweenService:Create(label, hideInfo, {TextTransparency = 1})
		t:Play()
		t.Completed:Connect(function()
			if row and row.Parent then row:Destroy() end
		end)
	end)
end

function VisualsModule:PlayHitSound()
	if not self.HITSOUND_ENABLED then return end

	local HITSOUND_MAP = {
		correct = "HitSfx13",
		skeet = "HitSfx",
		orchestra = "HitSfx2",
		bow = "HitSfx3",
		uwu = "HitSfx4",
		tf2 = "HitSfx5",
		b8 = "HitSfx6",
		basketball = "HitSfx7",
		idk = "HitSfx8",
		orb = "HitSfx9",
		balltap = "HitSfx10",
		softbell = "HitSfx11",
		softhit = "HitSfx12",
		soft = "HitSfx14",
		bell2 = "HitSfx15",
		tank1 = "HitSfx16",
		rampage = "HitSfx18",
		headshot = "HitSfx19",
		tank2 = "HitSfx20",
		rust = "HitSfx22",
	}

	if self.HITSOUND_PRESET == "bell" then
		local s = Instance.new("Sound")
		s.SoundId = "rbxassetid://7112391013"
		s.Volume = self.HITSOUND_VOLUME
		s.Parent = self.SoundService
		s:Play()
		self.Debris:AddItem(s, 3)
		return
	end

	if not self.HITSOUND_STORAGE then return end

	local assetName = HITSOUND_MAP[self.HITSOUND_PRESET]
	if not assetName then return end

	local src = self.HITSOUND_STORAGE:FindFirstChild(assetName)
	if not src then return end

	local sound
	if src:IsA("Sound") then
		sound = src:Clone()
	else
		sound = src:FindFirstChildWhichIsA("Sound", true)
		if sound then sound = sound:Clone() end
	end
	if not sound then return end

	sound.Volume = self.HITSOUND_VOLUME
	sound.Parent = self.SoundService
	sound:Play()
	self.Debris:AddItem(sound, math.max(sound.TimeLength + 0.3, 2))
end

function VisualsModule:CreateOffscreenArrows()
	local OffscreenGui = Instance.new("ScreenGui")
	OffscreenGui.Name = "ArcOffscreen"
	OffscreenGui.IgnoreGuiInset = true
	OffscreenGui.ResetOnSpawn = false
	OffscreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	OffscreenGui.Parent = self.guiParent

	self.OffscreenGui = OffscreenGui

	local function isEnemy(plr)
		if self.player.Team and plr.Team then
			return self.player.Team ~= plr.Team
		end
		return true
	end

	local function createArrow(plr)
		local container = Instance.new("Frame")
		container.Name = plr.Name .. "_Arrow"
		container.Size = UDim2.fromOffset(30, 30)
		container.AnchorPoint = Vector2.new(0.5, 0.5)
		container.BackgroundTransparency = 1
		container.Visible = false
		container.Parent = OffscreenGui

		local tri = Instance.new("Frame")
		tri.Name = "Tri"
		tri.Size = UDim2.fromOffset(14, 20)
		tri.AnchorPoint = Vector2.new(0.5, 0.5)
		tri.Position = UDim2.fromScale(0.5, 0.35)
		tri.BackgroundColor3 = self.OFFSCREEN_COLOR
		tri.BackgroundTransparency = 0.05
		tri.Rotation = 0
		tri.Parent = container
		local triCorner = Instance.new("UICorner")
		triCorner.CornerRadius = UDim.new(0, 2)
		triCorner.Parent = tri

		local triStroke = Instance.new("UIStroke")
		triStroke.Color = Color3.fromRGB(0, 0, 0)
		triStroke.Thickness = 1.5
		triStroke.Transparency = 0.3
		triStroke.Parent = tri

		local tipL = Instance.new("Frame")
		tipL.Name = "TipL"
		tipL.Size = UDim2.fromOffset(10, 14)
		tipL.AnchorPoint = Vector2.new(1, 0)
		tipL.Position = UDim2.new(0.5, -1, 0, -4)
		tipL.BackgroundColor3 = self.OFFSCREEN_COLOR
		tipL.BackgroundTransparency = 0.05
		tipL.Rotation = -25
		tipL.Parent = container
		Instance.new("UICorner", tipL).CornerRadius = UDim.new(0, 2)
		local tipLS = Instance.new("UIStroke")
		tipLS.Color = Color3.fromRGB(0, 0, 0)
		tipLS.Thickness = 1.5
		tipLS.Transparency = 0.3
		tipLS.Parent = tipL

		local tipR = Instance.new("Frame")
		tipR.Name = "TipR"
		tipR.Size = UDim2.fromOffset(10, 14)
		tipR.AnchorPoint = Vector2.new(0, 0)
		tipR.Position = UDim2.new(0.5, 1, 0, -4)
		tipR.BackgroundColor3 = self.OFFSCREEN_COLOR
		tipR.BackgroundTransparency = 0.05
		tipR.Rotation = 25
		tipR.Parent = container
		Instance.new("UICorner", tipR).CornerRadius = UDim.new(0, 2)
		local tipRS = Instance.new("UIStroke")
		tipRS.Color = Color3.fromRGB(0, 0, 0)
		tipRS.Thickness = 1.5
		tipRS.Transparency = 0.3
		tipRS.Parent = tipR

		local distLabel = Instance.new("TextLabel")
		distLabel.Name = "Dist"
		distLabel.Size = UDim2.fromOffset(40, 12)
		distLabel.AnchorPoint = Vector2.new(0.5, 0)
		distLabel.Position = UDim2.new(0.5, 0, 1, 2)
		distLabel.BackgroundTransparency = 1
		distLabel.TextColor3 = self.OFFSCREEN_COLOR
		distLabel.Font = Enum.Font.GothamBold
		distLabel.TextSize = 9
		distLabel.Text = ""
		distLabel.TextStrokeTransparency = 0.4
		distLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
		distLabel.Parent = container

		self.arrows[plr] = {
			container = container,
			tri = tri,
			tipL = tipL,
			tipR = tipR,
			triStroke = triStroke,
			distLabel = distLabel,
		}
	end

	local function removeArrow(plr)
		if self.arrows[plr] then
			self.arrows[plr].container:Destroy()
			self.arrows[plr] = nil
		end
	end

	self.Players.PlayerAdded:Connect(function(plr)
		if plr ~= self.player and isEnemy(plr) then
			createArrow(plr)
		end
	end)
	self.Players.PlayerRemoving:Connect(removeArrow)

	for _, p in ipairs(self.Players:GetPlayers()) do
		if p ~= self.player and isEnemy(p) then
			createArrow(p)
		end
	end

	local function refreshArrows()
		for plr, data in pairs(self.arrows) do
			if not isEnemy(plr) then
				data.container:Destroy()
				self.arrows[plr] = nil
			end
		end
		for _, plr in ipairs(self.Players:GetPlayers()) do
			if plr ~= self.player and isEnemy(plr) and not self.arrows[plr] then
				createArrow(plr)
			end
		end
	end

	self.player:GetPropertyChangedSignal("Team"):Connect(refreshArrows)

	self.RunService.RenderStepped:Connect(function()
		local t = tick()
		self.Camera = self.Workspace.CurrentCamera or self.Camera
		local Camera = self.Camera
		if not Camera then return end

		if not self.OFFSCREEN_ENABLED then
			for _, data in pairs(self.arrows) do
				data.container.Visible = false
			end
			return
		end

		local camCF = Camera.CFrame
		local camPos = camCF.Position
		local vp = Camera.ViewportSize
		local center = Vector2.new(vp.X / 2, vp.Y / 2)
		local color = self.OFFSCREEN_COLOR

		for plr, data in pairs(self.arrows) do
			if not isEnemy(plr) then
				data.container.Visible = false
				continue
			end

			local char = plr.Character
			local hrp = char and char:FindFirstChild("HumanoidRootPart")
			local hum = char and char:FindFirstChild("Humanoid")

			if not hrp or not hum or hum.Health <= 0 then
				data.container.Visible = false
				continue
			end

			local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)

			if onScreen and screenPos.Z > 0 then
				if screenPos.X > 0 and screenPos.X < vp.X and screenPos.Y > 0 and screenPos.Y < vp.Y then
					data.container.Visible = false
					continue
				end
			end

			local toPlayer = (hrp.Position - camPos).Unit
			local camRight = camCF.RightVector
			local x = toPlayer:Dot(camRight)
			local z = toPlayer:Dot(camCF.LookVector)

			local angle = math.atan2(x, z)
			local rot = math.deg(angle)

			local dist = (hrp.Position - camPos).Magnitude
			local maxRadius = math.min(380, math.min(vp.X, vp.Y) * 0.38)
			local pos = center + Vector2.new(math.sin(angle), -math.cos(angle)) * maxRadius

			data.container.Position = UDim2.fromOffset(pos.X, pos.Y)
			data.container.Rotation = rot + 180

			local pulse = 0.85 + math.sin(t * 3.5) * 0.15
			data.tri.BackgroundColor3 = color
			data.tri.BackgroundTransparency = 1 - pulse
			data.tipL.BackgroundColor3 = color
			data.tipL.BackgroundTransparency = 1 - pulse
			data.tipR.BackgroundColor3 = color
			data.tipR.BackgroundTransparency = 1 - pulse

			data.distLabel.Rotation = -(rot + 180)
			data.distLabel.TextColor3 = color
			data.distLabel.Text = math.floor(dist) .. "m"

			data.container.Visible = true
		end
	end)
end

function VisualsModule:CreateLightningTracer(startPos, endPos)
	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	local folder = Instance.new("Folder")
	folder.Name = "lightning_tracer"
	folder.Parent = self.Workspace

	local color = self.TRACER_COLOR
	local dir = (endPos - startPos).Unit
	local segments = math.clamp(math.floor(distance / 3), 4, 16)
	local segLen = distance / segments
	local jitter = 1.2

	local points = {startPos}
	for i = 1, segments - 1 do
		local basePoint = startPos + dir * (segLen * i)
		local right = dir:Cross(Vector3.new(0, 1, 0))
		if right.Magnitude < 0.01 then right = dir:Cross(Vector3.new(1, 0, 0)) end
		right = right.Unit
		local up = dir:Cross(right).Unit
		local offsetR = (math.random() - 0.5) * 2 * jitter
		local offsetU = (math.random() - 0.5) * 2 * jitter
		table.insert(points, basePoint + right * offsetR + up * offsetU)
	end
	table.insert(points, endPos)

	for i = 1, #points - 1 do
		local p1 = points[i]
		local p2 = points[i + 1]
		local mid = (p1 + p2) / 2
		local len = (p2 - p1).Magnitude

		local seg = Instance.new("Part")
		seg.Name = "BoltSeg"
		seg.Anchored = true
		seg.CanCollide = false
		seg.CanQuery = false
		seg.CanTouch = false
		seg.CastShadow = false
		seg.Material = Enum.Material.Neon
		seg.Color = color
		seg.Size = Vector3.new(0.08, 0.08, len)
		seg.CFrame = CFrame.lookAt(mid, p2)
		seg.Transparency = 0.1
		seg.Parent = folder

		if i == 1 or i == #points - 1 then
			local glow = Instance.new("PointLight")
			glow.Color = color
			glow.Range = 6
			glow.Brightness = 1
			glow.Parent = seg
		end
	end

	local lifetime = self.TRACER_LIFETIME * 0.7
	task.delay(lifetime * 0.3, function()
		for _, child in pairs(folder:GetChildren()) do
			if child:IsA("BasePart") then
				self.TweenService:Create(child,
					TweenInfo.new(lifetime * 0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					{Transparency = 1}
				):Play()
			end
		end
	end)

	self.Debris:AddItem(folder, lifetime + 0.2)
end

function VisualsModule:CreateTracer(startPos, endPos)
	if not self.TRACER_ENABLED then return end

	if self.TRACER_STYLE == "Lightning" then
		self:CreateLightningTracer(startPos, endPos)
		return
	end

	local distance = (endPos - startPos).Magnitude
	if distance < 0.5 then return end

	if self.WALLBANG_ENABLED then
		local direction = (endPos - startPos)
		local dirUnit = direction.Unit

		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		local char = self.player.Character
		if char then
			params.FilterDescendantsInstances = { char }
		end

		local rayForward = self.Workspace:Raycast(startPos, dirUnit * distance, params)
		if rayForward then
			local rayBackward = self.Workspace:Raycast(endPos, -dirUnit * distance, params)
			if rayBackward then
				local penetrationDepth = (rayForward.Position - rayBackward.Position).Magnitude
				if penetrationDepth > 0.5 and penetrationDepth < (distance * 0.95) then
					task.spawn(function()
						self:CreateWallbangMarker(rayForward.Position, self.WALLBANG_ENTRY_COLOR)
						self:CreateWallbangMarker(rayBackward.Position, self.WALLBANG_EXIT_COLOR)
					end)
				end
			end
		end
	end

	local tracerObj = table.remove(self.tracerPool)
	if not tracerObj then
		local folder = Instance.new("Folder")
		folder.Name = "tracer_fx"

		local mover = Instance.new("Part")
		mover.Name = "Mover"
		mover.Anchored = true
		mover.Transparency = 1
		mover.CanCollide = false
		mover.CanQuery = false
		mover.CanTouch = false
		mover.Size = Vector3.new(0.05, 0.05, 0.05)
		mover.Parent = folder

		local a0 = Instance.new("Attachment")
		a0.Name = "A0"
		a0.Parent = mover

		local a1 = Instance.new("Attachment")
		a1.Name = "A1"
		a1.Parent = mover

		local trail = Instance.new("Trail")
		trail.Name = "Trace"
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Enabled = false
		trail.FaceCamera = true
		trail.Brightness = self.TRACER_BRIGHTNESS
		trail.LightEmission = self.TRACER_LIGHTEMISSION
		trail.LightInfluence = self.TRACER_LIGHTINFLUENCE
		trail.TextureMode = Enum.TextureMode.Stretch
		trail.Texture = "rbxassetid://93746968407218"
		trail.TextureLength = 3
		trail.Transparency = self.TRACER_TRANSPARENCY
		trail.Parent = mover

		tracerObj = { folder = folder, mover = mover, a0 = a0, a1 = a1, trail = trail }
	end

	local w = math.clamp(self.TRACER_WIDTH, 0.02, 0.25)

	tracerObj.trail.Color = ColorSequence.new(self.TRACER_COLOR)
	tracerObj.trail.Lifetime = self.TRACER_LIFETIME
	tracerObj.trail.WidthScale = NumberSequence.new(w)
	tracerObj.trail.Transparency = self.TRACER_TRANSPARENCY
	tracerObj.trail.Brightness = self.TRACER_BRIGHTNESS
	tracerObj.trail.LightEmission = self.TRACER_LIGHTEMISSION
	tracerObj.trail.LightInfluence = self.TRACER_LIGHTINFLUENCE

	local dir = (endPos - startPos)
	local unit = dir.Unit

	tracerObj.folder.Parent = self.Workspace
	tracerObj.mover.CFrame = CFrame.lookAt(startPos, startPos + unit)
	tracerObj.a0.Position = Vector3.new(0, 0, 0)
	tracerObj.a1.Position = Vector3.new(0, 0, -self.TRACER_TAIL)
	tracerObj.trail.Enabled = true

	local flyTime = math.clamp(distance / 2200, 0.06, 0.22)
	local tween = self.TweenService:Create(tracerObj.mover, TweenInfo.new(flyTime, Enum.EasingStyle.Linear), {
		CFrame = CFrame.lookAt(endPos, endPos + unit),
	})
	tween:Play()

	tween.Completed:Once(function()
		task.delay(tracerObj.trail.Lifetime + 0.05, function()
			if not tracerObj or not tracerObj.folder then return end
			tracerObj.trail.Enabled = false
			tracerObj.folder.Parent = nil
			if #self.tracerPool < self.MAX_TRACER_POOL then
				table.insert(self.tracerPool, tracerObj)
			else
				tracerObj.folder:Destroy()
			end
		end)
	end)
end

function VisualsModule:CreateWallbangMarker(pos, color)
	local part = Instance.new("Part")
	part.Name = "WallbangMarker"
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CastShadow = false
	part.Material = Enum.Material.ForceField
	part.Color = color
	part.Size = self.WALLBANG_MARKER_SIZE
	part.CFrame = CFrame.new(pos)
	part.Parent = self.Workspace

	part.Transparency = 0
	local tIn = self.TweenService:Create(part, TweenInfo.new(0.3), { Transparency = 0 })
	tIn:Play()

	self.Debris:AddItem(part, self.WALLBANG_LIFETIME)

	task.delay(self.WALLBANG_LIFETIME - 0.5, function()
		if part.Parent then
			self.TweenService:Create(part, TweenInfo.new(0.5), { Transparency = 1, Size = Vector3.new(0, 0, 0) }):Play()
		end
	end)
end

function VisualsModule:CreateKillImageGUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisKillImage"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.DisplayOrder = 9999
	gui.Parent = self.guiParent

	local img = Instance.new("ImageLabel")
	img.Name = "Effect"
	img.Size = UDim2.fromScale(1, 1)
	img.Position = UDim2.fromScale(0.5, 0.5)
	img.AnchorPoint = Vector2.new(0.5, 0.5)
	img.BackgroundTransparency = 1
	img.Image = "http://www.roblox.com/asset/?id=3124804643"
	img.ImageTransparency = 1
	img.ScaleType = Enum.ScaleType.Stretch
	img.ZIndex = 999
	img.Parent = gui

	self.killImage = img
end

function VisualsModule:PlayKillImage()
	if not self.KILLIMAGE_ENABLED then return end
	if not self.killImage then return end

	self.killImage.ImageColor3 = self.KILLIMAGE_COLOR
	self.killImage.ImageTransparency = 1

	local tIn = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_IN, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{ ImageTransparency = 1 - self.KILLIMAGE_MAX_ALPHA }
	)

	local tOut = self.TweenService:Create(
		self.killImage,
		TweenInfo.new(self.KILLIMAGE_FADE_OUT, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
		{ ImageTransparency = 1 }
	)

	tIn:Play()
	tIn.Completed:Wait()
	task.wait(self.KILLIMAGE_HOLD)
	tOut:Play()
end

function VisualsModule:CreateHitMarkerUI()
	local gui = Instance.new("ScreenGui")
	gui.Name = "NemesisHitMarker"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.DisplayOrder = 100
	gui.Parent = self.guiParent

	local holder = Instance.new("Frame")
	holder.Name = "HitMarker"
	holder.Size = UDim2.new(0, 40, 0, 40)
	holder.AnchorPoint = Vector2.new(0.5, 0.5)
	holder.Position = UDim2.new(0.5, 0, 0.5, 0)
	holder.BackgroundTransparency = 1
	holder.Visible = false
	holder.Parent = gui

	self._hitMarkerLines = {}

	local function makeLine(rot)
		local line = Instance.new("Frame")
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.Position = UDim2.new(0.5, 0, 0.5, 0)
		line.Size = UDim2.new(0, 2, 0, 24)
		line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		line.BorderSizePixel = 0
		line.Rotation = rot
		line.BackgroundTransparency = 1
		line.Parent = holder

		local hole = Instance.new("Frame")
		hole.AnchorPoint = Vector2.new(0.5, 0.5)
		hole.Position = UDim2.new(0.5, 0, 0.5, 0)
		hole.Size = UDim2.new(0, 4, 0, 8)
		hole.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		hole.BackgroundTransparency = 1
		hole.BorderSizePixel = 0
		hole.Parent = line

		return line
	end

	table.insert(self._hitMarkerLines, makeLine(45))
	table.insert(self._hitMarkerLines, makeLine(-45))

	self._hitMarkerGui = holder
end

function VisualsModule:FlashHitMarker()
	if not self.HIT_MARKER_ENABLED then return end
	if not self._hitMarkerGui then return end

	self._hitMarkerGui.Visible = true
	self._hitMarkerGui.Size = UDim2.new(0, 50, 0, 50)
	for _, l in ipairs(self._hitMarkerLines) do
		l.BackgroundTransparency = 0
	end

	local shrink = self.TweenService:Create(self._hitMarkerGui,
		TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = UDim2.new(0, 40, 0, 40)}
	)
	shrink:Play()

	task.spawn(function()
		task.wait(0.15)
		if not self._hitMarkerGui then return end
		local fadeInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		for _, l in ipairs(self._hitMarkerLines) do
			self.TweenService:Create(l, fadeInfo, {BackgroundTransparency = 1}):Play()
		end
		task.wait(0.2)
		if self._hitMarkerGui then self._hitMarkerGui.Visible = false end
	end)
end

function VisualsModule:SetupPlayerEffects()
	self.player.CharacterAdded:Connect(function(char)
		task.wait(0.5)
		if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
		if self.WINGS_ENABLED then self:SpawnWings() end
		if self.AURA_ENABLED then self:SpawnAura() end
		if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
	end)

	if self.player.Character then
		task.defer(function()
			if self.CHINA_HAT_ENABLED then self:SpawnChinaHat() end
			if self.WINGS_ENABLED then self:SpawnWings() end
			if self.AURA_ENABLED then self:SpawnAura() end
			if self.JUMP_CIRCLES_ENABLED then self:ConnectJumpCircles() end
		end)
	end
end

function VisualsModule:SpawnChinaHat()
	self:DestroyChinaHat()
	local char = self.player.Character
	if not char then return end
	local head = char:FindFirstChild("Head")
	if not head then return end

	local parts = {}
	local SLICES = 8
	local RADIUS = 1.6
	local HEIGHT = 1.0

	for i = 1, SLICES do
		local angle = (i - 1) * (math.pi * 2 / SLICES)
		local nextAngle = i * (math.pi * 2 / SLICES)
		local midAngle = (angle + nextAngle) / 2

		local wedge = Instance.new("WedgePart")
		wedge.Name = "ArcHatSlice"
		wedge.Material = Enum.Material.SmoothPlastic
		wedge.Color = self.CHINA_HAT_COLOR
		wedge.Anchored = false
		wedge.CanCollide = false
		wedge.CanTouch = false
		wedge.CanQuery = false
		wedge.CastShadow = false
		wedge.Massless = true
		wedge.Transparency = 0.05

		local sliceWidth = 2 * RADIUS * math.sin(math.pi / SLICES)
		wedge.Size = Vector3.new(sliceWidth, HEIGHT, RADIUS)

		local cf = head.CFrame
			* CFrame.new(0, 0.6, 0)
			* CFrame.Angles(0, midAngle, 0)
			* CFrame.new(0, 0, -RADIUS / 2)
			* CFrame.Angles(0, 0, 0)

		wedge.CFrame = cf
		wedge.Parent = char

		local weld = Instance.new("WeldConstraint")
		weld.Part0 = head
		weld.Part1 = wedge
		weld.Parent = wedge

		table.insert(parts, wedge)
	end

	local brim = Instance.new("Part")
	brim.Name = "ArcHatBrim"
	brim.Shape = Enum.PartType.Cylinder
	brim.Size = Vector3.new(0.06, RADIUS * 2.3, RADIUS * 2.3)
	brim.Material = Enum.Material.SmoothPlastic
	brim.Color = self.CHINA_HAT_COLOR
	brim.Anchored = false
	brim.CanCollide = false
	brim.CanTouch = false
	brim.CanQuery = false
	brim.CastShadow = false
	brim.Massless = true
	brim.Transparency = 0.05
	brim.CFrame = head.CFrame * CFrame.new(0, 0.58, 0) * CFrame.Angles(0, 0, math.rad(90))
	brim.Parent = char

	local brimWeld = Instance.new("WeldConstraint")
	brimWeld.Part0 = head
	brimWeld.Part1 = brim
	brimWeld.Parent = brim

	table.insert(parts, brim)
	self._chinaHatParts = parts
end

function VisualsModule:DestroyChinaHat()
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p:Destroy() end
	end
	self._chinaHatParts = {}
end

function VisualsModule:SpawnWings()
	self:DestroyWings()
	local char = self.player.Character
	if not char then return end
	local torso = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")
	if not torso then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcWings"
	folder.Parent = char

	local allParts = {}
	local allTrails = {}

	local featherDefs = {
		{side = -1, x = 0.5, y = 0.9, z = 0.4, ry = 8,  flapMult = 0.7, w = 0.8, h = 1.4, d = 0.15},
		{side = -1, x = 1.1, y = 0.7, z = 0.5, ry = 14, flapMult = 0.85, w = 1.0, h = 2.0, d = 0.12},
		{side = -1, x = 1.8, y = 0.4, z = 0.55, ry = 20, flapMult = 1.0, w = 1.1, h = 2.5, d = 0.10},
		{side = -1, x = 2.4, y = 0.0, z = 0.6, ry = 25, flapMult = 1.15, w = 1.0, h = 2.8, d = 0.08},
		{side = -1, x = 2.9, y = -0.4, z = 0.65, ry = 30, flapMult = 1.3, w = 0.8, h = 2.4, d = 0.07},
		{side = -1, x = 3.3, y = -0.8, z = 0.7, ry = 34, flapMult = 1.45, w = 0.6, h = 1.7, d = 0.06},
		{side = 1, x = 0.5, y = 0.9, z = 0.4, ry = 8,  flapMult = 0.7, w = 0.8, h = 1.4, d = 0.15},
		{side = 1, x = 1.1, y = 0.7, z = 0.5, ry = 14, flapMult = 0.85, w = 1.0, h = 2.0, d = 0.12},
		{side = 1, x = 1.8, y = 0.4, z = 0.55, ry = 20, flapMult = 1.0, w = 1.1, h = 2.5, d = 0.10},
		{side = 1, x = 2.4, y = 0.0, z = 0.6, ry = 25, flapMult = 1.15, w = 1.0, h = 2.8, d = 0.08},
		{side = 1, x = 2.9, y = -0.4, z = 0.65, ry = 30, flapMult = 1.3, w = 0.8, h = 2.4, d = 0.07},
		{side = 1, x = 3.3, y = -0.8, z = 0.7, ry = 34, flapMult = 1.45, w = 0.6, h = 1.7, d = 0.06},
	}

	local feathers = {}
	for _, def in ipairs(featherDefs) do
		local feather = Instance.new("Part")
		feather.Name = "ArcFeather"
		feather.Size = Vector3.new(def.d, def.h, def.w)
		feather.Material = Enum.Material.Neon
		feather.Color = self.WINGS_COLOR
		feather.Anchored = true
		feather.CanCollide = false
		feather.CanTouch = false
		feather.CanQuery = false
		feather.CastShadow = false
		feather.Transparency = 0.15
		feather.Parent = folder
		table.insert(allParts, feather)

		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, def.h * 0.4, 0)
		a0.Parent = feather
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -def.h * 0.4, 0)
		a1.Parent = feather
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.WINGS_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.55),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.35
		trail.FaceCamera = true
		trail.LightEmission = 0.7
		trail.Parent = feather
		table.insert(allTrails, trail)

		table.insert(feathers, {part = feather, def = def})
	end

	local glowPart = Instance.new("Part")
	glowPart.Name = "ArcWingGlow"
	glowPart.Size = Vector3.new(0.5, 0.5, 0.5)
	glowPart.Transparency = 1
	glowPart.Anchored = true
	glowPart.CanCollide = false
	glowPart.CanQuery = false
	glowPart.Parent = folder

	local glow = Instance.new("PointLight")
	glow.Color = self.WINGS_COLOR
	glow.Range = 8
	glow.Brightness = 0.6
	glow.Parent = glowPart

	local particles = Instance.new("ParticleEmitter")
	particles.Color = ColorSequence.new(self.WINGS_COLOR)
	particles.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.08),
		NumberSequenceKeypoint.new(1, 0),
	})
	particles.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	particles.Lifetime = NumberRange.new(0.3, 0.8)
	particles.Rate = 15
	particles.Speed = NumberRange.new(0.5, 2)
	particles.SpreadAngle = Vector2.new(180, 180)
	particles.LightEmission = 0.9
	particles.LightInfluence = 0
	particles.Texture = "rbxassetid://6490035152"
	particles.Parent = glowPart

	table.insert(allParts, glowPart)

	local conn = self.RunService.Heartbeat:Connect(function()
		if not torso or not torso.Parent then
			self:DestroyWings()
			return
		end
		local t = tick()
		local torsoCF = torso.CFrame
		local flapBase = math.sin(t * 2.5) * 12

		for _, f in ipairs(feathers) do
			local d = f.def
			local side = d.side
			local flapAngle = flapBase * d.flapMult
			local breathe = math.sin(t * 1.5 + d.x * 0.6) * 2
			local flutter = math.sin(t * 5 + d.x * 3) * 0.8 * d.flapMult

			local localCF = CFrame.new(side * d.x, d.y, d.z)
				* CFrame.Angles(
					math.rad(breathe + flutter),
					math.rad(side * d.ry),
					math.rad(side * (flapAngle - 10))
				)

			f.part.CFrame = torsoCF * localCF
		end

		glowPart.CFrame = torsoCF * CFrame.new(0, 0.2, 0.5)
	end)

	self._wingData = {
		folder = folder,
		allParts = allParts,
		allTrails = allTrails,
		glow = glow,
		particles = particles,
		conn = conn,
	}
end

function VisualsModule:DestroyWings()
	if self._wingData then
		if self._wingData.conn then
			self._wingData.conn:Disconnect()
		end
		if self._wingData.folder and self._wingData.folder.Parent then
			self._wingData.folder:Destroy()
		end
		self._wingData = nil
	end
end

function VisualsModule:SpawnAura()
	self:DestroyAura()
	local char = self.player.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local folder = Instance.new("Folder")
	folder.Name = "ArcAura"
	folder.Parent = char

	local NUM_MAIN = 5
	local NUM_INNER = 3
	local RADIUS_MAIN = 3.2
	local RADIUS_INNER = 1.8

	local function makeOrb(name, size, transp)
		local orb = Instance.new("Part")
		orb.Name = name
		orb.Shape = Enum.PartType.Ball
		orb.Size = Vector3.new(size, size, size)
		orb.Material = Enum.Material.Neon
		orb.Color = self.AURA_COLOR
		orb.Anchored = true
		orb.CanCollide = false
		orb.CanTouch = false
		orb.CanQuery = false
		orb.CastShadow = false
		orb.Transparency = transp

		local light = Instance.new("PointLight")
		light.Color = self.AURA_COLOR
		light.Range = 4
		light.Brightness = 0.4
		light.Parent = orb

		local a0 = Instance.new("Attachment")
		a0.Position = Vector3.new(0, 0.1, 0)
		a0.Parent = orb
		local a1 = Instance.new("Attachment")
		a1.Position = Vector3.new(0, -0.1, 0)
		a1.Parent = orb
		local trail = Instance.new("Trail")
		trail.Attachment0 = a0
		trail.Attachment1 = a1
		trail.Color = ColorSequence.new(self.AURA_COLOR)
		trail.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.4),
			NumberSequenceKeypoint.new(1, 1),
		})
		trail.Lifetime = 0.5
		trail.FaceCamera = true
		trail.LightEmission = 0.7
		trail.Parent = orb

		orb.Parent = folder
		return orb
	end

	local mainOrbs = {}
	for i = 1, NUM_MAIN do
		table.insert(mainOrbs, makeOrb("AuraOrb_" .. i, 0.35, 0.25))
	end

	local innerOrbs = {}
	for i = 1, NUM_INNER do
		table.insert(innerOrbs, makeOrb("AuraInner_" .. i, 0.2, 0.4))
	end

	local rising = Instance.new("ParticleEmitter")
	rising.Name = "AuraRise"
	rising.Color = ColorSequence.new(self.AURA_COLOR)
	rising.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(0.5, 0.2),
		NumberSequenceKeypoint.new(1, 0),
	})
	rising.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.6, 0.6),
		NumberSequenceKeypoint.new(1, 1),
	})
	rising.Lifetime = NumberRange.new(0.8, 1.5)
	rising.Rate = 18
	rising.Speed = NumberRange.new(1.5, 3.5)
	rising.SpreadAngle = Vector2.new(20, 20)
	rising.RotSpeed = NumberRange.new(-60, 60)
	rising.LightEmission = 0.8
	rising.LightInfluence = 0.1
	rising.Texture = "rbxassetid://6490035152"
	rising.EmissionDirection = Enum.NormalId.Top
	rising.Parent = hrp

	self._auraData = {
		folder = folder,
		mainOrbs = mainOrbs,
		innerOrbs = innerOrbs,
		emitter = rising,
		conn = nil,
	}

	self._auraData.conn = self.RunService.Heartbeat:Connect(function()
		if not hrp or not hrp.Parent then
			self:DestroyAura()
			return
		end
		local t = tick()
		local basePos = hrp.Position

		for idx, orb in ipairs(mainOrbs) do
			if orb and orb.Parent then
				local angle = (t * 1.8) + (idx - 1) * (math.pi * 2 / NUM_MAIN)
				local yOff = math.sin(t * 2.5 + idx * 1.3) * 0.7
				local pulse = 0.35 + math.sin(t * 4 + idx) * 0.08
				orb.Size = Vector3.new(pulse, pulse, pulse)
				local x = math.cos(angle) * RADIUS_MAIN
				local z = math.sin(angle) * RADIUS_MAIN
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

		for idx, orb in ipairs(innerOrbs) do
			if orb and orb.Parent then
				local angle = -(t * 2.8) + (idx - 1) * (math.pi * 2 / NUM_INNER)
				local yOff = math.sin(t * 3.0 + idx * 2.1) * 0.4 + 1.0
				local x = math.cos(angle) * RADIUS_INNER
				local z = math.sin(angle) * RADIUS_INNER
				orb.CFrame = CFrame.new(basePos + Vector3.new(x, yOff, z))
			end
		end

	end)
end

function VisualsModule:DestroyAura()
	if self._auraData then
		if self._auraData.conn then
			self._auraData.conn:Disconnect()
		end
		if self._auraData.folder and self._auraData.folder.Parent then
			self._auraData.folder:Destroy()
		end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter:Destroy()
		end
		self._auraData = nil
	end
end

function VisualsModule:ConnectJumpCircles()
	self:DisconnectJumpCircles()

	local function hookChar(char)
		if self._jumpHumConn then
			pcall(function() self._jumpHumConn:Disconnect() end)
		end
		local hum = char:WaitForChild("Humanoid", 10)
		if not hum then return end
		self._jumpHumConn = hum.StateChanged:Connect(function(_, newState)
			if not self.JUMP_CIRCLES_ENABLED then return end
			if newState == Enum.HumanoidStateType.Jumping then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					self:SpawnJumpCircle(hrp.Position - Vector3.new(0, 3, 0))
				end
			end
		end)
	end

	if self.player.Character then
		task.spawn(function() hookChar(self.player.Character) end)
	end
	self._jumpCharConn = self.player.CharacterAdded:Connect(function(c)
		task.wait(0.3)
		hookChar(c)
	end)
end

function VisualsModule:DisconnectJumpCircles()
	if self._jumpHumConn then
		pcall(function() self._jumpHumConn:Disconnect() end)
		self._jumpHumConn = nil
	end
	if self._jumpCharConn then
		pcall(function() self._jumpCharConn:Disconnect() end)
		self._jumpCharConn = nil
	end
end

function VisualsModule:SpawnJumpCircle(position)
	local color = self.JUMP_CIRCLES_COLOR
	local folder = Instance.new("Folder")
	folder.Name = "ArcJumpCircle"
	folder.Parent = self.Workspace

	local ring = Instance.new("Part")
	ring.Shape = Enum.PartType.Cylinder
	ring.Anchored = true
	ring.CanCollide = false
	ring.CanTouch = false
	ring.CanQuery = false
	ring.CastShadow = false
	ring.Material = Enum.Material.Neon
	ring.Color = color
	ring.Size = Vector3.new(0.06, 0.8, 0.8)
	ring.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	ring.Transparency = 0.2
	ring.Parent = folder

	local inner = Instance.new("Part")
	inner.Shape = Enum.PartType.Cylinder
	inner.Anchored = true
	inner.CanCollide = false
	inner.CanTouch = false
	inner.CanQuery = false
	inner.CastShadow = false
	inner.Material = Enum.Material.Neon
	inner.Color = color
	inner.Size = Vector3.new(0.04, 0.4, 0.4)
	inner.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	inner.Transparency = 0
	inner.Parent = folder

	local spark = Instance.new("Part")
	spark.Anchored = true
	spark.CanCollide = false
	spark.CanQuery = false
	spark.Transparency = 1
	spark.Size = Vector3.new(1, 1, 1)
	spark.CFrame = CFrame.new(position)
	spark.Parent = folder

	local emitter = Instance.new("ParticleEmitter")
	emitter.Color = ColorSequence.new(color)
	emitter.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.15),
		NumberSequenceKeypoint.new(1, 0),
	})
	emitter.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	emitter.Lifetime = NumberRange.new(0.3, 0.6)
	emitter.Rate = 0
	emitter.Speed = NumberRange.new(3, 8)
	emitter.SpreadAngle = Vector2.new(360, 30)
	emitter.LightEmission = 1
	emitter.LightInfluence = 0
	emitter.Texture = "rbxassetid://6490035152"
	emitter.Parent = spark
	emitter:Emit(20)

	self.TweenService:Create(ring,
		TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.06, 7, 7), Transparency = 1}
	):Play()
	self.TweenService:Create(inner,
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.04, 4, 4), Transparency = 1}
	):Play()

	self.Debris:AddItem(folder, 1)
end

function VisualsModule:PlaySparkleFX(position)
	local white = Color3.fromRGB(255, 255, 255)
	local folder = Instance.new("Folder")
	folder.Name = "ArcSparkleFX"
	folder.Parent = self.Workspace

	local base = Instance.new("Part")
	base.Anchored = true
	base.CanCollide = false
	base.CanQuery = false
	base.CanTouch = false
	base.Transparency = 1
	base.Size = Vector3.new(1, 1, 1)
	base.CFrame = CFrame.new(position)
	base.Parent = folder

	local burst = Instance.new("ParticleEmitter")
	burst.Color = ColorSequence.new(white)
	burst.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.5),
		NumberSequenceKeypoint.new(0.5, 0.3),
		NumberSequenceKeypoint.new(1, 0),
	})
	burst.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(0.6, 0.2),
		NumberSequenceKeypoint.new(1, 1),
	})
	burst.Lifetime = NumberRange.new(0.4, 0.9)
	burst.Speed = NumberRange.new(10, 22)
	burst.SpreadAngle = Vector2.new(360, 360)
	burst.Rate = 0
	burst.RotSpeed = NumberRange.new(-200, 200)
	burst.Rotation = NumberRange.new(-180, 180)
	burst.LightEmission = 1
	burst.LightInfluence = 0
	burst.Texture = "rbxassetid://6490035152"
	burst.Parent = base
	burst:Emit(45)

	local shimmer = Instance.new("ParticleEmitter")
	shimmer.Color = ColorSequence.new(white)
	shimmer.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.15),
		NumberSequenceKeypoint.new(1, 0),
	})
	shimmer.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	shimmer.Lifetime = NumberRange.new(0.6, 1.2)
	shimmer.Speed = NumberRange.new(2, 6)
	shimmer.SpreadAngle = Vector2.new(360, 360)
	shimmer.Rate = 0
	shimmer.LightEmission = 1
	shimmer.LightInfluence = 0
	shimmer.Texture = "rbxassetid://6490035152"
	shimmer.EmissionDirection = Enum.NormalId.Top
	shimmer.Parent = base
	shimmer:Emit(20)

	local flash = Instance.new("Part")
	flash.Shape = Enum.PartType.Ball
	flash.Anchored = true
	flash.CanCollide = false
	flash.CanQuery = false
	flash.CastShadow = false
	flash.Material = Enum.Material.Neon
	flash.Color = white
	flash.Size = Vector3.new(1, 1, 1)
	flash.CFrame = CFrame.new(position)
	flash.Transparency = 0.3
	flash.Parent = folder

	self.TweenService:Create(flash,
		TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(5, 5, 5), Transparency = 1}
	):Play()

	local light = Instance.new("PointLight")
	light.Color = white
	light.Range = 18
	light.Brightness = 2.5
	light.Parent = base
	self.TweenService:Create(light, TweenInfo.new(0.6), {Range = 0, Brightness = 0}):Play()

	self.Debris:AddItem(folder, 2)
end

function VisualsModule:PlayRingFX(position, victimChar)
	local white = Color3.fromRGB(255, 255, 255)
	local folder = Instance.new("Folder")
	folder.Name = "ArcRingFX"
	folder.Parent = self.Workspace

	local rings = {}
	local ringConfigs = {
		{tiltX = 0,  tiltZ = 0,  speed = 4.0, startSize = 3},
		{tiltX = 60, tiltZ = 30, speed = 3.2, startSize = 3.5},
		{tiltX = 30, tiltZ = 70, speed = 5.0, startSize = 2.5},
	}

	for i, cfg in ipairs(ringConfigs) do
		local ring = Instance.new("Part")
		ring.Name = "Ring_" .. i
		ring.Shape = Enum.PartType.Cylinder
		ring.Anchored = true
		ring.CanCollide = false
		ring.CanQuery = false
		ring.CanTouch = false
		ring.CastShadow = false
		ring.Material = Enum.Material.Neon
		ring.Color = white
		ring.Size = Vector3.new(0.06, cfg.startSize, cfg.startSize)
		ring.Transparency = 0.15
		ring.Parent = folder
		table.insert(rings, {part = ring, cfg = cfg})
	end

	local light = Instance.new("PointLight")
	light.Color = white
	light.Range = 22
	light.Brightness = 2.5
	light.Parent = rings[1].part

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = white
					self.TweenService:Create(part,
						TweenInfo.new(1.8, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	local startT = tick()
	local conn
	conn = self.RunService.Heartbeat:Connect(function()
		local elapsed = tick() - startT
		if elapsed > 2.5 then
			conn:Disconnect()
			return
		end

		for _, r in ipairs(rings) do
			local ring = r.part
			local cfg = r.cfg
			if ring and ring.Parent then
				local rot = elapsed * cfg.speed
				local sz = cfg.startSize + elapsed * 1.5
				ring.Size = Vector3.new(0.06, sz, sz)
				ring.CFrame = CFrame.new(position)
					* CFrame.Angles(math.rad(cfg.tiltX), rot, math.rad(cfg.tiltZ))
					* CFrame.Angles(0, 0, math.rad(90))
				ring.Transparency = 0.15 + math.clamp((elapsed - 1.5) / 1.0, 0, 0.85)
			end
		end
	end)

	self.TweenService:Create(light, TweenInfo.new(2.0), {Range = 0, Brightness = 0}):Play()

	self.Debris:AddItem(folder, 3.5)
end

function VisualsModule:PlayBeamFX(position, victimChar)
	local white = Color3.fromRGB(255, 255, 255)
	local folder = Instance.new("Folder")
	folder.Name = "ArcBeamFX"
	folder.Parent = self.Workspace

	local BEAM_HEIGHT = 60
	local midPos = position + Vector3.new(0, BEAM_HEIGHT / 2, 0)

	local beam = Instance.new("Part")
	beam.Name = "BeamOuter"
	beam.Anchored = true
	beam.CanCollide = false
	beam.CanQuery = false
	beam.CanTouch = false
	beam.CastShadow = false
	beam.Material = Enum.Material.Neon
	beam.Color = white
	beam.Size = Vector3.new(2.5, BEAM_HEIGHT, 2.5)
	beam.CFrame = CFrame.new(midPos)
	beam.Transparency = 0.3
	beam.Parent = folder

	local inner = Instance.new("Part")
	inner.Name = "BeamInner"
	inner.Anchored = true
	inner.CanCollide = false
	inner.CanQuery = false
	inner.CanTouch = false
	inner.CastShadow = false
	inner.Material = Enum.Material.Neon
	inner.Color = white
	inner.Size = Vector3.new(0.8, BEAM_HEIGHT, 0.8)
	inner.CFrame = CFrame.new(midPos)
	inner.Transparency = 0
	inner.Parent = folder

	local light = Instance.new("PointLight")
	light.Color = white
	light.Range = 35
	light.Brightness = 4
	light.Parent = inner

	local impactRing = Instance.new("Part")
	impactRing.Shape = Enum.PartType.Cylinder
	impactRing.Anchored = true
	impactRing.CanCollide = false
	impactRing.CanQuery = false
	impactRing.CanTouch = false
	impactRing.CastShadow = false
	impactRing.Material = Enum.Material.Neon
	impactRing.Color = white
	impactRing.Size = Vector3.new(0.06, 2, 2)
	impactRing.CFrame = CFrame.new(position) * CFrame.Angles(0, 0, math.rad(90))
	impactRing.Transparency = 0.2
	impactRing.Parent = folder

	self.TweenService:Create(impactRing,
		TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
		{Size = Vector3.new(0.06, 14, 14), Transparency = 1}
	):Play()

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = white
					self.TweenService:Create(part,
						TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	task.delay(0.4, function()
		if beam and beam.Parent then
			self.TweenService:Create(beam,
				TweenInfo.new(0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Size = Vector3.new(0.2, BEAM_HEIGHT, 0.2), Transparency = 1}
			):Play()
		end
		if inner and inner.Parent then
			self.TweenService:Create(inner,
				TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
				{Transparency = 1}
			):Play()
		end
		if light then
			self.TweenService:Create(light, TweenInfo.new(0.7), {Range = 0, Brightness = 0}):Play()
		end
	end)

	self.Debris:AddItem(folder, 2)
end

function VisualsModule:PlayInfernoFX(position, victimChar)
	local white = Color3.fromRGB(255, 255, 255)
	local folder = Instance.new("Folder")
	folder.Name = "ArcInfernoFX"
	folder.Parent = self.Workspace

	local baseP = Instance.new("Part")
	baseP.Anchored = true
	baseP.CanCollide = false
	baseP.CanQuery = false
	baseP.CanTouch = false
	baseP.Transparency = 1
	baseP.Size = Vector3.new(1, 1, 1)
	baseP.CFrame = CFrame.new(position)
	baseP.Parent = folder

	local fire = Instance.new("ParticleEmitter")
	fire.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, white),
		ColorSequenceKeypoint.new(0.5, Color3.fromRGB(220, 220, 235)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 180, 200)),
	})
	fire.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.4),
		NumberSequenceKeypoint.new(0.3, 2.0),
		NumberSequenceKeypoint.new(0.7, 1.5),
		NumberSequenceKeypoint.new(1, 0),
	})
	fire.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.15),
		NumberSequenceKeypoint.new(0.5, 0.3),
		NumberSequenceKeypoint.new(1, 1),
	})
	fire.Lifetime = NumberRange.new(0.3, 0.7)
	fire.Rate = 60
	fire.Speed = NumberRange.new(5, 12)
	fire.SpreadAngle = Vector2.new(20, 20)
	fire.RotSpeed = NumberRange.new(-100, 100)
	fire.Rotation = NumberRange.new(-180, 180)
	fire.LightEmission = 1
	fire.LightInfluence = 0
	fire.Texture = "rbxassetid://6490035152"
	fire.EmissionDirection = Enum.NormalId.Top
	fire.Parent = baseP

	local embers = Instance.new("ParticleEmitter")
	embers.Color = ColorSequence.new(white)
	embers.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.1),
		NumberSequenceKeypoint.new(1, 0),
	})
	embers.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),
		NumberSequenceKeypoint.new(1, 1),
	})
	embers.Lifetime = NumberRange.new(0.5, 1.2)
	embers.Rate = 25
	embers.Speed = NumberRange.new(5, 12)
	embers.SpreadAngle = Vector2.new(45, 45)
	embers.LightEmission = 1
	embers.LightInfluence = 0
	embers.Texture = "rbxassetid://6490035152"
	embers.EmissionDirection = Enum.NormalId.Top
	embers.Parent = baseP

	local light = Instance.new("PointLight")
	light.Color = white
	light.Range = 25
	light.Brightness = 3
	light.Parent = baseP

	if victimChar then
		for _, part in pairs(victimChar:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function()
					part.Material = Enum.Material.Neon
					part.Color = white
					self.TweenService:Create(part,
						TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
						{Transparency = 1}
					):Play()
				end)
			end
		end
	end

	task.delay(0.8, function()
		if fire then fire.Rate = 0 end
		if embers then embers.Rate = 0 end
		if light and light.Parent then
			self.TweenService:Create(light, TweenInfo.new(0.8), {Range = 0, Brightness = 0}):Play()
		end
	end)

	self.Debris:AddItem(folder, 2.5)
end

function VisualsModule:FixFxInstance(fx, cf)
	if fx:IsA("Model") then
		for _, d in ipairs(fx:GetDescendants()) do
			if d:IsA("BasePart") then
				d.Anchored = true
				d.CanCollide = false
				d.CanQuery = false
				d.CanTouch = false
			end
		end
		fx:PivotTo(cf)
	elseif fx:IsA("BasePart") then
		fx.Anchored = true
		fx.CanCollide = false
		fx.CanQuery = false
		fx.CanTouch = false
		fx.CFrame = cf
	end
end

function VisualsModule:RecolorParticles(root, color)
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Color = ColorSequence.new(color)
		end
	end
end

function VisualsModule:PlayImpactFX(position)
	local template = self.FX_ROOT:FindFirstChild("ImpactFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(0.15, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:PlayCustomFX(position)
	local template = self.FX_ROOT:FindFirstChild("CustomFX")
	if not template then return end

	local fx = template:Clone()
	self:FixFxInstance(fx, CFrame.new(position))
	fx.Parent = self.Workspace

	self:RecolorParticles(fx, self.KILLFX_COLOR)

	local light = fx:FindFirstChild("PointLight") or fx:FindFirstChildWhichIsA("PointLight", true)
	if light then
		light.Color = self.KILLFX_LIGHT_COLOR
		light.Range = 0
		light.Brightness = self.KILLFX_LIGHT_BRIGHTNESS
		light.Enabled = true

		local tIn = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = self.KILLFX_LIGHT_RANGE })
		local tOut = self.TweenService:Create(light, TweenInfo.new(self.KILLFX_CUSTOM_DURATION * 0.5, Enum.EasingStyle.Quad), { Range = 0 })

		tIn:Play()
		tIn.Completed:Once(function()
			tOut:Play()
		end)
	end

	for _, d in ipairs(fx:GetDescendants()) do
		if d:IsA("ParticleEmitter") then
			d.Enabled = true
		end
	end

	task.delay(self.KILLFX_CUSTOM_DURATION, function()
		if fx and fx.Parent then
			for _, d in ipairs(fx:GetDescendants()) do
				if d:IsA("ParticleEmitter") then
					d.Enabled = false
				end
			end
		end
	end)

	self.Debris:AddItem(fx, 2)
end

function VisualsModule:SetupKillFXListener()
	local InfEvent = self.ReplicatedStorage:WaitForChild("inf", 10)
	if InfEvent then
		InfEvent.OnClientEvent:Connect(function(killedPlayerName)
			if not self.KILLFX_ENABLED then return end

			local killedPlayer = self.Players:FindFirstChild(killedPlayerName)
			if not killedPlayer then return end

			local char = killedPlayer.Character
			if not char then return end

			local head = char:FindFirstChild("Head")
			if not head then return end

			local pos = head.Position
			if self.KILLFX_TYPE == "Sparkle" then
				self:PlaySparkleFX(pos)
			elseif self.KILLFX_TYPE == "Ring" then
				self:PlayRingFX(pos, char)
			elseif self.KILLFX_TYPE == "Beam" then
				self:PlayBeamFX(pos, char)
			elseif self.KILLFX_TYPE == "Inferno" then
				self:PlayInfernoFX(pos, char)
			end

		end)
	end

	task.spawn(function()
		local htl = self.ReplicatedStorage:WaitForChild("htl", 10)
		if not htl then return end

		htl.OnClientEvent:Connect(function(hitType, info)
			if hitType == "Hit" then
				self:PlayHitSound()
				self:FlashHitMarker()
			end

			if hitType == "Hit" and info and self.KILLIMAGE_ENABLED then
				local dmg = info.damage or 0
				if dmg > 99 then
					self:PlayKillImage()
				end
			end

			if self.HITLOG_ENABLED then
				self:ShowHitlog(hitType, info)
			end
		end)
	end)
end

function VisualsModule:IsFakeLagEnabledFallback()
	if typeof(self.IsFakeLagEnabled) == "function" then
		local ok, v = pcall(self.IsFakeLagEnabled)
		if ok then return v == true end
	end
	if _G.ConfigSystem and _G.ConfigSystem.settings then
		return _G.ConfigSystem.settings["FakeLag"] == true
	end
	return false
end

function VisualsModule:SetupBacktrackGhost()
	local backtrackRemote = self.ReplicatedStorage:WaitForChild("btl")
	local lastSend = 0

	local ghostsFolder = self.Workspace:FindFirstChild("BacktrackGhosts") or Instance.new("Folder", self.Workspace)
	ghostsFolder.Name = "BacktrackGhosts"
	self._ghostsFolder = ghostsFolder

	self.RunService.Heartbeat:Connect(function()
		local now = tick()
		local dt = now - self._hbLast
		self._hbLast = now
		self._ghostDt = dt

		if self.ghostModel and now > self.ghostExpireAt then
			self:ClearBacktrackGhost()
		end

		if self.BACKTRACK_GHOST_ENABLED and self.player.Character then
			local hrp = self.player.Character:FindFirstChild("HumanoidRootPart")
			if hrp then
				if now - lastSend > 0.05 then
					lastSend = now
					backtrackRemote:FireServer(self:IsFakeLagEnabledFallback())
				end
			end
		end
	end)

	backtrackRemote.OnClientEvent:Connect(function(cframe, isFakelag, ping)
		if not self.BACKTRACK_GHOST_ENABLED then return end

		if not isFakelag and ping then
			local char = self.player.Character
			if char then
				local hrp = char:FindFirstChild("HumanoidRootPart")
				if hrp then
					local velocity = hrp.AssemblyLinearVelocity
					local pingOffset = velocity * (ping * 0.5)
					cframe = hrp.CFrame - pingOffset
				end
			end
		end

		self:UpdateBacktrackGhostPose(cframe, isFakelag)
	end)

	self.player.CharacterAdded:Connect(function()
		self:ClearBacktrackGhost()
	end)

	self.player.CharacterRemoving:Connect(function()
		self:ClearBacktrackGhost()
	end)
end

function VisualsModule:ClearBacktrackGhost()
	if self.ghostModel then
		self.ghostModel:Destroy()
		self.ghostModel = nil
		table.clear(self.ghostParts)
		table.clear(self.ghostLastCFrames)
	end
	self.sourceCharacter = nil
	self.lastFakeLagState = nil
end

function VisualsModule:CreateBacktrackGhost()
	local srcChar = self.player.Character
	if not srcChar then return nil end

	local root = srcChar:FindFirstChild("HumanoidRootPart")
	if not root then return nil end

	srcChar.Archivable = true
	local ghost = srcChar:Clone()
	srcChar.Archivable = false
	if not ghost then return nil end

	ghost.Name = self.player.Name .. "_BacktrackGhost"

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Script") or v:IsA("LocalScript") or v:IsA("Sound")
			or v:IsA("BillboardGui") or v:IsA("Humanoid")
			or v:IsA("AlignPosition") or v:IsA("AlignOrientation")
			or v:IsA("BodyMover") or v:IsA("BodyGyro") or v:IsA("BodyVelocity")
			or v:IsA("BodyPosition") or v:IsA("BodyForce") or v:IsA("VectorForce")
			or v:IsA("LineForce") or v:IsA("Animator") then
			v:Destroy()
		end
	end

	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("Motor6D") or v:IsA("Weld") or v:IsA("WeldConstraint")
			or v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint")
			or v:IsA("Constraint") or v:IsA("JointInstance") then
			v:Destroy()
		end
	end

	local hasParts = false
	for _, v in pairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			hasParts = true
			v.Anchored = true
			v.CanCollide = false
			v.CanTouch = false
			v.CanQuery = false
			v.Massless = true
			v.Material = Enum.Material.ForceField
			v.Transparency = self.GHOST_BASE_TRANSPARENCY
			v.Color = self.BACKTRACK_GHOST_COLOR
			v.CastShadow = false

			if v.Name == "Head" then
				local face = v:FindFirstChild("face")
				if face then face:Destroy() end
			end
		end
	end

	if not hasParts then
		ghost:Destroy()
		return nil
	end

	table.clear(self.ghostParts)
	for _, v in ipairs(ghost:GetDescendants()) do
		if v:IsA("BasePart") then
			table.insert(self.ghostParts, v)
		end
	end

	ghost.Parent = self._ghostsFolder
	return ghost
end

function VisualsModule:UpdateBacktrackGhostPose(targetCFrame, isFakelag)
	if not self.BACKTRACK_GHOST_ENABLED then return end

	local srcChar = self.player.Character
	if not srcChar then return end

	local humanoid = srcChar:FindFirstChild("Humanoid")
	if humanoid and humanoid.Health <= 0 then
		self:ClearBacktrackGhost()
		return
	end

	if (not self.ghostModel) or (self.sourceCharacter ~= srcChar) or (self.lastFakeLagState ~= isFakelag) or (not self.ghostModel.Parent) then
		self:ClearBacktrackGhost()
		self.ghostModel = self:CreateBacktrackGhost()
		if self.ghostModel then
			self.sourceCharacter = srcChar
			self.lastFakeLagState = isFakelag
		else
			return
		end
	end

	local srcRoot = srcChar:FindFirstChild("HumanoidRootPart")
	if not srcRoot then return end

	local currentRootCFrame = srcRoot.CFrame
	local offset = targetCFrame * currentRootCFrame:Inverse()

	local dt = tonumber(self._ghostDt) or (1 / 60)
	local alpha = math.clamp(self.GHOST_SMOOTH_SPEED * dt, 0, 1)

for _, ghostPart in ipairs(self.ghostParts) do
	local srcPart = srcChar:FindFirstChild(ghostPart.Name, true)
	if srcPart then
		local targetCF = offset * srcPart.CFrame
		local lastCF = self.ghostLastCFrames[ghostPart] or ghostPart.CFrame
		local newCF = lastCF:Lerp(targetCF, alpha)
		ghostPart.CFrame = newCF
		self.ghostLastCFrames[ghostPart] = newCF

		local dist = (newCF.Position - srcPart.Position).Magnitude

		if dist < self.GHOST_FADE_RADIUS then
			local k = math.clamp(1 - (dist / self.GHOST_FADE_RADIUS), 0, 1)
			k = k ^ self.GHOST_FADE_POWER
			ghostPart.Transparency = math.clamp(
				self.GHOST_BASE_TRANSPARENCY + k * (1 - self.GHOST_BASE_TRANSPARENCY),
				0,
				1
			)
		else
			ghostPart.Transparency = self.GHOST_BASE_TRANSPARENCY
		end
	end
end

	self.ghostExpireAt = tick() + self.BACKTRACK_GHOST_DURATION
end

function VisualsModule:SnapshotFirstEffect(className)
	local inst = self.Lighting:FindFirstChildOfClass(className)
	if not inst then return nil end
	local c = inst:Clone()
	c.Name = "NemesisOriginal_" .. className
	return c
end

function VisualsModule:WipeClass(className)
	for _, inst in ipairs(self.Lighting:GetDescendants()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
	for _, inst in ipairs(self.Lighting:GetChildren()) do
		if inst.ClassName == className then
			inst:Destroy()
		end
	end
end

function VisualsModule:ApplySingleEffect(className, enabled, applyFn)
	if enabled then
		self:WipeClass(className)
		local fx = Instance.new(className)
		fx.Name = "Nemesis_" .. className
		fx.Parent = self.Lighting
		applyFn(fx)
	else
		self:WipeClass(className)
		local original = self.ORIGINAL_EFFECTS[className]
		if original then
			original:Clone().Parent = self.Lighting
		end
	end
end

function VisualsModule:UpdateAtmosphere()
	self:ApplySingleEffect("Atmosphere", self.ATMOSPHERE_ENABLED, function(atmosphere)
		atmosphere.Density = self.ATMOSPHERE_DENSITY
		atmosphere.Offset = self.ATMOSPHERE_OFFSET
		atmosphere.Color = self.ATMOSPHERE_COLOR
		atmosphere.Decay = self.ATMOSPHERE_DECAY
		atmosphere.Glare = self.ATMOSPHERE_GLARE
		atmosphere.Haze = self.ATMOSPHERE_HAZE
	end)
end

function VisualsModule:SetAtmosphereEnabled(value)
	self.ATMOSPHERE_ENABLED = value
	self:UpdateAtmosphere()
end

function VisualsModule:SetAtmosphereDensity(value)
	self.ATMOSPHERE_DENSITY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereOffset(value)
	self.ATMOSPHERE_OFFSET = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereColor(value)
	self.ATMOSPHERE_COLOR = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereDecay(value)
	self.ATMOSPHERE_DECAY = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereGlare(value)
	self.ATMOSPHERE_GLARE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:SetAtmosphereHaze(value)
	self.ATMOSPHERE_HAZE = value
	if self.ATMOSPHERE_ENABLED then self:UpdateAtmosphere() end
end

function VisualsModule:UpdateBloom()
	self:ApplySingleEffect("BloomEffect", self.BLOOM_ENABLED, function(bloom)
		bloom.Enabled = true
		bloom.Intensity = self.BLOOM_INTENSITY
		bloom.Size = self.BLOOM_SIZE
		bloom.Threshold = self.BLOOM_THRESHOLD
	end)
end

function VisualsModule:SetBloomEnabled(value)
	self.BLOOM_ENABLED = value
	self:UpdateBloom()
end

function VisualsModule:SetBloomIntensity(value)
	self.BLOOM_INTENSITY = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomSize(value)
	self.BLOOM_SIZE = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:SetBloomThreshold(value)
	self.BLOOM_THRESHOLD = value
	if self.BLOOM_ENABLED then self:UpdateBloom() end
end

function VisualsModule:UpdateColorCorrection()
	self:ApplySingleEffect("ColorCorrectionEffect", self.COLOR_CORRECTION_ENABLED, function(cc)
		cc.Brightness = self.COLOR_CORRECTION_BRIGHTNESS
		cc.Contrast = self.COLOR_CORRECTION_CONTRAST
		cc.Saturation = self.COLOR_CORRECTION_SATURATION
		cc.TintColor = self.COLOR_CORRECTION_TINT
	end)
end

function VisualsModule:SetColorCorrectionEnabled(value)
	self.COLOR_CORRECTION_ENABLED = value
	self:UpdateColorCorrection()
end

function VisualsModule:SetColorCorrectionBrightness(value)
	self.COLOR_CORRECTION_BRIGHTNESS = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionContrast(value)
	self.COLOR_CORRECTION_CONTRAST = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionSaturation(value)
	self.COLOR_CORRECTION_SATURATION = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetColorCorrectionTint(value)
	self.COLOR_CORRECTION_TINT = value
	if self.COLOR_CORRECTION_ENABLED then self:UpdateColorCorrection() end
end

function VisualsModule:SetHitlogEnabled(value)
	self.HITLOG_ENABLED = value
	if self.hitlogContainer then
		self.hitlogContainer.Visible = value
	end
end

function VisualsModule:SetHitSoundEnabled(value)
	self.HITSOUND_ENABLED = value
end

function VisualsModule:SetHitSoundPreset(value)
	self.HITSOUND_PRESET = value
end

function VisualsModule:SetHitSoundVolume(value)
	self.HITSOUND_VOLUME = value
end

function VisualsModule:SetTracerEnabled(value)
	self.TRACER_ENABLED = value
end

function VisualsModule:SetTracerColor(value)
	self.TRACER_COLOR = value
end

function VisualsModule:SetTracerLifetime(value)
	self.TRACER_LIFETIME = value
end

function VisualsModule:SetTracerWidth(value)
	self.TRACER_WIDTH = value
end

function VisualsModule:SetTracerStyle(value)
	self.TRACER_STYLE = value
end

function VisualsModule:SetTracerNeon(value)
	self.TRACER_NEON = value
	if value then
		self.TRACER_BRIGHTNESS = 40
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0
	else
		self.TRACER_BRIGHTNESS = 20
		self.TRACER_LIGHTEMISSION = 1
		self.TRACER_LIGHTINFLUENCE = 0.95
	end
end

function VisualsModule:SetChinaHatEnabled(value)
	self.CHINA_HAT_ENABLED = value
	if value then
		self:SpawnChinaHat()
	else
		self:DestroyChinaHat()
	end
end

function VisualsModule:SetChinaHatColor(value)
	self.CHINA_HAT_COLOR = value
	for _, p in ipairs(self._chinaHatParts) do
		if p and p.Parent then p.Color = value end
	end
end

function VisualsModule:SetWingsEnabled(value)
	self.WINGS_ENABLED = value
	if value then
		self:SpawnWings()
	else
		self:DestroyWings()
	end
end

function VisualsModule:SetWingsColor(value)
	self.WINGS_COLOR = value
	if self._wingData then
		for _, p in ipairs(self._wingData.allParts) do
			if p and p.Parent then
				if not p:IsA("Part") or p.Transparency < 1 then
					pcall(function() p.Color = value end)
				end
			end
		end
		for _, trail in ipairs(self._wingData.allTrails) do
			trail.Color = ColorSequence.new(value)
		end
		if self._wingData.glow then self._wingData.glow.Color = value end
		if self._wingData.particles then
			self._wingData.particles.Color = ColorSequence.new(value)
		end
	end
end

function VisualsModule:SetAuraEnabled(value)
	self.AURA_ENABLED = value
	if value then
		self:SpawnAura()
	else
		self:DestroyAura()
	end
end

function VisualsModule:SetAuraColor(value)
	self.AURA_COLOR = value
	if self._auraData then
		local function colorOrb(orb)
			if orb and orb.Parent then
				orb.Color = value
				local light = orb:FindFirstChildOfClass("PointLight")
				if light then light.Color = value end
				local trail = orb:FindFirstChildOfClass("Trail")
				if trail then trail.Color = ColorSequence.new(value) end
			end
		end
		for _, orb in ipairs(self._auraData.mainOrbs) do colorOrb(orb) end
		for _, orb in ipairs(self._auraData.innerOrbs) do colorOrb(orb) end
		if self._auraData.emitter and self._auraData.emitter.Parent then
			self._auraData.emitter.Color = ColorSequence.new(value)
		end
	end
end

function VisualsModule:SetJumpCirclesEnabled(value)
	self.JUMP_CIRCLES_ENABLED = value
	if value then
		self:ConnectJumpCircles()
	else
		self:DisconnectJumpCircles()
	end
end

function VisualsModule:SetJumpCirclesColor(value)
	self.JUMP_CIRCLES_COLOR = value
end

function VisualsModule:SetHitMarkerEnabled(value)
	self.HIT_MARKER_ENABLED = value
end


function VisualsModule:SetWallbangEnabled(value)
	self.WALLBANG_ENABLED = value
end

function VisualsModule:SetWallbangEntryColor(value)
	self.WALLBANG_ENTRY_COLOR = value
end

function VisualsModule:SetWallbangExitColor(value)
	self.WALLBANG_EXIT_COLOR = value
end

function VisualsModule:SetWallbangMarkerSize(value)
	if typeof(value) == "number" then
		self.WALLBANG_MARKER_SIZE = Vector3.new(value, value, value)
	elseif typeof(value) == "Vector3" then
		self.WALLBANG_MARKER_SIZE = value
	end
end

function VisualsModule:SetWallbangLifetime(value)
	self.WALLBANG_LIFETIME = value
end

function VisualsModule:SetKillFXEnabled(value)
	self.KILLFX_ENABLED = value
end

function VisualsModule:SetKillFXType(value)
	self.KILLFX_TYPE = value
end

function VisualsModule:SetKillFXColor(value)
	self.KILLFX_COLOR = value
end

function VisualsModule:SetKillFXLightColor(value)
	self.KILLFX_LIGHT_COLOR = value
end

function VisualsModule:SetKillFXDuration(value)
	self.KILLFX_CUSTOM_DURATION = value
end

function VisualsModule:SetKillFXLightRange(value)
	self.KILLFX_LIGHT_RANGE = value
end

function VisualsModule:SetKillFXLightBrightness(value)
	self.KILLFX_LIGHT_BRIGHTNESS = value
end

function VisualsModule:SetOffscreenEnabled(value)
	self.OFFSCREEN_ENABLED = value
end

function VisualsModule:SetOffscreenColor(value)
	self.OFFSCREEN_COLOR = value
end

function VisualsModule:SetBacktrackGhostEnabled(value)
	self.BACKTRACK_GHOST_ENABLED = value
	if not value then
		self:ClearBacktrackGhost()
	end
end

function VisualsModule:SetBacktrackGhostColor(value)
	self.BACKTRACK_GHOST_COLOR = value
	for _, p in ipairs(self.ghostParts) do
		p.Color = value
		p.Transparency = self.GHOST_BASE_TRANSPARENCY
	end
end

function VisualsModule:SetBacktrackGhostDuration(value)
	self.BACKTRACK_GHOST_DURATION = value
end

function VisualsModule:SetKillImageEnabled(value)
	self.KILLIMAGE_ENABLED = value
end

function VisualsModule:SetKillImageColor(value)
	self.KILLIMAGE_COLOR = value
end

function VisualsModule:SetKillImageMaxAlpha(value)
	self.KILLIMAGE_MAX_ALPHA = value
end

function VisualsModule:GetSettings()
	local function colorToTable(c)
		return { math.floor(c.R * 255), math.floor(c.G * 255), math.floor(c.B * 255) }
	end

	return {
		HITLOG_ENABLED = self.HITLOG_ENABLED,
		HITSOUND_ENABLED = self.HITSOUND_ENABLED,
		HITSOUND_PRESET = self.HITSOUND_PRESET,
		HITSOUND_VOLUME = self.HITSOUND_VOLUME,

		OFFSCREEN_ENABLED = self.OFFSCREEN_ENABLED,
		OFFSCREEN_COLOR = colorToTable(self.OFFSCREEN_COLOR),

		WALLBANG_ENABLED = self.WALLBANG_ENABLED,
		WALLBANG_ENTRY_COLOR = colorToTable(self.WALLBANG_ENTRY_COLOR),
		WALLBANG_EXIT_COLOR = colorToTable(self.WALLBANG_EXIT_COLOR),
		WALLBANG_MARKER_SIZE = self.WALLBANG_MARKER_SIZE.X,
		WALLBANG_LIFETIME = self.WALLBANG_LIFETIME,

		KILLFX_ENABLED = self.KILLFX_ENABLED,
		KILLFX_TYPE = self.KILLFX_TYPE,
		KILLFX_COLOR = colorToTable(self.KILLFX_COLOR),
		KILLFX_LIGHT_COLOR = colorToTable(self.KILLFX_LIGHT_COLOR),
		KILLFX_CUSTOM_DURATION = self.KILLFX_CUSTOM_DURATION,
		KILLFX_LIGHT_RANGE = self.KILLFX_LIGHT_RANGE,
		KILLFX_LIGHT_BRIGHTNESS = self.KILLFX_LIGHT_BRIGHTNESS,

		KILLIMAGE_ENABLED = self.KILLIMAGE_ENABLED,
		KILLIMAGE_COLOR = colorToTable(self.KILLIMAGE_COLOR),
		KILLIMAGE_MAX_ALPHA = self.KILLIMAGE_MAX_ALPHA,

		BACKTRACK_GHOST_ENABLED = self.BACKTRACK_GHOST_ENABLED,
		BACKTRACK_GHOST_COLOR = colorToTable(self.BACKTRACK_GHOST_COLOR),
		BACKTRACK_GHOST_DURATION = self.BACKTRACK_GHOST_DURATION,

		TRACER_ENABLED = self.TRACER_ENABLED,
		TRACER_COLOR = colorToTable(self.TRACER_COLOR),
		TRACER_LIFETIME = self.TRACER_LIFETIME,
		TRACER_WIDTH = self.TRACER_WIDTH,
		TRACER_NEON = self.TRACER_NEON,
		TRACER_STYLE = self.TRACER_STYLE,

		CHINA_HAT_ENABLED = self.CHINA_HAT_ENABLED,
		CHINA_HAT_COLOR = colorToTable(self.CHINA_HAT_COLOR),
		WINGS_ENABLED = self.WINGS_ENABLED,
		WINGS_COLOR = colorToTable(self.WINGS_COLOR),
		AURA_ENABLED = self.AURA_ENABLED,
		AURA_COLOR = colorToTable(self.AURA_COLOR),
		JUMP_CIRCLES_ENABLED = self.JUMP_CIRCLES_ENABLED,
		JUMP_CIRCLES_COLOR = colorToTable(self.JUMP_CIRCLES_COLOR),

		HIT_MARKER_ENABLED = self.HIT_MARKER_ENABLED,

		ATMOSPHERE_ENABLED = self.ATMOSPHERE_ENABLED,
		ATMOSPHERE_DENSITY = self.ATMOSPHERE_DENSITY,
		ATMOSPHERE_OFFSET = self.ATMOSPHERE_OFFSET,
		ATMOSPHERE_COLOR = colorToTable(self.ATMOSPHERE_COLOR),
		ATMOSPHERE_DECAY = colorToTable(self.ATMOSPHERE_DECAY),
		ATMOSPHERE_GLARE = self.ATMOSPHERE_GLARE,
		ATMOSPHERE_HAZE = self.ATMOSPHERE_HAZE,

		BLOOM_ENABLED = self.BLOOM_ENABLED,
		BLOOM_INTENSITY = self.BLOOM_INTENSITY,
		BLOOM_SIZE = self.BLOOM_SIZE,
		BLOOM_THRESHOLD = self.BLOOM_THRESHOLD,

		COLOR_CORRECTION_ENABLED = self.COLOR_CORRECTION_ENABLED,
		COLOR_CORRECTION_BRIGHTNESS = self.COLOR_CORRECTION_BRIGHTNESS,
		COLOR_CORRECTION_CONTRAST = self.COLOR_CORRECTION_CONTRAST,
		COLOR_CORRECTION_SATURATION = self.COLOR_CORRECTION_SATURATION,
		COLOR_CORRECTION_TINT = colorToTable(self.COLOR_CORRECTION_TINT),
	}
end

function VisualsModule:ApplySettings(settings)
	if not settings then return end

	local function toColor3(arr)
		if type(arr) == "table" and #arr >= 3 then
			return Color3.fromRGB(arr[1], arr[2], arr[3])
		end
		return nil
	end

	if settings.HITLOG_ENABLED ~= nil then self:SetHitlogEnabled(settings.HITLOG_ENABLED) end
	if settings.HITSOUND_ENABLED ~= nil then self:SetHitSoundEnabled(settings.HITSOUND_ENABLED) end
	if settings.HITSOUND_PRESET ~= nil then self:SetHitSoundPreset(settings.HITSOUND_PRESET) end
	if settings.HITSOUND_VOLUME ~= nil then self:SetHitSoundVolume(settings.HITSOUND_VOLUME) end

	if settings.OFFSCREEN_ENABLED ~= nil then self:SetOffscreenEnabled(settings.OFFSCREEN_ENABLED) end
	if settings.OFFSCREEN_COLOR then self:SetOffscreenColor(toColor3(settings.OFFSCREEN_COLOR) or self.OFFSCREEN_COLOR) end

	if settings.WALLBANG_ENABLED ~= nil then self:SetWallbangEnabled(settings.WALLBANG_ENABLED) end
	if settings.WALLBANG_ENTRY_COLOR then self:SetWallbangEntryColor(toColor3(settings.WALLBANG_ENTRY_COLOR) or self.WALLBANG_ENTRY_COLOR) end
	if settings.WALLBANG_EXIT_COLOR then self:SetWallbangExitColor(toColor3(settings.WALLBANG_EXIT_COLOR) or self.WALLBANG_EXIT_COLOR) end
	if settings.WALLBANG_MARKER_SIZE ~= nil then self:SetWallbangMarkerSize(settings.WALLBANG_MARKER_SIZE) end
	if settings.WALLBANG_LIFETIME ~= nil then self:SetWallbangLifetime(settings.WALLBANG_LIFETIME) end

	if settings.KILLFX_ENABLED ~= nil then self:SetKillFXEnabled(settings.KILLFX_ENABLED) end
	if settings.KILLFX_TYPE ~= nil then self:SetKillFXType(settings.KILLFX_TYPE) end
	if settings.KILLFX_COLOR then self:SetKillFXColor(toColor3(settings.KILLFX_COLOR) or self.KILLFX_COLOR) end
	if settings.KILLFX_LIGHT_COLOR then self:SetKillFXLightColor(toColor3(settings.KILLFX_LIGHT_COLOR) or self.KILLFX_LIGHT_COLOR) end
	if settings.KILLFX_CUSTOM_DURATION ~= nil then self:SetKillFXDuration(settings.KILLFX_CUSTOM_DURATION) end
	if settings.KILLFX_LIGHT_RANGE ~= nil then self:SetKillFXLightRange(settings.KILLFX_LIGHT_RANGE) end
	if settings.KILLFX_LIGHT_BRIGHTNESS ~= nil then self:SetKillFXLightBrightness(settings.KILLFX_LIGHT_BRIGHTNESS) end

	if settings.KILLIMAGE_ENABLED ~= nil then self:SetKillImageEnabled(settings.KILLIMAGE_ENABLED) end
	if settings.KILLIMAGE_COLOR then self:SetKillImageColor(toColor3(settings.KILLIMAGE_COLOR) or self.KILLIMAGE_COLOR) end
	if settings.KILLIMAGE_MAX_ALPHA ~= nil then self:SetKillImageMaxAlpha(settings.KILLIMAGE_MAX_ALPHA) end

	if settings.BACKTRACK_GHOST_ENABLED ~= nil then self:SetBacktrackGhostEnabled(settings.BACKTRACK_GHOST_ENABLED) end
	if settings.BACKTRACK_GHOST_COLOR then self:SetBacktrackGhostColor(toColor3(settings.BACKTRACK_GHOST_COLOR) or self.BACKTRACK_GHOST_COLOR) end
	if settings.BACKTRACK_GHOST_DURATION ~= nil then self:SetBacktrackGhostDuration(settings.BACKTRACK_GHOST_DURATION) end

	if settings.TRACER_ENABLED ~= nil then self:SetTracerEnabled(settings.TRACER_ENABLED) end
	if settings.TRACER_COLOR then self:SetTracerColor(toColor3(settings.TRACER_COLOR) or self.TRACER_COLOR) end
	if settings.TRACER_LIFETIME ~= nil then self:SetTracerLifetime(settings.TRACER_LIFETIME) end
	if settings.TRACER_WIDTH ~= nil then self:SetTracerWidth(settings.TRACER_WIDTH) end
	if settings.TRACER_NEON ~= nil then self:SetTracerNeon(settings.TRACER_NEON) end
	if settings.TRACER_STYLE then self:SetTracerStyle(settings.TRACER_STYLE) end

	if settings.CHINA_HAT_ENABLED ~= nil then self:SetChinaHatEnabled(settings.CHINA_HAT_ENABLED) end
	if settings.CHINA_HAT_COLOR then self:SetChinaHatColor(toColor3(settings.CHINA_HAT_COLOR) or self.CHINA_HAT_COLOR) end
	if settings.WINGS_ENABLED ~= nil then self:SetWingsEnabled(settings.WINGS_ENABLED) end
	if settings.WINGS_COLOR then self:SetWingsColor(toColor3(settings.WINGS_COLOR) or self.WINGS_COLOR) end
	if settings.AURA_ENABLED ~= nil then self:SetAuraEnabled(settings.AURA_ENABLED) end
	if settings.AURA_COLOR then self:SetAuraColor(toColor3(settings.AURA_COLOR) or self.AURA_COLOR) end
	if settings.JUMP_CIRCLES_ENABLED ~= nil then self:SetJumpCirclesEnabled(settings.JUMP_CIRCLES_ENABLED) end
	if settings.JUMP_CIRCLES_COLOR then self:SetJumpCirclesColor(toColor3(settings.JUMP_CIRCLES_COLOR) or self.JUMP_CIRCLES_COLOR) end

	if settings.HIT_MARKER_ENABLED ~= nil then self:SetHitMarkerEnabled(settings.HIT_MARKER_ENABLED) end

	if settings.ATMOSPHERE_ENABLED ~= nil then self:SetAtmosphereEnabled(settings.ATMOSPHERE_ENABLED) end
	if settings.ATMOSPHERE_DENSITY ~= nil then self:SetAtmosphereDensity(settings.ATMOSPHERE_DENSITY) end
	if settings.ATMOSPHERE_OFFSET ~= nil then self:SetAtmosphereOffset(settings.ATMOSPHERE_OFFSET) end
	if settings.ATMOSPHERE_COLOR then self:SetAtmosphereColor(toColor3(settings.ATMOSPHERE_COLOR) or self.ATMOSPHERE_COLOR) end
	if settings.ATMOSPHERE_DECAY then self:SetAtmosphereDecay(toColor3(settings.ATMOSPHERE_DECAY) or self.ATMOSPHERE_DECAY) end
	if settings.ATMOSPHERE_GLARE ~= nil then self:SetAtmosphereGlare(settings.ATMOSPHERE_GLARE) end
	if settings.ATMOSPHERE_HAZE ~= nil then self:SetAtmosphereHaze(settings.ATMOSPHERE_HAZE) end

	if settings.BLOOM_ENABLED ~= nil then self:SetBloomEnabled(settings.BLOOM_ENABLED) end
	if settings.BLOOM_INTENSITY ~= nil then self:SetBloomIntensity(settings.BLOOM_INTENSITY) end
	if settings.BLOOM_SIZE ~= nil then self:SetBloomSize(settings.BLOOM_SIZE) end
	if settings.BLOOM_THRESHOLD ~= nil then self:SetBloomThreshold(settings.BLOOM_THRESHOLD) end

	if settings.COLOR_CORRECTION_ENABLED ~= nil then self:SetColorCorrectionEnabled(settings.COLOR_CORRECTION_ENABLED) end
	if settings.COLOR_CORRECTION_BRIGHTNESS ~= nil then self:SetColorCorrectionBrightness(settings.COLOR_CORRECTION_BRIGHTNESS) end
	if settings.COLOR_CORRECTION_CONTRAST ~= nil then self:SetColorCorrectionContrast(settings.COLOR_CORRECTION_CONTRAST) end
	if settings.COLOR_CORRECTION_SATURATION ~= nil then self:SetColorCorrectionSaturation(settings.COLOR_CORRECTION_SATURATION) end
	if settings.COLOR_CORRECTION_TINT then self:SetColorCorrectionTint(toColor3(settings.COLOR_CORRECTION_TINT) or self.COLOR_CORRECTION_TINT) end
end

function VisualsModule:Start()
end

return VisualsModule
